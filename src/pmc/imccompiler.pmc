
#include "imcc/embed.h"
#include "pmc/pmc_sub.h"

/* HEADERIZER HFILE: none */

pmclass IMCCompiler auto_attrs provides HLLCompiler provide invokable {
    ATTR imc_info_t *imcc_info;
    ATTR INTVAL is_pasm; /* 0 = PIR, 1 = PASM */
    ATTR INTVAL current_eval;

    VTABLE void init() {
        Parrot_ex_throw_from_c_args(INTERP, NULL, EXCEPTION_INVALID_OPERATION,
            "IMCCompiler: Must initialize with an integer argument 0 (PIR) or 1 (PASM)");
    }

    VTABLE void init_pmc(PMC *init) {
        const INTVAL type = VTABLE_get_integer(INTERP, init);
        VTABLE_init_int(INTERP, SELF, type);
    }

    VTABLE void init_int(INTVAL is_pasm) {
        Parrot_IMCCompiler_attributes * const attrs = PARROT_IMCCOMPILER(SELF);
        if (is_pasm != 0 && is_pasm != 1)
            Parrot_ex_throw_from_c_args(INTERP, NULL, EXCEPTION_INVALID_OPERATION,
                "IMCCompiler: Must have type 0 (PIR) or 1 (PASM)");
        attrs->is_pasm = is_pasm;
        attrs->imcc_info = imcc_new(INTERP);
        attrs->current_eval = 0;
    }

    /* provided to emulate the current NCI compreg */
    VTABLE void* invoke(void* next) {
        Parrot_IMCCompiler_attributes * const attrs = PARROT_IMCCOMPILER(SELF);
        PMC * const ctx = CURRENT_CONTEXT(INTERP);
        PMC * cont = INTERP->current_cont;
        PMC * const call_object = Parrot_pcc_get_signature(interp, ctx);
        PackFile_ByteCode * const cur_code = interp->code;
        PackFile * pf = NULL;
        STRING * code = STRINGNULL;
        PMC * result = PMCNULL;
        PMC * eval_pmc = PMCNULL;
        UINTVAL regs_used[4] = {3, 3, 3, 3};
        PMC * const newcontext = Parrot_push_context(interp, regs_used);

        Parrot_block_GC_mark(interp);
        //Parrot_pcc_set_HLL(interp, newcontext, 0);
        Parrot_pcc_set_sub(interp, newcontext, 0);

        Parrot_pcc_fill_params_from_c_args(INTERP, call_object, "S", &code);
        imcc_reset(attrs->imcc_info);
        result = imcc_compile_string(attrs->imcc_info, code, attrs->is_pasm);
        if (PMC_IS_NULL(result)) {
            STRING * const msg = imcc_last_error_message(attrs->imcc_info);
            INTVAL code = imcc_last_error_code(attrs->imcc_info);
            Parrot_unblock_GC_mark(interp);
            Parrot_ex_throw_from_c_args(INTERP, NULL, code, "%Ss", msg);
        }
        pf = (PackFile*)VTABLE_get_pointer(INTERP, result);
        {
            Parrot_Sub_attributes *sub_data;

            eval_pmc = Parrot_pmc_new(INTERP, enum_class_Eval);
            PMC_get_sub(INTERP, eval_pmc, sub_data);
            sub_data->seg = pf->cur_cs;
            sub_data->start_offs = 0;
            sub_data->end_offs = pf->cur_cs->base.size;
            sub_data->name = Parrot_sprintf_c(INTERP, "EVAL_%d", attrs->current_eval);
            attrs->current_eval++;
            PackFile_fixup_subs(INTERP, PBC_MAIN, eval_pmc);
        }

        Parrot_pop_context(interp);
        Parrot_unblock_GC_mark(interp);

        /* Handle the case where we we've been tailcalled into. See NCI.invoke
           for more details */
        if (cont && cont != NEED_CONTINUATION
        && (PObj_get_FLAGS(cont) & SUB_FLAG_TAILCALL)) {
            cont = Parrot_pcc_get_continuation(interp, CURRENT_CONTEXT(interp));
            next = VTABLE_invoke(INTERP, cont, next);
        }

        Parrot_pcc_build_call_from_c_args(INTERP, call_object, "P", eval_pmc);
        interp->code = cur_code;
        return next;
    }

    VTABLE void *get_pointer() {
        Parrot_IMCCompiler_attributes * const attrs = PARROT_IMCCOMPILER(SELF);
        return attrs->imcc_info;
    }

    VTABLE INTVAL get_integer() {
        Parrot_IMCCompiler_attributes * const attrs = PARROT_IMCCOMPILER(SELF);
        return attrs->is_pasm;
    }

    VTABLE STRING *get_string() {
        Parrot_IMCCompiler_attributes * const attrs = PARROT_IMCCOMPILER(SELF);
        if (attrs->is_pasm)
            return CONST_STRING(INTERP, "PASM");
        else
            return CONST_STRING(INTERP, "PIR");
    }

    VTABLE void destroy() {
        Parrot_IMCCompiler_attributes * const attrs = PARROT_IMCCOMPILER(SELF);
        imcc_destroy(attrs->imcc_info);
        attrs->imcc_info = NULL;
    }

    METHOD compile(STRING *source,
            STRING *target :named("target") :optional, INTVAL has_target :opt_flag,
            PMC *outer_ctx :named("outer_ctx") :optional, INTVAL has_ctx :opt_flag
    ) {
        Parrot_IMCCompiler_attributes * const attrs = PARROT_IMCCOMPILER(SELF);
        PMC * pf = PMCNULL;
        if (has_target)
            Parrot_ex_throw_from_c_args(INTERP, NULL, EXCEPTION_INVALID_OPERATION,
                "IMCCompiler: compiler does not support the target option");
        /* TODO: Handle outer_ctx */
        pf = imcc_compile_string(attrs->imcc_info, source, attrs->is_pasm);
        imcc_reset(attrs->imcc_info);
        RETURN(PMC *pf);
    }

    METHOD compile_file(STRING *filename,
            STRING *target :named("target") :optional, INTVAL has_target :opt_flag,
            PMC *outer_ctx :named("outer_ctx") :optional, INTVAL has_ctx :opt_flag
    ) {
        Parrot_IMCCompiler_attributes * const attrs = PARROT_IMCCOMPILER(SELF);
        PMC * pf = PMCNULL;
        UINTVAL regs_used[4] = {3, 3, 3, 3};
        PMC * const newcontext = Parrot_push_context(interp, regs_used);



        if (has_target)
            Parrot_ex_throw_from_c_args(INTERP, NULL, EXCEPTION_INVALID_OPERATION,
                "IMCCompiler: compiler does not support the target option");

        Parrot_block_GC_mark(interp);
        Parrot_pcc_set_HLL(interp, newcontext, 0);
        Parrot_pcc_set_sub(interp, newcontext, 0);

        /* TODO: Handle outer_ctx */
        pf = imcc_compile_file(attrs->imcc_info, filename, attrs->is_pasm);
        if (PMC_IS_NULL(pf)) {
            STRING * const msg = imcc_last_error_message(attrs->imcc_info);
            INTVAL code = imcc_last_error_code(attrs->imcc_info);
            Parrot_ex_throw_from_c_args(INTERP, NULL, code, "%Ss", msg);
        }

        Parrot_pop_context(interp);
        Parrot_unblock_GC_mark(interp);

        RETURN(PMC *pf);
    }

    METHOD eval(STRING *source,
            STRING *target :named("target") :optional, INTVAL has_target :opt_flag,
            PMC *outer_ctx :named("outer_ctx") :optional, INTVAL has_ctx :opt_flag
    ) {
        Parrot_IMCCompiler_attributes * const attrs = PARROT_IMCCOMPILER(SELF);
        PMC * pf = PMCNULL;
        if (has_target)
            Parrot_ex_throw_from_c_args(INTERP, NULL, EXCEPTION_INVALID_OPERATION,
                "IMCCompiler: compiler does not support the target option");
        /* TODO: Handle outer_ctx */
        pf = imcc_compile_string(attrs->imcc_info, source, attrs->is_pasm);
        /* TODO: Execute it */
    }

    METHOD preprocess(STRING *code) {
        Parrot_IMCCompiler_attributes * const attrs = PARROT_IMCCOMPILER(SELF);
        imcc_preprocess(attrs->imcc_info, code);
    }

    METHOD parse_name(STRING *name) {
        Parrot_ex_throw_from_c_args(INTERP, NULL, EXCEPTION_UNIMPLEMENTED,
                "IMCCompiler: parse_name is not supported");
    }

    METHOD load_module(STRING *name) {
        /* TODO: This */
    }

    METHOD get_module(STRING *name) {
        /* TODO: This */
    }

    METHOD get_exports(PMC *module) {
        /* TODO: This */
    }
}
