/*
Copyright (C) 2001-2008, The Perl Foundation.
$Id$

=head1 NAME

src/pmc/stmvar.pmc -- A transactional variable

=head1 DESCRIPTION

A transactional variable for Parrot's Software Transactional Memory (STM)
implementation.

=head2 Methods

=over 4

=cut

*/

#include "parrot/parrot.h"
#include "parrot/stm/backend.h"

#define PMC_STM_handle(o) ((Parrot_STM_PMC_handle)PMC_struct_val(o))

/* we set need_ext here because we really want to have PMC sync structure;
 * we set no_ro because we are logically read-only; one can't change which
 * transactional object this references (though one can change that
 * object)
 */

pmclass STMVar is_shared need_ext no_ro {

/*

=item C<void init()>

Initialize the STMVar PMC. Allocates the necessary STM data structures for the
PMC and sets the PObj_custom_mark flag.

=item C<void init_pmc(value)>

Initializes a new STMVar PMC based on PMC C<value>. If C<value> is another STMVar
or an STMRef PMC, we simply copy the PMC internals of that PMC into this one.
If not, we create a new STM structure based on C<value> and assign that to this
PMC.

=cut

*/
    VTABLE void init() {
        PMC_struct_val(SELF) = NULL;
        PMC_struct_val(SELF) = Parrot_STM_alloc(INTERP, PMCNULL);
        PObj_custom_mark_SET(SELF);
    }

    VTABLE void init_pmc(PMC *value) {
        PMC_struct_val(SELF) = NULL;

        if (value->vtable->base_type == enum_class_STMRef ||
            value->vtable->base_type == enum_class_STMVar)
            PMC_struct_val(SELF) = PMC_struct_val(value);
        else
            PMC_struct_val(SELF) = Parrot_STM_alloc(INTERP, value);

        PObj_custom_mark_SET(SELF);
    }
/*

=item C<PMC *clone()>

Return the STMVar PMC.

=cut

*/

    VTABLE PMC *clone() {
        return SELF;
    }

/*

=item C<void mark()>

Mark data associated with this transactional variable.

=cut

*/

    VTABLE void mark() {
        PARROT_ASSERT(PObj_is_PMC_shared_TEST(SELF));
        PARROT_ASSERT(PMC_sync(SELF)->owner == INTERP);

        Parrot_STM_mark_pmc_handle(INTERP, PMC_STM_handle(SELF));
    }

/*

=item C<get_read>

Reads the current STM value of the PMC

=item C<get_update>

Begin an STM process on this PMC, and return a PMC pointer to the updated data.

=item C<set>

Writes the value C<new_value> to the PMC, or begins an STM transaction to do that.

=item C<freeze>

Freeze the PMC into a serial format.

=item C<thaw>

Thaws the PMC from a serial bytecode format

=item C<share_ro>

TODO: Document this!

=cut

*/

    METHOD get_read() {
        PMC *read = Parrot_STM_read(INTERP, PMC_STM_handle(SELF));
        RETURN(PMC *read);
    }

    METHOD get_update() {
        PMC *update = Parrot_STM_begin_update(INTERP, PMC_STM_handle(SELF));
        RETURN(PMC *update);
    }

    METHOD set(PMC *new_value) {
        Parrot_STM_write(INTERP, PMC_STM_handle(SELF), new_value);
    }

    VTABLE void freeze(visit_info *info) {
        IMAGE_IO * const io = info->image_io;

        SUPER(info);

        Parrot_freeze_STM_PMC_handle(INTERP, io, PMC_STM_handle(SELF));
    }

    VTABLE void thaw(visit_info *info) {
        IMAGE_IO * const io = info->image_io;

        SUPER(info);

        PMC_struct_val(SELF) = Parrot_thaw_STM_PMC_handle(INTERP, io);

        PARROT_ASSERT(PObj_is_PMC_shared_TEST(SELF));
        PARROT_ASSERT(PMC_sync(SELF));
    }

    /* we can do this because we don't modify ourself in dangerous
       ways -- we are always a reference to the same transactional
       variable.
     */
    VTABLE PMC *share_ro() {
        return pt_shared_fixup(INTERP, SELF);
    }
}

/*

=back

*/

/*
 * Local variables:
 *   c-file-style: "parrot"
 * End:
 * vim: expandtab shiftwidth=4:
 */
