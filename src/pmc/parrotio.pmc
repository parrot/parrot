/*
Copyright (C) 2001-2008, The Perl Foundation.
$Id$

=head1 NAME

src/pmc/parrotio.pmc - Parrot IO

=head1 DESCRIPTION

These are the vtable functions and methods for Parrot IO.

=head2 Methods

=over 4

=cut

*/

#include "parrot/parrot.h"

/* This class is actually part of the io subsystem */
#include "../src/io/io_private.h"

#ifdef PARROT_HAS_READLINE
#ifdef __cplusplus
extern "C" {
#endif
char *readline(const char *);
void add_history(const char*);
#ifdef __cplusplus
}
#endif
#endif

pmclass ParrotIO need_ext {

/*

=item C<METHOD say(STRING *s)>

Print the string with an appended newline to SELF or to stdout if used as a
class method.

=cut

*/

    METHOD say(STRING *s) {
        PMC * const out = SELF == interp->vtables[enum_class_ParrotIO]->pmc_class ?
            PIO_STDOUT(INTERP) : SELF;
        const INTVAL r = PIO_putps(INTERP, out, s) +
                         PIO_puts(INTERP, out, "\n");
        RETURN(INTVAL r);
    }
/*

=item C<METHOD open(STRING *file, STRING *mode, STRING *layer)>

Opens the file with the given mode, using the given IO layer.

=cut

*/

    METHOD open(STRING *file, STRING *mode, STRING *layer) {
        ParrotIOLayer * l;
        PMC * pio;
        int is_mmap;

        { /* Scope for temporary C string */
            char * const c_layer = string_to_cstring(INTERP, layer);

            is_mmap = STREQ(c_layer, "mmap");
            l = PIO_get_layer(INTERP, c_layer);

            string_cstring_free(c_layer);
        }

        { /* Scope for temporary C strings */
            char * const c_file  = string_to_cstring(INTERP, file);
            char * const c_mode  = string_to_cstring(INTERP, mode);

            pio = PIO_open(INTERP, l, c_file, c_mode);

            string_cstring_free(c_file);
            string_cstring_free(c_mode);
        }

        if (!pio || !PMC_struct_val(pio)) {
            PMC *retval = pmc_new(INTERP, enum_class_Undef);
            RETURN(PMC *retval);
        }

        if (l) {
            ParrotIO * const io = (ParrotIO *)PMC_data(pio);

            /* RT #46079 move this into the layer */
            if ((is_mmap && (io->b.flags & PIO_BF_MMAP)) || !is_mmap) {
                l = interp->piodata->default_stack;

                if (STREQ(l->name, "buf"))
                    l = l->down;

                /* RT #46081 layer is stored twice - which is used when */
                io->stack           = l;
                PMC_struct_val(pio) = l;

                /* push the layer */
                PIO_push_layer_str(INTERP, pio, layer);
            }
            else {
                l                   = interp->piodata->default_stack;
                io->stack           = l;
                PMC_struct_val(pio) = l;
            }
        }

        RETURN(PMC *pio);
    }

/*

=item C<METHOD isatty()>

=cut

*/
    METHOD isatty() {
        const ParrotIO * const io  = (ParrotIO *)PMC_data(SELF);
        INTVAL isatty = (io->flags & PIO_F_CONSOLE) == PIO_F_CONSOLE;
        RETURN(INTVAL isatty);
    }

/*

=item C<METHOD set_readline_interactive(INTVAL)>

Sets readline interactive mode to the given value, if PARROT_HAS_READLINE is
defined, that is, if the readline library is available.  The return values are:

=over

=item * -1

readline isn't configured

=item * -2

The file is not open/not input or not a tty, if turning on interactive.

=item * 0 / 1

old interactive setting

=back

=item C<METHOD readline(STRING *prompt)>

Reads a line from the given PIO. If readline is interactive and a prompt
is not empty, it will be displayed. The interactive feature is not
available with the C<readline> opcode (which will be removed anyway).
Interactive mode adds non-empty lines to the readline history.

Returns the line without the newline in a String PMC. If ^D/eof occurred,
this will return a Null PMC.

SYNOPSIS

      pio = getstdin
      $I0 = pio.'set_readline_interactive'(1)
      if $I0 >= 0 goto loop
      printerr "set_readline_interactive failed: "
      ...
  loop:
      $P1 = pio.'readline'('hello polly> ')
      if null $P1  goto ex
      ..
      goto loop
  ex:

=cut

*/

    METHOD set_readline_interactive(INTVAL on) {
        ParrotIO * const io = (ParrotIO *)PMC_data(SELF);
        if (!io)
            RETURN(INTVAL -2);
        if (!(io->flags & PIO_F_READ))
            RETURN(INTVAL -2);

#ifdef PARROT_HAS_READLINE
        {
            INTVAL flag;
            if (on && !(io->flags & PIO_F_CONSOLE))
                RETURN(INTVAL -2);
            flag = !!(io->flags & PIO_F_READLINE);

            if (on)
                io->flags |= PIO_F_READLINE;
            else
                io->flags &= ~PIO_F_READLINE;

            RETURN(INTVAL flag);
        }
#else
        RETURN(INTVAL -1);
#endif
    }

    METHOD readline(STRING *prompt) {
        ParrotIO * const io = (ParrotIO *)PMC_data(SELF);

        if (!io)
            RETURN(PMC *PMCNULL);

#ifdef PARROT_HAS_READLINE
        if (io->flags & PIO_F_READLINE) {
            char * const r = readline(prompt ? prompt->strstart : NULL);

            if (r) {
                STRING *res;
                PMC    *pmc_res;

                if (*r)
                    add_history(r);

                res                  = string_from_cstring(INTERP, r, 0);
                mem_sys_free(r);
                pmc_res              = pmc_new(INTERP, enum_class_String);
                PMC_str_val(pmc_res) = res;
                RETURN(PMC *pmc_res);
            }

            RETURN(PMC *PMCNULL);
        }
        else
#endif
        {
            STRING *res;
            PMC    *pmc_res;
            UINTVAL len;

            if (!(io->flags & PIO_F_LINEBUF))
                PIO_setlinebuf(interp, SELF);

            res = PIO_reads(interp, SELF, 0);

            if (!res)
                RETURN(PMC *PMCNULL);

            /* readline should better return the string w/o NL */
            len = string_length(INTERP, res);
            while (len &&
                    (((char*)res->strstart)[len - 1] == '\n' ||
                     ((char*)res->strstart)[len - 1] == '\r')) {
                --len;
                --res->strlen;
                --res->bufused;
            }

            pmc_res              = pmc_new(INTERP, enum_class_String);
            PMC_str_val(pmc_res) = res;
            RETURN(PMC *pmc_res);
        }
    }

/*

=item METHOD slurp(STRING *name);

Slurp an (existing, disc) file named I<name> into a STRING result.

Please note that this method isn't catching any failures yet.

Usage as class method:

  .local pmc cl
  cl = get_class 'ParrotIO'
  $S0 = cl.'slurp'('the_file')

The file will be opened, read, and closed.

Or with an openend file:

  pio = open 'the_file', '<'
  $S0 = pio.'slurp'('')

This does B<not> close the file.

=cut

*/

    METHOD slurp(STRING *name) {
        STRING *result;

        if (!PMC_data0(SELF)) {
            /* called as class method - open, slurp, close file */
            char * const path = string_to_cstring(interp, name);
            PMC  * const pio  = PIO_open(INTERP, NULL, path, "<");
            const size_t size =
                (size_t)(Parrot_stat_info_intval(INTERP, name, STAT_FILESIZE));

            string_cstring_free(path);

            /* RT #46085 handle stdin */
            result = PIO_reads(INTERP, pio, size);
            PIO_close(INTERP, pio);
            RETURN(STRING *result);
        }
        else {
            /* slurp open file */
            if (!PMC_data(SELF))
                Parrot_ex_throw_from_c_args(interp, NULL, EXCEPTION_PIO_ERROR,
                    "Cannot slurp from empty filehandle");

            result = string_make_empty(INTERP, enum_stringrep_one, 0);

            do {
                STRING * const part = PIO_reads(INTERP, SELF, 4096);

                if (string_length(INTERP, part) == 0)
                    break;
                result = string_append(INTERP, result, part);
            } while (1);
        }

        RETURN(STRING *result);
    }

/*

=item C<METHOD eof()>

Returns true or false according to the end of file state of the object.

=item C<METHOD flush()>

Flushes pending writes.

=item C<METHOD setbuf(INTVAL)>

RT #46087 TBD

=item C<METHOD setlinebuf()>

RT #46089 TBD

=item C<METHOD INTVAL get_fd()>

Get the file descriptor out of the ParrotIO object.

RT #48312 Still to do: integral file descriptors might not exist outside of the UNIX platform.
                      or for other streams.

=cut

*/

    METHOD get_fd() {
         const INTVAL r = PIO_getfd(INTERP, SELF);
         RETURN(INTVAL r);
    }

/*

=item C<void class_init()>

Class initialization.

=cut

*/

    void class_init() {
        if (pass) {
            register_nci_method(INTERP, enum_class_ParrotIO,
                    F2DPTR(PIO_flush), "flush", "vJO");
            register_nci_method(INTERP, enum_class_ParrotIO,
                    F2DPTR(PIO_setbuf), "setbuf", "iJOi");
            register_nci_method(INTERP, enum_class_ParrotIO,
                    F2DPTR(PIO_setlinebuf), "setlinebuf", "iJO");
            register_nci_method(INTERP, enum_class_ParrotIO,
                    F2DPTR(PIO_puts), "puts", "iJOt");
            register_nci_method(INTERP, enum_class_ParrotIO,
                    F2DPTR(PIO_eof), "eof", "iJO");
        }
    }

/*

=item C<void init()>

Initializes the IO PMC.

=cut

*/

    VTABLE void init() {
        PObj_active_destroy_SET(SELF);
    }

/*

=item C<void destroy()>

Destroys the IO PMC, flushing and closing as necessary.

=cut

*/

    VTABLE void destroy() {
        ParrotIO * const io = (ParrotIO *)PMC_data(SELF);

        if (io) {
            /* shared filehandles will only get flushed */
            if (io->flags & PIO_F_SHARED)
                PIO_flush(INTERP, SELF);
            else
                PIO_close(INTERP, SELF);

            PIO_destroy(interp, SELF);
        }
    }

/*

=item C<PMC *clone()>

Clones the IO PMC.

For now, both PMCs refer to the same C<ParrotIO> object. If we have different
IO layers, we might copy C<data> and C<struct_val>.

=cut

*/

    VTABLE PMC *clone() {
        PMC * const dest     = PIO_dup(INTERP, SELF);
        return dest;
    }
    /*

=item C<void assign_pmc(PMC *other)>

Set SELF to the data in other.

=cut

*/

    VTABLE void set_pmc(PMC *other) {
        SELF.assign_pmc(other);
    }

    VTABLE void assign_pmc(PMC *other) {
        PMC * clone;
        /* only handle the case where the other PMC is the same type */
        if (other->vtable->base_type == SELF->vtable->base_type) {
            clone = VTABLE_clone(INTERP, other);
            PMC_data(SELF)       = PMC_data(clone);
            PMC_struct_val(SELF) = PMC_struct_val(clone);
            /* prevent the clone from freeing its data when it's gc'd */
            PObj_active_destroy_CLEAR(clone);
            if (PObj_is_PMC_EXT_TEST(clone))
              clone->pmc_ext = NULL;

        }
        else {
            Parrot_ex_throw_from_c_args(INTERP, NULL, EXCEPTION_INVALID_OPERATION,
                "Can't assign a non-IO type to an IO");
        }
    }

/*

=item C<INTVAL get_bool()>

Returns whether at C<EOF> or not.

=cut

*/

    VTABLE INTVAL get_bool() {
        return !PIO_eof(INTERP, SELF);
    }

/*

=item C<STRING *get_string_keyed_int(INTVAL n)>

Returns the name of the nth layer. B<n> >= 0 returns layer names up from the
bottom.  If B<n> is negative, returns layer names from top down. For
non-existent layers, returns an empty string.

=cut

*/

    VTABLE STRING *get_string_keyed_int(INTVAL n) {
        ParrotIO * const io = (ParrotIO *)PMC_data(SELF);

        if (io) {
            ParrotIOLayer *layer = io->stack;

            if (n >= 0) {
                ParrotIOLayer *last = layer;
                for (; layer; layer = layer->down)
                    last = layer;

                for (; n && last; --n, last = last->up)
                    ;

                if (last)
                    return string_from_cstring(INTERP, last->name, 0);

                return string_from_literal(INTERP, "");
            }

            for (++n; n && layer; layer = layer->down, ++n)
                ;

            if (layer)
                return string_from_cstring(INTERP, layer->name, 0);
        }

        return string_from_literal(INTERP, "");
    }
/*

=item C<void push_string(STRING *value)>

Pushes the layer name C<value> onto the PIO's layer stack.

=item C<STRING *pop_string()>

Pops a layer off the PIO's layer stack and returns its name.

=cut

*/

    VTABLE void push_string(STRING *value) {
        PIO_push_layer_str(INTERP, SELF, value);
    }

    VTABLE STRING *pop_string() {
        return PIO_pop_layer_str(INTERP, SELF);
    }

}

/*

=back

=cut

*/

/*
 * Local variables:
 *   c-file-style: "parrot"
 * End:
 * vim: expandtab shiftwidth=4:
 */
