/*
Copyright (C) 2001-2008, Parrot Foundation.
$Id$

=head1 NAME

src/pmc/retcontinuation.pmc - Return Continuation

=head1 DESCRIPTION

C<RetContinuation> extends C<Continuation>.

A return continuation is a one shot Continuation.  It gets recycled immediately
after invocation.

=head2 Methods

=over 4

=cut

*/

#include "parrot/oplib/ops.h"

pmclass RetContinuation extends Continuation need_ext {

/*

=item C<void init()>

Initializes the continuation.

=cut

*/

    VTABLE void init() {
        Parrot_RetContinuation_attributes * const attrs =
            mem_allocate_typed(Parrot_RetContinuation_attributes);

        PMC_data(SELF) = attrs;
        PMC_cont(SELF) = new_ret_continuation(INTERP);

        PObj_custom_mark_destroy_SETALL(SELF);
    }

    /*
     * XXX when reusing SUPER.destroy() RetContinuations
     *     have to set ref_count initially to 1
     */

    VTABLE void destroy() {
        Parrot_cont * const cc = PMC_cont(SELF);

        if (cc)
            mem_sys_free(cc);

        mem_sys_free(PMC_data(SELF));
    }
/*

=item C<PMC *clone>

Return a new Continuation PMC with the context of SELF. Note: the returned
object is not a RetContinuation and creating a real Continuation invalidates
all RetContinuation all the way up the call chain.  That is, these can't be
recycled; they persist until the GC gets at them.

=cut

*/
    VTABLE PMC *clone() {
        invalidate_retc_context(INTERP, SELF);
        return SUPER();
    }
/*

=item C<opcode_t *invoke(void *next)>

Transfers control to the calling context and frees the current context.

=cut

*/

    VTABLE opcode_t *invoke(void *in_next) {
        Parrot_cont       *cc         = PMC_cont(SELF);
        Parrot_Context    *from_ctx   = cc->from_ctx;
        PackFile_ByteCode * const seg = cc->seg;
        opcode_t          *next       = cc->address;
        UNUSED(in_next)

        Parrot_continuation_check(interp, SELF, cc);
        Parrot_continuation_rewind_environment(interp, SELF, cc);
        Parrot_free_context(INTERP, from_ctx, 1);

        /* the continuation is dead - delete and destroy it */
        /* This line causes a failure in t/pmc/packfiledirectory.t. No idea
           what the relationship is between this line of code and that test
           failure. Will look into it later */
        /* Parrot_gc_free_pmc_header(interp, SELF); */

        if (INTERP->code != seg)
            Parrot_switch_to_cs(INTERP, seg, 1);

        return next;
    }
}


/*

=back

=head1 HISTORY

Initial revision by sean 2002/08/04.

=cut

*/

/*
 * Local variables:
 *   c-file-style: "parrot"
 * End:
 * vim: expandtab shiftwidth=4:
 */
