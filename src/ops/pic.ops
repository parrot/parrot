/*
** pic.ops
*/

#define DEPRECATED internal_exception(UNIMPLEMENTED, "you shouldn't see this")

#include "parrot/oplib/ops.h"

typedef opcode_t* (*interface_f)(Interp*, INTVAL*, void **);

VERSION = PARROT_VERSION;

=head1 NAME

pic.ops - PIC (Polymorphic Inline Cache) opcode variants

=cut

=head1 DESCRIPTION

During predereferencing opcodes that allow caching are rewritten so that
equivalent opcodes in this file are used. User code MUST never emit these
opcodes directly.

###############################################################################

=head2 General infix operations

These operations take an infix operation number and PMC arguments.

########################################

=cut

=over 4

=item B<pic_infix__>(inconst INT, in PMC, in PMC)

One for fun and MOPS.

=cut

inline op pic_infix__(inconst INT, in PMC, in PMC) :pic {
    Parrot_MIC *mic;
    Parrot_PIC_lru *lru;
    PMC *left, *right;
    INTVAL lr_types;

    mic = (Parrot_MIC *) cur_opcode[1];
    left = $2;
    right = $3;
    lru = &mic->lru;
    lr_types = (left->vtable->base_type << 16) | right->vtable->base_type;
    if (lru->u.type == lr_types) {
runit_v_pp:
	((mmd_f_v_pp)lru->f.real_function)(interpreter, left, right);
	goto NEXT();
    }
    if (mic->pic) {
	lru = mic->pic->lru;
	if (lru->u.type == lr_types)
	    goto runit_v_pp;
	if (++lru->u.type == lr_types)
	    goto runit_v_pp;
	if (++lru->u.type == lr_types)
	    goto runit_v_pp;
	mic->pic->miss_count++;
	/*
	 * TODO if we got too often here just do a dynamic lookup
	 */
    }
    parrot_pic_find_infix_v_pp(interpreter, left, right, mic, cur_opcode);
    /* rerun this opcode */
    goto OFFSET(0);
}

=item B<pic_inline_sub__>(inconst INT, in PMC, in PMC)

And for more fun an inlined variant too.

=cut

inline op pic_inline_sub__(inconst INT, in PMC, in PMC) :pic {
    Parrot_MIC *mic;
    Parrot_PIC_lru *lru;
    PMC *left, *right;
    INTVAL lr_types, lt, rt;

    left = $2;
    mic = (Parrot_MIC *) cur_opcode[1];
    lt = left->vtable->base_type;
    right = $3;
    lru = &mic->lru;
    rt = right->vtable->base_type;
    lr_types = (lt << 16) | rt;
    if (lru->u.type == lr_types) {
	INTVAL a = lt == enum_class_Integer ? PMC_int_val(left) :
	    VTABLE_get_integer(interpreter, left);
	INTVAL b = rt == enum_class_Integer ? PMC_int_val(right) :
	    VTABLE_get_integer(interpreter, right);
	INTVAL c = a - b;
	if ((c^a) >= 0 || (c^~b) >= 0) {
	    if (lt == enum_class_Integer)
		PMC_int_val(left) = c;
	    else
		VTABLE_set_integer_native(interpreter, left, c);
	}
	else {
	    if (PARROT_ERRORS_test(interpreter,PARROT_ERRORS_OVERFLOW_FLAG)) {
		real_exception(interpreter, NULL, ERR_OVERFLOW,
			"Integer overflow");
	    }
	    /* TODO preserve type system */
	    VTABLE_morph(interpreter, left, enum_class_BigInt);
	    VTABLE_set_integer_native(interpreter, left, a);
	    mmd_dispatch_p_pip(interpreter, left, b, left, MMD_SUBTRACT);
	}
    }
    else {
        ((void**)cur_opcode)[0] =
            parrot_pic_opcode(interpreter, PARROT_OP_pic_infix___ic_p_p);
	goto OFFSET(0);
    }
    goto NEXT();
}

=item B<pic_get_params__>(inconst PMC /* , ... */)

Fetch function parameters for this subroutine.

=item B<pic_set_returns__>(inconst PMC /* , ... */)

Return values to caller.

=cut

inline op pic_get_params__(inconst PMC) :pic {
    Parrot_MIC *mic;
    Parrot_PIC_lru *lru;
    PMC *sig, *ccont;
    opcode_t *src_pc;
    void **src_pred;
    parrot_context_t *caller_ctx, *ctx;
    int n;

    /* avoid load dependencies - intermix derefs
     * - yes, confusing but faster
     */
    ctx = CONTEXT(interpreter->ctx);
    src_pc = interpreter->current_args;
    mic = (Parrot_MIC *) cur_opcode[1];
    caller_ctx = ctx->caller_ctx;
    if (src_pc) {
	src_pred = (void**) src_pc - caller_ctx->pred_offset;
	sig = (PMC*)(src_pred[1]);
    }
    else {
	sig = NULL;
	src_pred = NULL;	/* just for gcc */
    }
    lru = &mic->lru;
    if (lru->u.signature == sig) {
	if (sig) {
	    n = ((arg_pass_f)lru->f.real_function)(interpreter, sig,
		    (char*)caller_ctx->bp.regs_i, src_pred, 
		    _reg_base, (void**)cur_opcode);
	}
        else
            n = 2;
	ccont = ctx->current_cont;
	if (PObj_get_FLAGS(ccont) & SUB_FLAG_TAILCALL) {
	    PObj_get_FLAGS(ccont) &= ~SUB_FLAG_TAILCALL;
	    --ctx->recursion_depth;
	    ctx->caller_ctx = caller_ctx->caller_ctx;
	    Parrot_free_context(interpreter, caller_ctx, 1);
	}

	goto OFFSET(n);
    }
    /* no match redo plain opcode */
    ((void**)cur_opcode)[0] =
	parrot_pic_opcode(interpreter, PARROT_OP_get_params_pc);
    ((void**)cur_opcode)[1] = mic->m.sig;
    goto OFFSET(0);
}

inline op pic_set_returns__(inconst PMC) :pic {
    Parrot_MIC *mic;
    Parrot_PIC_lru *lru;
    PMC *sig, *ccont;
    opcode_t *dest_pc;
    void **dest_pred;
    parrot_context_t *caller_ctx, *ctx;
    parrot_cont_t cc;
    int n;

    ctx = CONTEXT(interpreter->ctx);
    mic = (Parrot_MIC *) cur_opcode[1];
    ccont = ctx->current_cont;
    cc = PMC_cont(ccont);
    if (!cc->address) {
	interpreter->current_returns = CUR_OPCODE;
        n = PMC_int_val(mic->m.sig);
	goto OFFSET(n + 2);
    }
    caller_ctx = cc->to_ctx;
    interpreter->current_args = NULL;
    dest_pc = caller_ctx->current_results;
    if (dest_pc) {
	dest_pred = (void**) dest_pc - caller_ctx->pred_offset;
	sig = (PMC*)(dest_pred[1]);
    }
    else {
	sig = NULL;
	dest_pred = NULL;
    }
    lru = &mic->lru;
    if (lru->u.signature == sig) {
	if (sig) {
	    n = ((arg_pass_f)lru->f.real_function)(interpreter, mic->m.sig,
		    _reg_base, (void**)cur_opcode, 
		    (char*)caller_ctx->bp.regs_i, dest_pred);
	}
        else
            n = 2;
	goto OFFSET(n);
    }
    /* no match redo plain opcode */
    ((void**)cur_opcode)[0] =
	parrot_pic_opcode(interpreter, PARROT_OP_set_returns_pc);
    ((void**)cur_opcode)[1] = mic->m.sig;
    goto OFFSET(0);
}

=item B<pic_callr__>(inconst PMC)

Call the function $1 as C<pc = func(interp, 0, **args)>. args[0] holds the
address of the function result, args[1..] are function arguments, both
according to the C<get_results> and C<set_args> opcodes. The function is
a C interface function (or NCI) or a JITed PIR function. args[n] holds the
C<pc> of the next opcode and is usually just returned.

=cut

inline op pic_callr__(inconst PMC) :pic {
    Parrot_MIC *mic;
    Parrot_PIC_lru *lru;
    void *args[6];      /* TODO ARG_MAX */
    parrot_context_t *ctx;
    opcode_t *pc;
    void **pred_pc;
    INTVAL n_args;

    ctx = CONTEXT(interpreter->ctx);
    mic = (Parrot_MIC *) cur_opcode[1];
    pc = ctx->current_results;
    if (pc) {
	pred_pc = (void**) pc - ctx->pred_offset;
        args[0] = (_reg_base + ((opcode_t*)pred_pc)[2]);
	assert((sig = (PMC*)(pred_pc[1])) &&
                    PObj_is_PMC_TEST(sig) &&
                    sig->vtable->base_type == enum_class_FixedIntegerArray &&
                    VTABLE_elements(interpreter, sig) == 1);
    }
    else
        args[0] = NULL;
    /* TODO set_args */
    n_args = 0;
    /* set_args (); set_p_pc; get_results (1), x; invokecc_p */
    pc = CUR_OPCODE + 2 + n_args + 3 + 3 + 2;    
    args[1 + n_args] = pc;
    lru = &mic->lru;
    /* TODO verify $1 didn't change */
    pc = ((interface_f)lru->f.real_function)(interpreter, NULL, args);
    goto ADDRESS(pc);
}

=back

=cut

###############################################################################

=head1 COPYRIGHT

Copyright (C) 2005 The Perl Foundation.  All rights reserved.

=head1 LICENSE

This program is free software. It is subject to the same license
as the Parrot interpreter itself.

=cut


/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
 * vim: expandtab shiftwidth=4 ft=c:
*/
