/*
** var.ops
*/

VERSION = PARROT_VERSION;

=head1 NAME

var.ops - Variable Ops

=head1 DESCRIPTION

These operations deal with both lexical and global variables,
as well as the symbol tables that contain them.

=cut

###############################################################################

=head2 Lexical variable ops

Operations to create, modify and delete lexical variables.

=over 4

=cut

########################################

=item B<store_lex>(in STR, in PMC)

Store object $2 as lexical symbol $1. The opcode might succeed
or throw an exception on unknown lexical names depending on the
implementation of the LexPad PMC.
Parrot's LexPad throws an exception for unknown names.


=cut

op store_lex(in STR, in PMC) {
    parrot_context_t * const ctx = CONTEXT(interpreter->ctx);
    STRING * const lex_name = $1;
    PMC * const lex_pad = Parrot_find_pad(interpreter, lex_name, ctx);
    if (PMC_IS_NULL(lex_pad)) {
	real_exception(interpreter, NULL, LEX_NOT_FOUND,
		"Lexical '%Ss' not found", lex_name);
    }
    VTABLE_set_pmc_keyed_str(interpreter, lex_pad, lex_name, $2);
    goto NEXT();
}

########################################

=item B<find_lex>(out PMC, in STR)

Find the lexical variable named $2 and store it in $1. This
opcode either throws an exception or returns a Null PMC for the failure case,
depending on the implementation of the LexPad PMC. Parrot's
standard LexPad throws and exception for non-existing names.

=cut

op find_lex(out PMC, in STR) {
    parrot_context_t * const ctx = CONTEXT(interpreter->ctx);
    STRING * const lex_name = $2;
    PMC * const lex_pad = Parrot_find_pad(interpreter, lex_name, ctx);
    PMC *result = NULL;

    if (!PMC_IS_NULL(lex_pad))
	result = VTABLE_get_pmc_keyed_str(interpreter, lex_pad, lex_name);
    if (!result) {
	real_exception(interpreter, NULL, LEX_NOT_FOUND,
		"Lexical '%Ss' not found", lex_name);
    }
    $1 = result;
    goto NEXT();
}


=back

=cut

###############################################################################

=head2 Global variable ops

Operations to modify global variables

=over 4

=cut

########################################

=item B<store_global>(in STR, in PMC)

Store value $2 as global symbol $1 in the current namespace.

=item B<store_global>(in STR, in STR, in PMC)

=item B<store_global>(in PMC, in STR, in PMC)

=item B<store_global>(in KEY, in STR, in PMC)

Store global $3 as global symbol $2 in namespace designated by $1.  If
namespace does not exist, create it.  $1 may be a key, a string, or an array
of strings.

=cut

op store_global(in STR, in PMC) {
    Parrot_store_global_cur(interpreter, $1, $2);
    goto NEXT();
}

op store_global(in STR, in STR, in PMC) {
    Parrot_store_global_s(interpreter, $1, $2, $3);
    goto NEXT();
}

op store_global(in PMC, in STR, in PMC) {
    Parrot_store_global_k(interpreter, $1, $2, $3);
    goto NEXT();
}

op store_global(in KEY, in STR, in PMC) {
    Parrot_store_global_k(interpreter, $1, $2, $3);
    goto NEXT();
}

########################################

=item B<find_global>(out PMC, in STR)

Find the global named $2 in the current namespace and store it in $1.

If the global doesn't exist either throws an exception or sets $1 to the
Null PMC, depending on current errors settings. See B<errorson>.

=item B<find_global>(out PMC, in STR, in STR)

Find the global named $3 in the namespace named $2 and store it in $1.

If the global doesn't exist either throws an exception or sets $1 to the
Null PMC, depending on current errors settings. See B<errorson>.

=item B<find_global>(out PMC, in PMC, in STR)

=item B<find_global>(out PMC, in KEY, in STR)

Find the global named $3 in the namespace designated by $2 and store it in
$1.  $2 may be a key, a string, or an array of strings.

If the global doesn't exist either throws an exception or sets $1 to the
Null PMC, depending on current errors settings.  See B<errorson>.

=cut

op find_global(out PMC, in STR) {
    PMC * const ns = CONTEXT(interpreter->ctx)->current_namespace;
    $1 = Parrot_find_global_op(interpreter, ns, $2, expr NEXT());
    goto NEXT();
}

op find_global(out PMC, in STR, in STR) {
    PMC * const ns = Parrot_find_namespace_s(interpreter, $2);
    $1 = Parrot_find_global_op(interpreter, ns, $3, expr NEXT());
    goto NEXT();
}

op find_global(out PMC, in PMC, in STR) {
    PMC * const ns = Parrot_find_namespace_k(interpreter, $2);
    $1 = Parrot_find_global_op(interpreter, ns, $3, expr NEXT());
    goto NEXT();
}

op find_global(out PMC, in KEY, in STR) {
    PMC * const ns = Parrot_find_namespace_k(interpreter, $2);
    $1 = Parrot_find_global_op(interpreter, ns, $3, expr NEXT());
    goto NEXT();
}

=item B<find_name>(out PMC, in STR)

Find the name $2 in lexical, current, global, or builtin namespace and
store it in $1. If the name doesn't exist
either throws an exception or sets $1 to PMCNULL, depending on current
errors settings. See B<errorson>.

=cut

op find_name(out PMC, in STR) {
    if (!$2)
	internal_exception(1, "Tried to find null name");

    $1 = Parrot_find_name_op(interpreter, $2, expr NEXT());
    goto NEXT();
}

=item B<get_namespace>(out PMC)

Get currrent namespace.

=item B<get_namespace>(out PMC, in PMC)

=item B<get_namespace>(out PMC, in KEY)

=item B<get_namespace>(out PMC, in STR)

Get the specified namespace. $2 is either an array of names or a key.
If the namespace doesn't exist, $1 is set to PMCNULL.

=back

=head2 Namespace opcodes

These will be moved to F<var.ops> soon.

=over 4

=cut

op get_namespace(out PMC) {
    $1 = CONTEXT(interpreter->ctx)->current_namespace;
    goto NEXT();
}

op get_namespace(out PMC, in PMC) {
    PMC *ns = VTABLE_get_pmc_keyed(interpreter,
				   Parrot_get_ctx_HLL_namespace(interpreter), $2);
    $1 = ns ? ns : PMCNULL;
    goto NEXT();
}

op get_namespace(out PMC, in KEY) {
    PMC *ns = VTABLE_get_pmc_keyed(interpreter,
				   Parrot_get_ctx_HLL_namespace(interpreter), $2);
    $1 = ns ? ns : PMCNULL;
    goto NEXT();
}

op get_namespace(out PMC, in STR) {
    PMC *ns = VTABLE_get_pmc_keyed_str(interpreter,
				       Parrot_get_ctx_HLL_namespace(interpreter), $2);
    $1 = ns ? ns : PMCNULL;
    goto NEXT();
}


=back

###############################################################################

=head1 COPYRIGHT

Copyright (C) 2001-2006, The Perl Foundation.

=head1 LICENSE

This program is free software. It is subject to the same license
as the Parrot interpreter itself.

=cut
