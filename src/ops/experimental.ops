/*
** experimental.ops
*/

VERSION = PARROT_VERSION;

=head1 NAME

experimental.ops - Experimental Operations

=cut

=head1 DESCRIPTION

This file contains operations that are in an experimental state. Do not
rely upon the existence of the ops in this file when writing production code.
No decision has yet been made as to whether they are accepted as regular
Parrot ops or not. They are included here for testing purposes only!

=cut

###############################################################################

=head2 Mathematical operations

Implementations of various mathematical operations

=over 4

=cut

########################################

=item B<gcd>(out INT, in NUM, in NUM)

Greatest Common divisor of $2 and $3.

=item B<gcd>(out INT, out INT, out INT, in INT, in INT)

Given $4 and $5, it calculates $1, $2 and $3 so that

$1 = gcd($4, $5) = $2 * $4 + $3 * $5 (d = gcd(a,b) = x*a + y*b)

=cut

inline op gcd(out INT, in NUM, in NUM) :advanced_math {

  FLOATVAL q = 0;
  FLOATVAL c = 0;
  FLOATVAL temp2 = $2 < 0.0 ? -$2 : $2;
  FLOATVAL temp3 = $3 < 0.0 ? -$3 : $3;
  while (temp3 != 0) {
    q = floor( (FLOATVAL)temp2/temp3 );
    c = temp2 - temp3*q;
    temp2 = temp3;
    temp3 = c;
  }
  $1 = (INTVAL)temp2;
  goto NEXT();
}

inline op gcd(out INT, out INT, out INT, in INT, in INT) :advanced_math {
  /* r0 = q1*r1 + r2 */
  INTVAL r0 = $4 < 0 ? -$4 : $4;
  INTVAL r1 = $5 < 0 ? -$5 : $5;
  INTVAL r2 = 0;
  INTVAL q1 = 0;

  INTVAL xkm1 = 1;
  INTVAL xk = 0;
  INTVAL xkp1 = 0;

  INTVAL ykm1 = 0;
  INTVAL yk = 1;
  INTVAL ykp1 = 0;

  INTVAL n = 1;

  INTVAL x;
  INTVAL y;

  while (1) {
    q1 = r0/r1;
    r2 = r0 - q1*r1;
    if (r2 == 0) {
      break;
    }
    r0 = r1;
    r1 = r2;

    xkp1 = q1*xk + xkm1;
    xkm1 = xk;
    xk = xkp1;

    ykp1 = q1*yk + ykm1;
    ykm1 = yk;
    yk = ykp1;
  }
  $1 = r1;
  $2 = (INTVAL)( xk * pow( -1, n ) );
  $3 = (INTVAL)( yk * pow( -1, n+1 ) );

  x = $2 * $4;
  y = $3 * $5;

  /* correct the sign (can be wrong because we used abs($4) and abs($5) */
  if ( x + y == r1 ) {
    /* no correction necessary */
  }
  else if ( x + y == -r1 ) {
    $2 = -$2;
    $3 = -$3;
  }
  else if ( x - y == r1 ) {
    $3 = -$3;
  }
  else if ( -x + y == r1 ) {
    $2 = -$2;
  }

  goto NEXT();
}

=back

=cut

###############################################################################

=head2 Misc other ops

=over 4

=cut

=item B<new>(out PMC, in INT, in KEY)

XXX

=cut

op new(out PMC, in INT, in KEY) {
  if ($2 <= 0 || $2 >= interpreter->n_vtable_max) {
    internal_exception(1, "Illegal PMC enum (%d) in new", (int)$2);
  }
  $1 = pmc_new_init(interpreter, $2, $3);
  goto NEXT();
}

########################################

=item B<splice>(in PMC, in PMC, in INT, in INT)

Replace $4 values at offset $3 in aggregate $1 with the PMCs in aggregate $2.
The values are put into the aggregate by a shallow copy. If the values would
be reused, they have to be B<clone>d.

=cut

inline op splice(in PMC, in PMC, in INT, in INT) {
    $1->vtable->splice(interpreter, $1, $2, $3, $4);
    goto NEXT();
}


=item B<slice>(out PMC, in PMC, in KEY)

Return a new Iterator PMC $1 for aggregate $2 and Slice PMC $3.

=item B<slice>(out PMC, in PMC, in KEY, inconst INT)

Return a new list PMC $1 for aggregate $2 and Slice PMC $3.

This is a Python opcode. Range is i <= k < j. $4 must be 1.
May change and move to python.ops.

=item B<iter>(out PMC, in PMC)

Return a new Iterator PMC $1 for aggregate $2.

=cut

inline op slice (out PMC, in PMC, in KEY) :base_core {
    $1 = $2->vtable->slice(interpreter, $2, $3, 0);
    goto NEXT();
}

inline op slice (out PMC, in PMC, in KEY, inconst INT) :python {
    $1 = $2->vtable->slice(interpreter, $2, $3, $4);
    goto NEXT();
}

inline op iter (out PMC, in PMC) :base_core {
    $1 = $2->vtable->get_iter(interpreter, $2);
    goto NEXT();
}

########################################

=item B<morph>(in PMC, in INT)

Have $1 turn itself into a PMC of type $2.

=cut

inline op morph(in PMC, in INT) {
  VTABLE_morph(interpreter, $1, $2);
  goto NEXT();
}

=item B<exec>(in STR)

Execute the passed-in command. Completely tosses the current process
image and replaces it with the command. Doesn't exit (the program
ends, after all), though it does throw an exception if something goes
wrong.

=cut

inline op exec(in STR) {
  Parrot_Exec_OS_Command(interpreter, $1);
  goto NEXT();
}

=back

=head2 Namespace opcodes

These will be moved to F<var.ops> soon.

=over 4

=item B<get_namespace>(out PMC)

Get currrent namespace.

=item B<get_namespace>(out PMC, in PMC)

=item B<get_namespace>(out PMC, in KEY)

=item B<get_namespace>(out PMC, in STR)

Get the specified namespace. $2 is either an array of names or a key.
If the namespace doesn't exist, $1 is set to PMCNULL.

=item B<find_global>(out PMC, in KEY, in STR)

Find the variable $3 in $2.

=cut

op get_namespace(out PMC) {
    $1 = CONTEXT(interpreter->ctx)->current_namespace;
    goto NEXT();
}

op get_namespace(out PMC, in PMC) {
    PMC *ns_root = interpreter->stash_hash, *ns;
    ns = VTABLE_get_pmc_keyed(interpreter, ns_root, $2);
    $1 = ns ? ns : PMCNULL;
    goto NEXT();
}

op get_namespace(out PMC, in KEY) {
    PMC *ns_root = interpreter->stash_hash, *ns;
    ns = VTABLE_get_pmc_keyed(interpreter, ns_root, $2);
    $1 = ns ? ns : PMCNULL;
    goto NEXT();
}

op get_namespace(out PMC, in STR) {
    PMC *ns_root = interpreter->stash_hash, *ns;
    ns = VTABLE_get_pmc_keyed_str(interpreter, ns_root, $2);
    $1 = ns ? ns : PMCNULL;
    goto NEXT();
}

op find_global(out PMC, in KEY, in STR) {
    $1 = Parrot_find_global_p(interpreter, $2, $3);
    goto NEXT();
}

=back

=head2 More Experimental Ops

=over 4

=item C<debug_brk>

Break into debugger. Implementation notes:

 - x86/gcc ... works with gdb
 - TODO

For other architectures, this is a C<noop>.

=cut

op debug_brk() {
#if defined(__GNUC__) && defined(i386)
    __asm__("int3");       /* opcode 0xcc */
#endif
    goto NEXT();
}

=item B<pow>(out NUM, in NUM, in INT)

Set $1 to $2 raised to the power $3.

=cut

inline op pow(out NUM, in NUM, in INT) :base_core {
    FLOATVAL n2 = $2;
    FLOATVAL res = 1.0;
    INTVAL   e  = $3;
    int s = 1;
    if (e != 0) {
	if (e < 0) {
	    s = -1;
	    e = -e;
	}
    }
    while (e) {
	if (e & 1) {
	    res *= n2;
	}
	n2 *= n2;
	e >>= 1;
    }
    if (s < 0) {
	res = 1.0/res;
    }
    $1 = res;
    goto NEXT();
}

=item B<new>(out PMC, inconst STR, in PMC)

Create a new PMC of class $2;

 new P0, "Foo", P1

The PMC in $3 is passed to the constructor. It's up to the class what to do
with the intializer.

=cut

op new(out PMC, in STR, in PMC) {
	STRING *class = $2;
	INTVAL type = pmc_type(interpreter, class);
	if (!type) {
		Parrot_autoload_class(interpreter, class);
		type = pmc_type(interpreter, class);
	}
	if (type <= 0)
		real_exception(interpreter, NULL, NO_CLASS,
				"Class '%Ss' not found", class);
	$1 = pmc_new_init(interpreter, type, $3);
	goto NEXT();
}

=item op B<getclass>(out PMC, in INT)

Return the class PMC of the type $2.

=cut

op getclass(out PMC, in INT) {
    int typ = $2;
    if (typ < 1 || typ >= interpreter->n_vtable_max)
	real_exception(interpreter, NULL, E_ValueError,
		"type number out of range");
    $1 = interpreter->vtables[typ]->class;
    goto NEXT();
}

inline op newclass(out PMC, in KEY) :object_classes {
  $1 = pmc_new_init(interpreter, enum_class_ParrotClass, $2);
  goto NEXT();
}

inline op new(out PMC, in KEY) :object_classes {
  PMC *class = $2;
    INTVAL type = pmc_type_p(interpreter, class);
    if (type <= 0)
        real_exception(interpreter, NULL, NO_CLASS,
            "Class '%Ss' not found", class);
  $1 = pmc_new(interpreter, type);
  goto NEXT();
}

op subclass(out PMC, in STR, in KEY) :object_classes {
  PMC *class = Parrot_class_lookup(interpreter, $2);
  opcode_t *next = expr NEXT();
  if (PMC_IS_NULL(class)) {
    real_exception(interpreter, next, NO_CLASS, "Class '%s' doesn't exist",
		string_to_cstring( interpreter, $2 ));
  }
  $1 = VTABLE_subclass(interpreter, class, $3);
  goto ADDRESS(next);
}

op subclass(out PMC, in KEY, in KEY) :object_classes {
  PMC *class = Parrot_class_lookup_p(interpreter, $2);
  opcode_t *next = expr NEXT();
  if (PMC_IS_NULL(class)) {
    STRING *name = readable_name(interpreter, $2);
    real_exception(interpreter, next, NO_CLASS, 
		"Class '%Ss' doesn't exist", name);
  }
  $1 = VTABLE_subclass(interpreter, class, $3);
  goto ADDRESS(next);
}

inline op subclass(out PMC, in PMC, in KEY) :object_base {
  $1 = VTABLE_subclass(interpreter, $2, $3);
  goto NEXT();
}

inline op getclass(out PMC, in KEY) :object_classes {
  PMC *class = Parrot_class_lookup_p(interpreter, $2);
  opcode_t *next = expr NEXT();
  if (PMC_IS_NULL(class)) {
    STRING *name = readable_name(interpreter, $2);
    real_exception(interpreter, next, NO_CLASS, 
         "Class '%Ss' doesn't exist", name);
  }
  else
    $1 = class;
  goto ADDRESS(next);
}
=back

=head1 COPYRIGHT

Copyright (C) 2001-2004 The Perl Foundation.  All rights reserved.

=head1 LICENSE

This program is free software. It is subject to the same license
as the Parrot interpreter itself.

=cut
