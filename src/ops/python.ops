/*
** python.ops
*/

/* XXX in io/io.c */
int PIO_softspace(theINTERP, PMC *pmc, int new);

VERSION = PARROT_VERSION;

=head1 NAME

python.ops - Python Operations

=cut

=head1 DESCRIPTION

Currently included in main - will be split.

=cut

###############################################################################

=head2 IO operations

=over 4

=cut

########################################

=item B<print_item>(in INT)

=item B<print_item>(in NUM)

=item B<print_item>(invar PMC)

=item B<print_item>(in STR)

Print $1 to standard output. If another C<print_item> follows, a
space is inserted.

=item B<print_newline>()

Print a newline char to standard output.

=cut

inline op print_item(in INT) :base_io {
  PMC * const io = PIO_STDOUT(interp);
  if (PIO_softspace(interp, io, 0))
    PIO_puts(interp, io, " ");
  PIO_printf(interp, INTVAL_FMT, (INTVAL)$1);
  PIO_softspace(interp, io, 1);
  goto NEXT();
}

inline op print_item(in NUM) :base_io {
  PMC * const io = PIO_STDOUT(interp);
  STRING *s;
  if (PIO_softspace(interp, io, 0))
    PIO_puts(interp, io, " ");
  s = Parrot_sprintf_c(interp, "%.12g", (double)$1);
  PIO_putps(interp, io, s);
  if (string_str_index(interp, s,
        const_string(interp, "."), 0) == -1 &&
      string_str_index(interp, s,
        const_string(interp, "e"), 0) == -1)
    PIO_puts(interp, io, ".0");
  PIO_softspace(interp, io, 1);
  goto NEXT();
}

op print_item(in STR) :base_io {
  STRING * const s = $1;
  PMC * const io = PIO_STDOUT(interp);
  if (s && string_length(interp, s)) {
    if (PIO_softspace(interp, io, 0))
      PIO_puts(interp, io, " ");
    PIO_putps(interp, PIO_STDOUT(interp), s);
    PIO_softspace(interp, io, 1);
  }
  goto NEXT();
}

op print_item(invar PMC) :base_io {
  PMC * const p = $1;
  PMC * const io = PIO_STDOUT(interp);
  STRING * const s = (VTABLE_get_string(interp, p));
  if (s) {
    if (PIO_softspace(interp, io, 0))
      PIO_puts(interp, io, " ");
    PIO_putps(interp, PIO_STDOUT(interp), s);
    PIO_softspace(interp, io, 1);
  }
  goto NEXT();
}

op print_newline() :base_io {
  PMC * const io = PIO_STDOUT(interp);
  PIO_puts(interp, io, "\n");
  PIO_softspace(interp, io, 0);
  goto NEXT();
}

=item B<print_item>(invar PMC, in INT)

=item B<print_item>(invar PMC, in NUM)

=item B<print_item>(invar PMC, invar PMC)

=item B<print_item>(invar PMC, in STR)

Print $2 to IO stream object $1. If another C<print_item> follows, a
space is inserted.

=item B<print_newline>(invar PMC)

Print a newline char to IO stream object $1.

=cut

inline op print_item(invar PMC, in INT) :base_io {
  PMC * const io = $1;
  if (PIO_softspace(interp, io, 0))
    PIO_puts(interp, io, " ");
  PIO_fprintf(interp, io, INTVAL_FMT, (INTVAL)$2);
  PIO_softspace(interp, io, 1);
  goto NEXT();
}

inline op print_item(invar PMC, in NUM) :base_io {
  PMC * const io = $1;
  STRING *s;
  if (PIO_softspace(interp, io, 0))
    PIO_puts(interp, io, " ");
  s = Parrot_sprintf_c(interp, "%.12g", (double)$2);
  PIO_putps(interp, io, s);
  if (string_str_index(interp, s,
        const_string(interp, "."), 0) == -1 &&
      string_str_index(interp, s,
        const_string(interp, "e"), 0) == -1)
    PIO_puts(interp, io, ".0");
  PIO_softspace(interp, io, 1);
  goto NEXT();
}

op print_item(invar PMC, in STR) :base_io {
  STRING * const s = $2;
  PMC * const io = $1; /* TODO Can this be localized? */
  if (s && string_length(interp, s)) {
    if (PIO_softspace(interp, io, 0))
      PIO_puts(interp, io, " ");
    PIO_putps(interp, io, s);
    PIO_softspace(interp, io, 1);
  }
  goto NEXT();
}

op print_item(invar PMC, invar PMC) :base_io {
  PMC * const p = $2;
  PMC * const io = $1; /* TODO Can this be localized? */
  STRING *s = (VTABLE_get_string(interp, p));
  if (s) {
    if (PIO_softspace(interp, io, 0))
      PIO_puts(interp, io, " ");
    PIO_putps(interp, io, s);
    PIO_softspace(interp, io, 1);
  }
  goto NEXT();
}

op print_newline(invar PMC) :base_io {
  PMC * const io = $1;
  PIO_puts(interp, io, "\n");
  PIO_softspace(interp, io, 0);
  goto NEXT();
}

########################################

=back

=cut


###############################################################################

=head1 COPYRIGHT

Copyright (C) 2001-2006, The Perl Foundation.

=head1 LICENSE

This program is free software. It is subject to the same license
as the Parrot interpreter itself.

=cut


/*
 * Local variables:
 *   c-file-style: "parrot"
 * End:
 * vim: expandtab shiftwidth=4:
 */
