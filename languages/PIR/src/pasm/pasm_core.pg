grammar PIR::Grammar;
  
  
rule core_op {
  #
  # basic
  #
  end
| noop
| reserved        <arg_hack> #<int_constant> 
| load_bytecode   <arg_hack> #<arg_string>
  #
  # control flow
  #
| branch          <arg_hack> #<arg_int>
| branch_cs       <arg_hack> #<arg_string>
| bsr             <arg_hack> #<arg_int>
| ret
| jsr <arg_int>
| enternative
  # conditional branch
| if              <arg_hack> #<target> \, <arg_int>
| unless          <arg_hack> #<target> \, <arg_int>
  # subroutine ops <arg_hack> #
| invokecc         <arg_hack> #<arg_pmc_target> 
| invoke           <arg_hack> #<arg_pmc_target> \, <arg_pmc_target>
| yield            <arg_hack> #
| tailcall         <arg_hack> #<arg_pmc_target>
| returncc         <arg_hack> #
| newclosure       <arg_hack> #<arg_pmc_target> \, <arg_pmc_target>
  # function args ops
| set_args        <arg_hack> # <arg_set_args>
| get_results     <arg_hack> # <arg_get_results> 
| get_params      <arg_hack> # <arg_get_params>
| set_returns     <arg_hack> # <arg_set_returns>
| result_info     <arg_hack>
  # address manipulation  
| set_addr        <arg_hack> #<target> \, <int_constant>
| get_addr        <arg_hack> #<target> \, <target> 
  # exception handling
| push_eh             <arg_hack> #<id>
| pop_eh              <arg_hack> #
| throw               <arg_hack> #<target>
| rethrow             <arg_hack> #<target>
| die                 <arg_hack> #<int_constant> \, <int_constant>
| exit                <arg_hack> #<int_constant> 
| pushmark            <arg_hack> #<int_constant>
| popmark             <arg_hack> #<int_constant>
| pushaction          <arg_hack> #<target>
  # interpreter ops
| debug               <arg_hack> #<int_constant>
| bounds              <arg_hack> #<int_constant>
| profile             <arg_hack> #<int_constant>
| trace               <arg_hack> #<int_constant>
| gc_debug            <arg_hack> #<int_constant>
| interpinfo          <arg_hack> #<target> \, <int_constant>
| warningson          <arg_hack> #<int_constant>
| warningsoff         <arg_hack> #<int_constant>
| errorson            <arg_hack> #<int_constant>
| errorsoff           <arg_hack> #<int_constant>
| runinterp           <arg_hack> #<target> \, <int_constant>
| getinterp           <arg_hack> #<target> 
  # GC            
| sweep               <arg_hack> #<int_constant>
| collect             
| sweepoff            
| sweepon             
| collectoff          
| collecton           
| needs_destroy       <arg_hack> #<target>
  # NCI               
| loadlib             <arg_hack> #<target> \, <target>
| dlfunc              <arg_hack> #<target> \, <target> \, <target> \, <target>
| dltarget               <arg_hack> #<target> \, <target> \, <target>
| compreg             <arg_hack> #<target> \, <target>
| new_callback        <arg_hack> #<target> \, <target> \, <target> \, <target>
}
