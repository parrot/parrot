#
# match_close
#
# given a string and a starting position,
# return the position at which the leading { or " 
# closes, including the last character.

.sub __match_close
  .param string buffer
  .param int start_pos

  .local int opener
  .local int closer
  .local int peekchar

  .local int count
  .local int state
  .local int position
  .local int bufferlen
  .local int position
  .local int hierarchical

  hierarchical = 0 

  position = start_pos

  length bufferlen, buffer
  ord opener, buffer, start_pos
  closer = -1

  # {}
  if opener != 123 goto trycommand
  hierarchical = 1
  closer = 125
  goto gotcloser 

  # []
trycommand:
  if opener != 91 goto tryquote
  closer = 93
  goto gotcloser 

  # ""
tryquote: 
  if opener != 34 goto tryparen
  closer = 34

tryparen: 
  if opener != 40 goto gotcloser
  hierarchical = 1
  closer = 41

gotcloser: 
  if closer == -1 goto die1 

  count = 1
  state = 1
  # 1 == normal, 2 == saw a \

outer:

  if count == 0 goto outer_done

  inc position 


  if position == bufferlen goto die2

  ord peekchar,buffer,position


  if state==2 goto state2

  if peekchar == closer goto decr
  if peekchar == opener goto incr

  # backslash
  if peekchar != 92 goto outer

  state = 2
  goto outer

# a \ is only special the first time...
state2:
  state = 1
  goto outer

# found a closer
decr:
  if opener == closer goto outer_done 
  count = count - 1
  goto outer

# found another opener
incr:
  if hierarchical == 0 goto outer
  count = count + 1
  goto outer

outer_done:

  $I1 = position - start_pos
  # off by two?
  inc $I1
  goto done

die1:
  # invalid opening match char
  $I1 = -1
  goto done

die2:
  # no closing char found
  $I1 = -2

done:
  .pcc_begin_return
    .return $I1
  .pcc_end_return
.end
