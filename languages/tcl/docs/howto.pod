=head1 contributing to tcl/parrot

a brief overview on how to help out, if you're interested. In general, 
it's ok to send patches for tcl to the RT system for anything that isn't
"BIG STUFF" - those, please bounce off me first. I'd prefer C<diff -u>
patches, but am happy to take complete files as well.

Most of this is mentioned in the TODO - in fact, this document probably
should merge with the TODO to avoid redundancy.

=head1 BIG STUFF

=over 4

=item interperter -> compiler

Right now, partcl is an interpreter. The parser generates an AST of sorts,
which the interpreter then walks through the ast, finds the command to execute,
(e.g., C<Tcl::puts>), gets the values for each of the args (Evaluation is
deferred until just before the function is called.)

To switch to a compiler, we need to basically use the same interpreter loop,
but generate it specifically for the series of commands being invoked. Once
we have the PIR, we can then C<compile> it, and return that anonymous PIR
sub. Then, instead of calling "interpret", we can just invoke that sub.

Some optimizations we can do:

TclWord (which we call to get the PMC for
the various arguments), has an "is_const" method - If we look up the
value and it's constant, we can hardcode it right into the PIR. Same goes
for the commands.

A non-tcl option we can provide is a command line option to just dump the
generated PIR/bytecode. (e.g. tclsh -o foo.pir or tclsh -o foo.pbc)

One algorithm to cache the builtins - keep a global counter (in some places,
called epoch) - every time [rename] is called, epoch is bumped up and we have
to re-fetch the method. But, if it hasn't changed, we're allowed to cheat.
And if we can cheat on something like C<puts foo>, we can translate that
*in place* to a simple C<print "foo\n"> and not have to go through all
the overhead.

=item speed

We're currently quite slow, compared to tclsh. Switching over to a compiler
instead of an interpreter might help here, though I'm having a hard time
envisioning a compiler that doesn't have to do all the things we already do
as an interpreter. 

We could rewrite parse/interpret/compile in C, either as an NCI or behind
a PMC object - this would I<possibly> give us an improvement in speed also.

=item features

We're currently missing some things that require support from parrot
before we can continue, like [info nameofexecutable]. In general, though,
a lot of what we need to do is possible with parrot.

If you're looking for something to todo, check one of: TODO tests in 
C<t/>; RT
https://rt.perl.org/rt3/NoAuth/parrot/List.html?Field=Lang&Value=tcl
or by their absence: every actual builtin at 
http://www.tcl.tk/man/tcl8.5/TclCmd/contents.htm
should have a corresponding file in C<lib/commands/>

=back

=head1 DOCUMENTATION

=over 4

=item pod

Every PIR .sub that's defined should probably have some POD to go along
with it to document the arguments and return values.

=item big picture docs.

Are the docs in C<docs/> useful? Could use someone to proof them, and
verify that there are no missing chunks (if missing, write them, or 
get them added to the C<TODO>), and that they are coherent.

=back

=head1 PIR

=over 4

=item Missing Commands

Every builtin command corresponds to a file with an appropriately named
sub in C<lib/commands> - Each of these subs takes some number of PMCs
as arguments. For those commands that take a fixed number of parameters,
we declare them with C<.param>. For those that take a variable number,
we use the C<foldup> opcode.

Note that there are two return values for each command, an int and a PMC.
The integer contains the Tcl return value for that command (OK, BREAK,
RETURN, etc.). The PMC is usually a string at this point, but could be
any valid PMC. Note - right now, if there's an error condition, create
a new string-like PMC and put the error condition in it. Eventually this
will be some kind of structure.

Before adding new functionality, add a test (or a test in an existing) file 
in C<t/> - tests for C<puts>, for example,
go in C<t/cmd_puts.t> - we use the C<Test::Harness> framework, via 
C<Parrot::Test>. 

Our final goal will be to pass (most of) the tcl test suite: run 
C<make tcl-test> to checkout the latest version of of the tcl test suite
and run it. Warning: slow...

=back



=cut

