=head1 hacks.pod

Prodding by Matt Diephouse to generate documentation for two things:

=over 4

=item 1

Things that partcl has done that might be considered hacks -
things that will likely impair our ability in the distant future to
cleanly do language interoperability.

=item 2

Things that partcl hasn't done yet at all because parrot makes them
hard.

=back

It is, of course, quite likely that said feature already exists with
a nice interface, and was just not found by the partcl developers -
If you find something along these lines, let them know on the internals
list.

=head1 WORKAROUNDS

=over 4

=item PDD20 - lexical vars

The new scheme (PDD20) for lexical vars means that to use the 'store_lex', and
'find_lex' opcodes, you have to be inside a sub that's marked :lex: That
is, inside a sub that corresponds to a HLL block that introduces a new
lexical scope. Tcl uses helper functions to figure out whether a particular
'$a' is referring to a global or a lexical var. To keep our current
flexibility (which may be too flexible), these lexical calls are now
delegated to lib/variables.pir's find_lex_pdd20 and store_lex_pdd20, which
query the interpreter to find the closest lexical pad and perform the
stores/finds against that.

This is in contrast to the previous way lexicals were implemented, which 
let you call the _lex opcodes anywhere, as long as at some point in the past
of the program, you had a created a lex_pad and put it on the stack.

=item subroutine meta information.

Tcl provides the ability to query subroutines about their arguments
and their code. For example:

 % proc sum {{a 2} {b 3}} {
 return [expr $a + $b]
 }
 % sum
 5
 % info args sum
 a b
 % info body sum

  return [expr $a + $b]

 % info default sum a the_argument
 1
 % puts $the_argument
 2
 %

Right now, partcl is using globals to store the argument list and the the
body information. It would seem that we'd want to have a builtin mechanism
for querying the subs directly rather than storing this information separately.

=item user defined subs; parameter handling.

Tcl provides nice exceptions for dealing with argument handling - to continue
our example:

 % sum a b c
 wrong # args: should be "sum ?a? ?b?"

Right now, this is handled I<inside> the function definition - it is defined
to take an arbitary number of args, and then is checked for correctness
internally. It would be nice to have invoke() automatically figure this out
and generate an exception that Tcl can use. (This also starts to drag in
"how to do Tcl exceptions cleanly from parrot")

=item stack depth

Cheating and keeping a global around right now, so we can figure out if we
should be using a global or a lexical (and if so, how far down or up).

=item [trace]'ing

There are two ways we can go about the tracing - either we can keep the
information about the traces in a global, and check that global every time
the appropriate action is taken; or, we can tie that information into the
actual commands and variables. I think the latter would be somewhat cleaner,
and, if any other languages support this feature, this would give us a chance
to interoperate.

=item list splicing

There are several cases where we convert TclLists or ResizablePMCArrays to
Arrays so that we can use the splice opcode. Need to have better splice
support in parrot array classes, as well as our own. See
C<lib/commands/linsert.pir>.

=item marshalling/unmarshalling

When compiling, there is currently no easy way to embed a PMC that exists
at runtime into the compiled code. Because of this, we have to interrogate
the PMC at compile time for its type, and then handroll the appropriate PIR
to intialize its value. We should be able to freeze the PMC during compilation,
And then have in the generated code C<$P1 = thaw "...">.

=back

=cut


