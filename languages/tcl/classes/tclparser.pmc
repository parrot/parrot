/* TclParser.pmc
 *  Copyright: 2001-2003 The Perl Foundation.  All Rights Reserved.
 *  CVS Info
 *     $Id$
 *  Overview:
 *     A container for methods related to tcl parsing.
 *  Data Structure and Algorithms:
 *  History:
 *  Notes:
 *  References:

=head1 NAME

dynclasses/tclparser.pmc - Tcl Parser

=head1 DESCRIPTION

Handle any parsing of Tcl code - putting this into a pmc with state
allows us to more easily handle [parser]

=cut

*/

#include "parrot/parrot.h"

static INTVAL TclList,StringClass,IntegerClass,TclWord;
static STRING *bs_nl, *nl, *cb, *cp, *space;
static STRING *ConcatWords, *ConcatConst, *ConcatVariable;
static STRING *ConcatChar, *ConcatCommand;

pmclass TclParser dynpmc group tcl_group {

    void class_init() {
      PMC *string_anchor;
      INTVAL fixedstringarray_typenum;
      if (pass) {
          TclList       = Parrot_PMC_typenum(INTERP, "TclList");
          StringClass   = Parrot_PMC_typenum(INTERP, "String");
          IntegerClass  = Parrot_PMC_typenum(INTERP, "Integer");

          bs_nl = string_from_const_cstring(INTERP, "\\\n",2);
          nl    = string_from_const_cstring(INTERP, "\n",1);
          cb    = string_from_const_cstring(INTERP, "}",1);
          cp    = string_from_const_cstring(INTERP, ")",1);
          space = string_from_const_cstring(INTERP, " ",1);

          ConcatWords    = string_from_const_cstring(INTERP, "concat_words",12);
          ConcatConst    = string_from_const_cstring(INTERP, "concat_const",12);
          ConcatVariable = string_from_const_cstring(INTERP, "concat_variable",15);
          ConcatChar     = string_from_const_cstring(INTERP, "concat_char",11);
          ConcatCommand  = string_from_const_cstring(INTERP, "concat_command", 14);

          /* Avoid having these strings GC'd. */
          fixedstringarray_typenum =
            Parrot_PMC_typenum(INTERP, "FixedStringArray");
          string_anchor = pmc_new(INTERP,fixedstringarray_typenum);
          VTABLE_set_integer_native(INTERP,string_anchor,10);
          VTABLE_set_string_keyed_int(INTERP,string_anchor,0,bs_nl);
          VTABLE_set_string_keyed_int(INTERP,string_anchor,1,nl);
          VTABLE_set_string_keyed_int(INTERP,string_anchor,2,cb);
          VTABLE_set_string_keyed_int(INTERP,string_anchor,3,cp);
          VTABLE_set_string_keyed_int(INTERP,string_anchor,4,space);
          VTABLE_set_string_keyed_int(INTERP,string_anchor,5,ConcatWords);
          VTABLE_set_string_keyed_int(INTERP,string_anchor,6,ConcatConst);
          VTABLE_set_string_keyed_int(INTERP,string_anchor,7,ConcatVariable);
          VTABLE_set_string_keyed_int(INTERP,string_anchor,8,ConcatChar);
          VTABLE_set_string_keyed_int(INTERP,string_anchor,9,ConcatCommand);
          dod_register_pmc(INTERP,string_anchor);
      }
    }

/*

=item C<void init()>

Initializes the instance.

=cut

*/

    void init () {
        PMC_str_val(SELF) = string_make_empty(INTERP,enum_stringrep_one,0);
    }

/*

=item C<METHOD PMC* "parse"(STRING *code, INTVAL preserve_whitespace, INTVAL block_interpolation)

Given a string of Tcl Code, return a chunk of data we can then pass
to the expression sub.

XXX: Skip the evaluate step, and just return an invokable.

=cut

*/

    METHOD PMC* parse(STRING *code, INTVAL preserve_whitespace, INTVAL block_interpolation) {
      INTVAL start_word=0;  /* position of the start of the word */
      INTVAL word_length; /* length of the word */
      INTVAL word_trailing_length;  /* include the last char in the word? */
      INTVAL character; /* The current character */
      INTVAL last_character; /*The last character */
      INTVAL end_of_word; /* Boolean, is the word done? */
      PMC *commands; /* List of all the commands parsed */
      PMC *command;  /* The current command */
      INTVAL bs_marker = 0;
      INTVAL bs_pos;
      INTVAL bs_diff;
      INTVAL buffer_length;
      INTVAL old_length,chunk_start,escape_length,temppos;

      STRING *buffer = Parrot_make_COW_reference(INTERP, code);
      PMC *word;
      INTVAL I0,I1,I2;
      STRING *S0, *S1;
      PMC *P0,*P1,*P2,*P3,*P4;

      /* XXX running this in class_init is apparently too soon, so run it here */
      TclWord = Parrot_PMC_typenum(INTERP, "TclWord");

      /* backslash/newline substitution */
      buffer_length = string_length(INTERP, buffer);

      /* Possible regression here if we do the bs_nl substitution >1 */
      bs_pos = string_str_index(INTERP, buffer, bs_nl, bs_marker);
      while (bs_marker <= buffer_length && bs_pos != -1) {
	INTVAL chr;

        bs_marker = bs_pos;
        bs_pos++;
        chr = string_index(INTERP, buffer, bs_pos++);
        while (chr < 33 && chr != '\n') {
            chr = string_index(INTERP, buffer, bs_pos++);
        }

        /* delete the items from marker to pos */
        bs_diff = bs_pos - bs_marker;
        string_replace(INTERP,buffer,bs_marker,bs_diff,space,NULL);

        buffer_length = string_length(INTERP, buffer);
        bs_pos = string_str_index(INTERP, buffer, bs_nl, bs_marker);
      }

  /* Keep track of the position of the current word */
  start_word = 0;

  commands = pmc_new(INTERP,TclList);

  /*
   * (Do this after the newline_subst since this could change the
   *  size of the buffer.)  ... don't fall off the end
   */

  buffer_length = string_length(INTERP, buffer);

begin_command:
  command = pmc_new(INTERP,TclList);

begin_word:
  word = pmc_new(INTERP,TclWord);
  end_of_word = 0;
  /* Skip any leading whitespace, unless we're preserving. */

  if (preserve_whitespace)
    goto pre_middle;

space_loop:
  if (start_word >= buffer_length)
    goto end_scope;

  I0 = string_index(INTERP, buffer, start_word);
  if (I0 < 33 && I0 != '\n') {
    start_word++;
    goto space_loop;
  }

space_loop_end:
  /*
   * At this point, we know start_word is correct.
   * Now to figure out where the word ends.
   */

  /* If the first character is special, then DTRT */

  character = string_index(INTERP, buffer, start_word);

  if (character == '{') {
    /* brace-encrusted block */

    word_length = Parrot_TclParser_match_close(INTERP, SELF, buffer,start_word);
    if (word_length < 0)
      real_exception(INTERP, NULL, E_Exception, "missing close-brace");

    end_of_word = 1;

    /* figure out where the new word is going to start.*/
    I1 = start_word + word_length;

    /* This gets added as a constant.*/
    start_word++;
    word_length-=2;

    S0 = string_substr(INTERP, buffer, start_word, word_length, NULL, 0);
    P1 = VTABLE_find_method(INTERP, word, ConcatConst);
    Parrot_call_method(INTERP, P1, word, ConcatConst, "vS", S0);
    start_word = I1;
    word_length = 0;
    goto middle_word;
  } else if (character == '"') {
    /* "string" */

    word_length = Parrot_TclParser_match_close(INTERP, SELF, buffer,start_word);
    if (word_length < 0)
      real_exception(INTERP, NULL, E_Exception, "missing \"");

    end_of_word = 1 ;

    /*figure out where the new word is going to start.*/
    I1 = start_word + word_length;

    /*
     * Since we could have embedded things in our string,
     * recall the parser, but tell it to preserve the whitespace in
     * this quote.
     * (There could be embedded vars, commands, etc.)
     */

    start_word++;
    word_length-=2;
    S0 = string_substr(INTERP, buffer, start_word, word_length, NULL, 0);

    P0 = Parrot_TclParser_parse(INTERP, SELF, S0, 1, 0);
    P4 = VTABLE_find_method(INTERP, word, ConcatWords);
    /* XXX This method on the object currently causes a bus error */
    Parrot_call_method(INTERP, P4, word, ConcatWords, "vP", P0);
    start_word = I1;
    word_length = 0;
    goto middle_word;
  }

  /* #comment */
  if (character == '#' && Parrot_PMC_get_intval(INTERP,command) == 0) {
    INTVAL I0 = string_str_index(INTERP, buffer, nl, start_word);
    if (I0 == -1) {
      /* If the comment is all that's left, quit. */
      goto end_command;
    } else {
      /*  otherwise, stop at the next newline. */
      start_word = I0 + 1;
      goto begin_command;
    }
  }

pre_middle:
  word_length = word_trailing_length = 0;
  last_character = -1;

middle_word:
  I0 = start_word+word_length;
  if (I0 >= buffer_length)
   goto end_command;

  character = string_index(INTERP, buffer, I0);

  if (preserve_whitespace)
    goto middle_word_2;

  if (character < 33 && character != '\n')
    goto end_word;

  /* if this isn't a newline, skip */
  if (character != '\n')
    goto middle_word_2;

middle_word_1:
  word_trailing_length=1;
  goto end_command;

middle_word_2:
  /* wait, this was a semicolon - go back and deal with it.*/
  if (character == ';')
    goto middle_word_1;

  /* If we've gotten this far and we're in a brace-block, die */
  /* XXX gives wrong exception on quoted string */
  if (end_of_word == 1)
    real_exception(INTERP, NULL, E_Exception,
      "extra characters after close-brace");

  if (block_interpolation)
    goto check_bs;

  if (character == '[') {
    /* command block */
    old_length = word_length;
    chunk_start = start_word + word_length;
    word_length = Parrot_TclParser_match_close(INTERP, SELF, buffer,chunk_start);

    if (word_length < 0)
      real_exception(INTERP, NULL, E_Exception, "missing close-bracket");

    if (old_length) {
      /* if there's any word so far, save it*/
      S0 = string_substr(INTERP, buffer, start_word, old_length, NULL, 0);
      P1 = VTABLE_find_method(INTERP, word, ConcatConst);
      Parrot_call_method(INTERP, P1, word, ConcatConst, "vS", S0);
    }

    /* Save this as a command (skip the []'s)*/
    I0 = chunk_start + 1;
    I1 = word_length - 2;
    S0 = string_substr(INTERP, buffer, I0, I1, NULL, 0);
    P1 = VTABLE_find_method(INTERP, word, ConcatCommand);
    Parrot_call_method(INTERP, P1, word, ConcatCommand, "vS", S0);

    start_word = chunk_start + word_length;
    word_length = 0;

    goto middle_word;
  }

  if (character == '$')
    goto handle_variable;

check_bs:
  /* backslash */
  if (character == '\\')
    goto handle_backslash;

  last_character = character;
  word_length++;
  goto middle_word;

end_word:
  /*  save the word and put it into the command array */

  S0 = string_substr(INTERP, buffer, start_word, word_length, NULL, 0);
  P1 = VTABLE_find_method(INTERP, word, ConcatConst);
  Parrot_call_method(INTERP, P1, word, ConcatConst, "vS", S0);

  VTABLE_push_pmc(INTERP, command, word);

  start_word += word_length + word_trailing_length + 1;

  goto begin_word;

end_command:
  /*
   * if we're preserving whitespace and we're at the end of the command,
   * we must really be done.
   */
  if (preserve_whitespace)
    goto end_command_0;

  /*
   * If this was an empty line, we'll have a 0 word length but
   * a trailing length of 1. skip the newline
   */

  /* unless we finished the word, in which case... */
  if (end_of_word == 1)
    goto end_command_0;

  /*
   * Because of how we grabbed the command, we could have a word_length
   * of zero, but have a word object in process.
   */
  I0 = Parrot_PMC_get_intval(INTERP, word);
  if (I0 != 0)
    goto end_command_0;

  /* If word_length is zero now, don't bother adding the word. */
  /* (unless we're preserving whitespace...) */
  if (word_length == 0)
    goto end_command_1;

end_command_0:
  S0 = string_substr(INTERP, buffer, start_word, word_length, NULL, 0);
  P1 = VTABLE_find_method(INTERP, word, ConcatConst);
  Parrot_call_method(INTERP, P1, word, ConcatConst, "vS", S0);
  VTABLE_push_pmc(INTERP, command, word);
  if (preserve_whitespace)
    goto preserve_end_scope;


end_command_1:
  /* go to the next word*/

  I0 = Parrot_PMC_get_intval(INTERP, command);
  if (I0 == 0)
    goto end_command_2;

  VTABLE_push_pmc(INTERP, commands, command);

end_command_2:
  start_word += word_length;
  start_word += word_trailing_length;
  goto begin_command;


handle_variable:
  /* First, save off anything we've gotten so far as a constant.*/
  old_length = word_length;
  chunk_start = start_word + word_length;
  word_length = Parrot_TclParser_match_close(INTERP, SELF, buffer,chunk_start);

  /* if there's any word so far, save it*/
  if (old_length == 0)
    goto handle_variable_1;

  S0 = string_substr(INTERP, buffer, start_word, old_length, NULL, 0);
  P1 = VTABLE_find_method(INTERP, word, ConcatConst);
  Parrot_call_method(INTERP, P1, word, ConcatConst, "vS", S0);

handle_variable_1:
  /* Are we dealing with a braced-var name? */
  if (string_index(INTERP, buffer, ++chunk_start) != '{')
    goto handle_variable_nobrace;

  /* Get the closing brace, but we don't have to have matched pairs here. */
  I1 = string_str_index(INTERP, buffer, cb, chunk_start);
  if (I1 > buffer_length)
    real_exception(INTERP, NULL, E_Exception, "XXX invalid variable");

  /* Save the new start word for when we go to middle word.*/
  I1++;
  start_word = I1;
  word_length = 0;

  /* Name of variable is between the braces..*/
  chunk_start++;
  I2 = I1 - chunk_start - 1;
  S0 = string_substr(INTERP, buffer, chunk_start, I2, NULL, 0);
  P1 = VTABLE_find_method(INTERP, word, ConcatVariable);
  Parrot_call_method(INTERP, P1, word, ConcatVariable, "vS", S0);
  goto middle_word;

handle_variable_nobrace:
  temppos = chunk_start;

inner:
  if (++temppos >= buffer_length)
    goto inner_done;

  I0 = string_index(INTERP, buffer, temppos);
  if (
       (I0 >= 'A' && I0 <= 'Z') ||
       (I0 >= 'a' && I0 <= 'z') ||
       (I0 >= '0' && I0 <= '9') ||
       (I0 == '_')
     ) {
    goto inner;
  }

inner_done:
  /* Once we get here, we could also have a () to deal with..   */
  /* () */
  I1 = temppos - chunk_start;
  S0 = string_substr(INTERP, buffer, chunk_start, I1, NULL, 0);
  start_word = chunk_start + I1;
  word_length = 0;

  if (I0 != 40) {
    goto gotword;
  }
  temppos = string_str_index(INTERP, buffer, cp, start_word);
  if (temppos == -1) {
    real_exception(INTERP, NULL, E_Exception, "XXX bad array");
  }
  /* $S0($S1) */
  start_word++;
  I1 = temppos - start_word;
  S1 = string_substr(INTERP, buffer, start_word, I1, NULL, 0);
  start_word = temppos + 1;
  P1 = VTABLE_find_method(INTERP, word, ConcatVariable);
  Parrot_call_method(INTERP, P1, word, ConcatVariable, "vSS", S0, S1);
  goto middle_word;

gotword:
  /* $S0 was set to the name of the variable above. */
  P1 = VTABLE_find_method(INTERP, word, ConcatVariable);
  Parrot_call_method(INTERP, P1, word, ConcatVariable, "vS", S0);

  goto middle_word;

handle_backslash:
  /* dump anything so far as a constant.*/
  if (word_length == 0)
    goto backslash_escape;

  S0 = string_substr(INTERP, buffer, start_word, word_length, NULL, 0);
  P1 = VTABLE_find_method(INTERP, word, ConcatConst);
  Parrot_call_method(INTERP, P1, word, ConcatConst, "vS", S0);

  start_word += word_length;
  word_length =  0;

backslash_escape:
  /*
   * get the next character (start_word is now the beginning of the escape)
   * XXX Need to make sure we don't walk off the edge here.
  */

  start_word++;
  escape_length = 1;
  I0 = string_index(INTERP, buffer, start_word);
  /* add this escape as a sequence.*/
  P1 = VTABLE_find_method(INTERP, word, ConcatChar);
  switch (I0) {
    case 'a':
        Parrot_call_method(INTERP, P1, word, ConcatChar, "vI", 7);
        break;
    case 'b':
        Parrot_call_method(INTERP, P1, word, ConcatChar, "vI", 8);
        break;
    case 'f':
        Parrot_call_method(INTERP, P1, word, ConcatChar, "vI", 12);
        break;
    case 'n':
        Parrot_call_method(INTERP, P1, word, ConcatChar, "vI", 10);
        break;
    case 'r':
        Parrot_call_method(INTERP, P1, word, ConcatChar, "vI", 13);
        break;
    case 't':
        Parrot_call_method(INTERP, P1, word, ConcatChar, "vI", 9);
        break;
    case 'v':
        Parrot_call_method(INTERP, P1, word, ConcatChar, "vI", 11);
        break;
    /*
     * Unicode Excape:
     * Take 1-4 hex digits.
     */
    case 'u':
        I0 = 0;
        while (escape_length <= 4) {
            I1 = string_index(INTERP, buffer, start_word + escape_length);
            if (I1 >='0' && I1 <='9') {
                I0 = I0 * 16 + I1-'0';
            } else if (I1>='A' && I1<='F') {
                I0 = I0 * 16 + (I1 - 'A' + 10);
            } else if (I1>='a' && I1<='f') {
                I0 = I0 * 16 + (I1 - 'a' + 10);
            } else {
                break;
            }
            escape_length++;
        }
        if (escape_length == 1) {
            Parrot_call_method(INTERP, P1, word, ConcatChar, "vI", 'u');
        } else {
            Parrot_call_method(INTERP, P1, word, ConcatChar, "vI", I0);
        }
        break;
    /*
     * Hex Excape:
     * Take as many hex digit as we can get, but only the last
     * two are used to generate the character.
     */
    case 'x':
        /* loop, getting characters. Keep a running total in I0 */
        I0 = 0;
        while (1) {
            I1 = string_index(INTERP, buffer, start_word + escape_length);
            if (I1 >='0' && I1 <='9') {
                I0 = I0 * 16 + I1-'0';
            } else if (I1>='A' && I1<='F') {
                I0 = I0 * 16 + (I1 - 'A' + 10);
            } else if (I1>='a' && I1<='f') {
                I0 = I0 * 16 + (I1 - 'a' + 10);
            } else {
                break;
            }
            I0 = I0 % 256;  /* Toss away anything bigger than two digits. */
            escape_length++;
        }
        if (escape_length == 1) {
            Parrot_call_method(INTERP, P1, word, ConcatChar, "vI", 120);
        } else {
            Parrot_call_method(INTERP, P1, word, ConcatChar, "vI", I0);
        }
        break;
    /* Octal Escape (XXX: Too ASCII?) */
    /* We can take one to three digits. */
    case '0':
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
    case '8':
    case '9':
        I0 -= '0';
        I1 = string_index(INTERP, buffer, start_word+1);
        if (I1 >='0' && I1 <='9') {
            escape_length++;
            I0 = 8*I0 + I1-'0';
            I1 = string_index(INTERP, buffer, start_word+2);
            if (I1 >='0' && I1 <='9') {
                escape_length++;
                I0 = 8*I0 + I1-'0';
            }
        }
        Parrot_call_method(INTERP, P1, word, ConcatChar, "vI", I0);
        break;
    /* A backslash that didn't have any special meaning */
    default:
        Parrot_call_method(INTERP, P1, word, ConcatChar, "vI", I0);
  }

escape_done:
  /* skip the escaped char(s) */
  start_word = start_word + escape_length;
  goto middle_word;

  /* if we're preserving whitespace, just return the single command */

preserve_end_scope:
  return(command);

end_scope:
    /* If we have a command in progress, save it!*/
    if (Parrot_PMC_get_intval(INTERP, command)) {
      VTABLE_push_pmc(INTERP, commands, command);
    }
    return(commands);
  }

  /* Given a string and a beginning position in the string, return
   * the length of the string that forms a valid tcl construct.
   * [], {}, (), "", etc.
   *
   * return -1 if an invalid initial character is found
   * return -2 if no closing character is found.
   */

  METHOD INTVAL match_close(STRING *buffer, INTVAL index) {
    INTVAL opener;
    INTVAL closer = -1;
    INTVAL peekchar;
    INTVAL count = 1;
    INTVAL state = 1;
    INTVAL position = index;
    INTVAL bufferlen;
    INTVAL hierarchical = 0;
    INTVAL retval = -1;

    bufferlen = string_length(INTERP, buffer);
    opener = string_index(INTERP, buffer, index);

    switch (opener) {
        case '{':
            hierarchical = 1;
            closer = '}';
            break;
        case '[':
            hierarchical = 1;
            closer = ']';
            break;
        case '(':
            hierarchical = 1;
            closer = ')';
            break;
        case '"':
            closer = '"';
            break;
        default:
            return -1;
            /* invalid matching char. */
            /* XXX - generate an exception? */
    }

    /* state == 1, normal; 2, saw a backslash */

    /* loop_outer */
    while (count != 0) {
      position++;
      if (position == bufferlen) {
        return -2;
      }
      peekchar = string_index(INTERP,buffer,position);
      if (state == 2) {
        state = 1;
      } else if (peekchar == closer) {
        if (opener == closer) {
          count = 0;
        } else {
          count--;
        }
      } else if ((peekchar == opener) && hierarchical) {
        count++;
      } else if (peekchar == '\\') {
        state = 2;
      }
    }

    retval = position - index + 1;
    return retval;
  }

}
