=head1 tcllib

This file contains all the PIR necessary to setup the basic C<Tcl>,
C<_Tcl>, and C<_TclWord> namespaces. These namespaces can then be used
by our own C<tcl.imc> to setup a tclsh-like interpreter, or to allow
other PIR programs to access procedures in our own namespaces, also
providing a compreg-compatible method.

=cut

# don't pollute the global namespaces with our utility functions.

# setup some global constants (a bit TOO global, we should confine these
# to at least the _Tcl namespace)

# return codes
 .const int TCL_OK = 0
 .const int TCL_ERROR = 1
 .const int TCL_RETURN = 2
 .const int TCL_BREAK = 3
 .const int TCL_CONTINUE = 4

# expression codes - we use TCL_OK there, so move these out high enough
# so there's no conflict.

  .const int OP      = 20
  .const int FUNC    = 21
  # XXX Should be changed to OPERAND
  .const int INTEGER = 11
 
  # Still not sure if these are going to be useful
  .const int BLOCK   = 14
  .const int CHUNK   = 15
  .const int COMMAND = 16

  .const int MAX_PRECEDENCE =  9

# Constants for operator/function lookup.

  .const int OPERATOR_BITAND = 30
  .const int OPERATOR_BITOR  = 31
  .const int OPERATOR_BITXOR = 32
  .const int OPERATOR_DIV    = 33
  .const int OPERATOR_EQUAL  = 34
  .const int OPERATOR_GT     = 35
  .const int OPERATOR_GTE    = 36
  .const int OPERATOR_LT     = 37
  .const int OPERATOR_LTE    = 38
  .const int OPERATOR_MINUS  = 39
  .const int OPERATOR_MOD    = 40
  .const int OPERATOR_MUL    = 41
  .const int OPERATOR_PLUS   = 42
  .const int OPERATOR_SHL    = 43
  .const int OPERATOR_SHR    = 44
  .const int OPERATOR_UNEQUAL= 45
  .const int FUNCTION_ATAN2  = 46
  .const int FUNCTION_FMOD   = 47
  .const int FUNCTION_POW    = 48
  .const int OPERATOR_UMINUS = 49
  .const int OPERATOR_UPLUS  = 50
  .const int OPERATOR_BITNOT = 51
  .const int OPERATOR_LOGNOT = 52
  .const int FUNCTION_ABS    = 53
  .const int FUNCTION_ACOS   = 54
  .const int FUNCTION_ASIN   = 55
  .const int FUNCTION_ATAN   = 56
  .const int FUNCTION_COS    = 57
  .const int FUNCTION_COSH   = 58
  .const int FUNCTION_EXP    = 59
  .const int FUNCTION_LOG    = 60
  .const int FUNCTION_LOG10  = 61
  .const int FUNCTION_ROUND  = 62
  .const int FUNCTION_SIN    = 63
  .const int FUNCTION_SINH   = 64
  .const int FUNCTION_SQRT   = 65
  .const int FUNCTION_TAN    = 66
  .const int FUNCTION_TANH   = 67
  .const int FUNCTION_RAND   = 68

.namespace [ "_Tcl" ]

.sub __prepare_lib @LOAD

  # Load any dependant libraries.
  $P0 = loadlib "tcl_group"
  load_bytecode "languages/tcl/lib/tclword.pbc"
  load_bytecode "runtime/parrot/library/Data/Escape.pbc"
 
  .local int TclArray
  TclArray = find_type "TclArray" # happy case.

  .local pmc operators
  .local pmc math_funcs
  .local pmc precedence

  # XXX Should track how many args are needed for each of these.

  # Keep track of math functions
  math_funcs = new TclArray

  math_funcs["abs"]   = FUNCTION_ABS
  math_funcs["acos"]  = FUNCTION_ACOS
  math_funcs["asin"]  = FUNCTION_ASIN
  math_funcs["atan"]  = FUNCTION_ATAN
  math_funcs["cos"]   = FUNCTION_COS
  math_funcs["cosh"]  = FUNCTION_COSH
  math_funcs["exp"]   = FUNCTION_EXP
  math_funcs["log"]   = FUNCTION_LOG
  math_funcs["log10"] = FUNCTION_LOG10
  math_funcs["sin"]   = FUNCTION_SIN
  math_funcs["sinh"]  = FUNCTION_SINH
  math_funcs["sqrt"]  = FUNCTION_SQRT
  math_funcs["tan"]   = FUNCTION_TAN
  math_funcs["tanh"]  = FUNCTION_TANH

  operators = new TclArray
  precedence = new TclArray

  # This precedence check should be shoved into [expr]. There's no need
  # to make it this generic. 

  operators["*"] = OPERATOR_MUL
  precedence["*"] = 1 
  operators["/"] = OPERATOR_DIV
  precedence["/"] = 1 
  operators["%"] = OPERATOR_MOD
  precedence["%"] = 1 
  operators["+"] = OPERATOR_PLUS
  precedence["+"] = 2
  operators["-"] = OPERATOR_MINUS
  precedence["-"] = 2 
  operators["<<"] = OPERATOR_SHL
  precedence["<<"] = 3 
  operators[">>"] = OPERATOR_SHR
  precedence[">>"] = 3 
  operators["<"] = OPERATOR_LT
  precedence["<"] = 4
  operators[">"] = OPERATOR_GT
  precedence[">"] = 4
  operators["<="] = OPERATOR_LTE
  precedence["<="] = 4 
  operators[">="] = OPERATOR_GTE
  precedence[">="] = 4
  operators["=="] = OPERATOR_EQUAL
  precedence["=="] = 5
  operators["!="] = OPERATOR_UNEQUAL
  precedence["!="] = 5 
  operators["&"] = OPERATOR_BITAND
  precedence["&"] = 7
  operators["^"] = OPERATOR_BITXOR
  precedence["^"] =  8
  operators["|"] = OPERATOR_BITOR
  precedence["|"] = 9

  store_global "_Tcl", "operators", operators
  store_global "_Tcl", "functions", math_funcs
  store_global "_Tcl", "precedence", precedence

  # Eventually, we'll need to register MMD for the various Tcl PMCs
  # (Presuming we don't do this from the .pmc definitions.)

  # XXX These go away when [proc] is a little smarter.
  $P1 = new TclArray
  store_global "_Tcl", "proc_body", $P1

  # Global variable initialization
  # XXX Are outer level tcl scopes true globals, or are they merely top
  # level lexicals?
  #$P0 = new String
  #$P0 = "0.1"
  #store_lex 0, "tcl_patchLevel", $P0
  #$P0 = new String
  #$P0 = "0.1"
  #store_lex 0, "tcl_version", $P0
 
  # Setup the default channelIds
  $P1 = new TclArray
  $P2 = getstdin
  $P1["stdin"] = $P2
  $P2 = getstdout
  $P1["stdout"] = $P2
  $P2 = getstderr
  $P1["stderr"] = $P2
  store_global "_Tcl", "channels", $P1
  
  # Setup the id # for channels..
  $P1 = new Integer
  $P1 = 1
  store_global "_Tcl", "next_channel_id", $P1

  $P1 = find_global "_Tcl", "_tcl_compile"
  compreg "TCL", $P1

.end

.sub _tcl_compile 
  .param string tcl_code

  .local pmc pir_compiler
  .local string pir_code

  .local pmc escaper
  escaper = find_global "Data::Escape", "String" 
 
  pir_compiler = compreg "PIR"

  # should generate a new sub each time, or no?
  # yes, we should.
  pir_code = ".namespace [ \"_Tcl\" ]\n.sub _throwaway_sub\n.local string code\ncode = \""
  tcl_code = escaper(tcl_code,"\"")
  pir_code .= tcl_code
  pir_code .= "\"\n.local pmc tcl_parse\n.local pmc tcl_interpret\ntcl_parse = find_global \"_Tcl\", \"__parse\"\ntcl_interpret = find_global \"_Tcl\", \"__interpret\"\n$P1 = tcl_parse(code,0,0)\n($I0,$P3) = tcl_interpret($P1)\n.return($I0,$P3)\n .end\n"

  .local pmc compiled_sub
  compiled_sub = compile pir_compiler, pir_code

  .return(compiled_sub)
.end

# This handler is just supposed to get us back to the next
# instruction. It's our job to deal with it in the calling
# code, then.

# WJC - 11/21 - not allowed to use a non-local handler anymore.
#.namespace [ "_Tcl"]
#.emit
#__default_handler:
  #set P4, P5["_invoke_cc"]
  #set P5, P5["_P5"]
  #invoke P4
#.eom

${INCLUDES}
