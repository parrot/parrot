=head1 Primary Goal

Primary goal right now should be to pass a single test from a single file in
the tcl suite of tests.

Let's pick C<concat.test>, as we already would pass several of those tests
if they were recast into the tcl test suite.

To get this to work, we need to get (at least partial) implementations of:

  [lsearch]
  [namespace children]
  [namespace import -force]
  [package require]

the test scripts import the library C<tcltest>, which in turn uses quite
a bit more. We can use a stripped down version of C<tcltest> that does
the bare minimum to get things started.

=head1 Various

=over 4

=item interactive tclsh

simple interactive mode now exists. Still have to:

 o Should catch any real_exceptions thrown.
 o respect tcl_prompt1, tcl_prompt2
 o deal with incomplete input (needs better error handling)
 o give invalid commands to the system.

=item [interpinfo name]

how to do this from inside parrot?
[ there's a RT ticket for this now, someone should put the # here.]

=item migrate all these issues to RT or TODO tests

=item provide a way to test a recent tcl suite. [matt]

=item update docs [will]

(including add pod to all .imc)

=back

=head1 Programming Issues

=head2 C-level tasks

=over 4

=item string to list 

Should be moved to tcllist's set_string method. ... except that it turns
out this is non-trivial.

=back

=head2 PIR-level tasks

=over 4

=item subcommand processing

Convert any commands that use subcommands to [info] style dispatch to ease
maintenance. Subcommands invoked in this style get a single container PMC
with all their args, but *NOT* the invoking command. so, given the tcl:

  info args foo

Tcl::info is called with (args, foo), which then dispatched to:

_Tcl::builtins::info::args ((foo)).

=item clean up variable access

Currently wherever a normal C<find_lex> or C<store_lex>  might be, we have a 
snippet of code
to lookup the call_level (shouldn't even have this as a global), and based on
that, treat the variable like a global instead. This should all be re-factored
out into a single location. We also hardcode the default global namespace, 
which in parrot is "Tcl". Refactoring this will save us pain when we add
[namespace] support.

=item implement default globals, etc.

global variables provided by tcl libary. L<tclvars>.

global variables provided by tcl interpreter. L<tclsh>

source per-user settings. L<tclsh>

=item unimplemented commands/subcommands

[after] [array get] [array names] [array unset] 
[array statistics] [array anymore] [array donesearch]
[array nextelement] [array startsearch] [bgerror] [binary] 
[case] [clock] [close] [cd] [dde] [encoding] [eof] [exec]
[fblocked] [fconfigure] [fcopy] [file] [fileevent]
[flush] [gets] [glob] [http] [interp] [library]
[lindex] [load] [lreplace] [lsearch] [lset] [lsort] 
[memory] [msgcat] [namespace] [open] [package] [pid] [pwd]
[read] [registry] [regexp] [regsub] [resource] 
[safe] [scan] [seek] [socket] [subst]
[string replace] [string tolower] [string totitle] [string toupper]
[string trim] [string trimleft] [string trimright]
[string compare] [string equal] [string last]
[string bytelength] [string is] [string map]
[string wordstart] [string wordend] [switch] [tcltest]
[tell] [update] [variable] [vwait]

=back

=head2 Tests

=over 4

=item standards

Any future tests, write more like t/tcl_var_subst.t. Eventually cleanup
tests so they're consistent.

=item Add tests for...

=over 4

=item info

tclversion, body, args, exists

=item expr's precedence and parens and missing functionality.

=item [puts]'s ability to write to other channels

=item [uplevel]

=item [upvar]

=item [lrange]

=back

=back

=head1 Uncategorized Issues

=over 4

=item provide a way to access existing library PIR from Tcl.

Perhaps via [namespace import]? Can fake it right now with [inline]

=item multiple level lists

=item expr

Clean up [expr]. MUUUUCH room for improvement there. [expr] is the source
of most of our abysmal performance in bench.tcl.

the expr AST could use a rework. Be nice if it just passed around something
invokable.

clean up expr so that it's not passing around
type indicators. - just use PMCs everywhere. (Though we may still need
to have CONST vs. VARIABLE types.)

The type indicator is also used to disambiguate operators and function calls
from operands. We can easily remove it for operands, but how to cleanly
remove this for operators? 

TBD: strings, floats as operands - (many of the math funcs return floats
but you can't specify them, and not everything takes them 
(try, for example, [expr sin(1) + sin(1)] vs [expr sin(1) * sin(1)].)

TBD: blocks, commands, and strings as operands

TBD: logical binary ops & ternary op (need deferred evaluation) ; unary ops;
ops that work on strings only.

TBD: functions that take > 1 arg.

TBD: Argument type requirements - Currently works ONLY on bitand - esp need
to get any that require int-only args, as we can now /generate/ floats,
even if we cannot specify them. This is all supportable by MMD - we just
need to specify the correct errors to throw.

=item misc

complete [error]

=back

=cut
