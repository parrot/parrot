=head1 In no particular order....

=over 4

=item PMC based parser -

Instead of the current PIR level parsing, we should instead use
a pmc - not only should this improve speed slightly, but will help
us implement the [parser] builtin.

=item string to list 

Should be moved to tcllist's set_string method. (but this requires first
moving the parser into a pmc.)

=item given PGE

[array get] [array names] [array unset] 
[regexp] [regsub] [switch] [glob]

=item migrate all these issues to RT.

TODO tests would also suffice, where possible.

=item tclword

An object is probably too heavyweight for this. A PMC with a few overloaded
methods is probably sufficient.

=item From leo - cleanup of tcl objects.

C<tclobject> is an abstract object, it doesn't have a vtable. But the
bundling code *does* C<pmc_register> this PMC. This leads to an empty
vtable slot, dereferencing that NULL is an operation, which many systems
don't like.

I'd first reduce C<TclArray> to a bare minimum. Specifically the creation
functions (init, clone) should be inherited (or follow the C<PerlHash>
conventions). The same applies to any PMC that can hold pointers to
other PMCs.

These changes are necessary to make a PMC compliant with incremental GC.
Please grep through the docs and the sources for DOD_WRITE_BARRIER.

=item Remove Perl*

Mostly done. All that seems to be left is PerlUndef. Much was already
converted to the internal types. PerlUndef removal will probably result
(finally) in the use of null checks where it's being used for that, and
TclObject where it's being used for shimmering.

=item Freeze/Thaw of TclWord would ...

allow us to build a braindead compile
option - given a chunk of tcl, generate a chunk of PIR that we can 
emit to be saved, compiled, and then run again.

=item tail call optimizations

tail call optimizations - there are several cases where I could use this
and save myself a call. Possible to do right now with PASM - wait for
PIR support before welding in.

=item provide a way to access existing library PIR from Tcl.

=item add benchmarks?

=item cross language compatibility 

We need to make sure that we I<take> any PMC and try to do the right
thing. Don't I<require> that someone pass in a TclString when a PerlString
will work fine, thanks. This is now a bigger issue when using the [list] ops.
if someone passes in a fixed list and we need to resize it... what do we do?

=item given freeze/thaw for objects...

Once freeze/thaw is working for tclwords (currently waiting on parrot
support), rewrite proc to preparse
once and cache the result in the generated sub rather than reparsing
each time.

(Though this seems evil, too. There must be a better way.)

=item TclWord

implement C<is_const> to allow for some optimizations in the compiler. 
(which isn't written yet.)
when adding words, default to true, but if at any point we add a variable
or a command, invalidate that. (mostly done!)

Move TclWord namespace into _Tcl::Word, less clutter?

=item multiple level lists

This will be much easier to do when we can call into the parser from
the TclList PMC. (is this already doable?)

=item [[list]] proc

doesn't handle varargs.

support default values (e.g.: proc joe {{drink coffee}} { slurp $drink } )

=item compiler vs. interpreter

it should be possible to further extend our interpreter
this to make an actual compiler,
where the _compiler emits PIR. So, the resulting call from, say, [source]
would be:

	# Note this a change from _parse's current signature 
	(parsed_data_structure,tcl_status,error) = _parse(tcl_code)
	(pir_code,tcl_status,error) = _compile(parsed_data_structure)
	
And now that we have the pir_code, we can either emit the necessary
PIR (ala parrot's -o option) or we can compile and run it.

Caveat: how to support -o with user defined procs - right now, proc is defining
the sub on the fly, where, with a compiler, we may want to defer compilation,
and simply be able to extract the generated PIR.

=item (LOW) speed

Comparing examples/fact.tcl with parrot vs. tclsh (OSX)

 ??/??/??: 8-12 x slower, single call
 05/14/04: 500 calls in a loop slows us down to 60x!
 11/22/04: 500 calls in a loop: only 10x slower!

=item Tests

Any future tests, write more like t/tcl_var_subst.t. Eventually cleanup
tests so they're consistent.

=item Add tests for...

tclword.imc tcl*.pmc
[concat] [join] [list] [llength] [lappend] [linsert] [lrepeat]
[lrange] [array set] [global] [string match] [inline]
[uplevel] [upvar]
the macros?
expr's precedence and parens
[puts]'s ability to write to other channels.

=item update docs/* 

with the parser/interpreter split, things are different.
(And, hopefully, easier.)

=item Use PMCs to handle numifying

not the pir routines we now have. Verify that [expr 2a + 2b] behaves
appropriately when doing this. Include proper numififcation of octal and
hex

=item test suite patches

need to patch testall so that it's not so cranky about people
who don't play nice with the new tests...

=item unfinished commands

[array statistics] - useless?

[array anymore], [array donesearch] [array nextelement], [array startsearch]
 { use iterators }

[string repeat], [string replace], [string tolower],
[string totitle], [string toupper], [string trim], [string trimleft],
[string trimright], [string compare], [string equal], [string last]

[string bytelength], [string compare], [string is], [string map],
[string wordstart], [string wordend]

=item given [list]

[foreach]

=item given arrays

[string map]

=item expr

Clean up expr. MUUUUCH room for improvement there.

expr - parse/interpret split - This is working for expr - change any other 
thing that calls __expression to use the _p, _i variants, delete the original 
proc. Once we've done that, determine a better structure to use as the inter
mediate representation between the two.

clean up expr so that it's not passing around
type indicators. - just use PMCs everywhere. (Though we may still need
to have CONST vs. VARIABLE types.

The type indicator is also used to disambiguate operators and function calls
from operands. We can easily remove it for operands, but how to cleanly
remove this for operators? 

TBD: strings, floats as operaands - (many of the math funcs return floats
but you can't specify them, and not everything takes them 
(try, for example, [expr sin(1) + sin(1)] vs [expr sin(1) * sin(1)].)

TBD: blocks, commands, and strings as operands

TBD: logical binary ops & ternary op (need deferred evaluation) ; unary ops;
ops that work on strings only.

TBD: functions that take > 1 arg.

TBD: Argument type requirements - Currently works ONLY on bitand - esp need
to get any that require int-only args, as we can now /generate/ floats,
even if we cannot specify them. {This probably requires switching to Tcl*
PMCs and putting the logic in there hidden under MMD}

=item misc

tclsh normally does some extra processing that we aren't doing, namely
.tclshrc/tclshrc.tcl, setting of variables argc, argv, argv0, and
tcl_interactive... see also "man n tclvars"

=item misc

interactive tclsh mode currently only waits for EOF and then runs all
commands entered. should have sane defaults for tcl_prompt1, tcl_prompt2
and respect them, and process intermediate input.

=item misc

octal and hex escapes are not supported. (Not sure parrot is
ready for this yet)

=item tests 

run a tcl test suite (7.6p2 ?) and pass one test.
(then, pass most of them.) (then, retarget against tcl-latest)

=item misc

complete [error] (need global var support)

If the return type of the outermost script is not OK, return the
I<appropriate> code to the system.

=item missing procs

Here's a list of commands from the 7.3 Ousterhout book that have yet to be
implemented. Just because something is implemented doesn't mean it's a full
implementation, either. That's what the test suite is for. =-) I've tried
to group them so that any procs that depend on another proc to really work
are so listed, and that related procs are grouped together. Some are SMOPs
at this point, others require me to add features, or refactor. Many already
implemented procs will require updating after procs/features are added.

  lreplace, lsearch, lsort, foreach, scan

  cd, file, pwd, pid, glob

  seek, tell, open, close, eof, flush (use pioctl?), read, gets, close

  info, exec {use exec/spawn opcodes.}

  auto_mkindex*, trace*

  unknown, history [ only in interactive mode ]

  * isn't a recent distro of tcl
  
  And, here are more from a more recent tcl in no order.

  after bgerror binary case clock dde
  encoding fblocked fconfigure (use pioctl?) fcopy fileevent filename
  http interp {setup our current single parser/interp as an pmc?}
  library lindex load lset memory
  msgcat namespace package packagens
  pkgMkIndex registry resource
  safe socket subst (use our parser?) tcltest
  update variable vwait
 
  also see "man n tclvars"

=item tests

Long term goal: Run the tcl test suite. Will an  older one, be easier to pass?
Yes, much easier. We still have a ways to go, however. To run all the tests,
run tclsh, sourcing "<tcl distro>tests/all".

The sooner we can do this, the better, as I only want to have tests for
internals, not for any Tcl.

=back 4

=cut
