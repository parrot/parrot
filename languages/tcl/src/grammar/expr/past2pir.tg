grammar TclExpr::PIR::Grammar is TGE::Grammar;

transform result (ROOT)  {
    .local pmc pir
    pir = new 'PGE::CodeString'

    $S0 = typeof node
    $P0 = tree.get('pir', node, $S0)
    pir .= $P0

    .local pmc ret, label
    ret   = node['ret']
    label = pir.unique('expr_is_string')
 
    pir.emit(<<'END_PIR', ret, label)
  .local pmc __number
  __number = get_root_global ['_tcl'], '__number'
  push_eh %1
    %0 = __number(%0)
  clear_eh
%1:
END_PIR

    .return(pir)
}

transform pir (PAST::Program) {
    .local string pir

    .local pmc iter, child
    iter = node.'child_iter'()
loop:
    unless iter goto end
    child = shift iter
    $P0 = tree.'get'('pir', child)
    $S0 = $P0
    pir .= $S0
    goto loop
end:
    $S0 = child['ret']
    node['ret'] = $S0
    .return(pir)
}

transform pir (PAST::Val) {
    .local pmc pir
    .local pmc ret
    .local pmc class

    pir = new 'PGE::CodeString'
    ret = pir.unique('$P')
    class = node['class']
    pir.emit("    %0 = new '%1'", ret, class)
    $S0 = node['value']
    if class == "TclFloat"  goto assign_float
    if class == "TclString" goto assign_string
    if class == "TclConst"  goto assign_string
    goto assign_val
  assign_float:                                    
    $I0 = index $S0, '.'                           # XXX: '.' hack due to
    if $I0 >= 0 goto assign_val                    # parrotbug #38896
    $I0 = index $S0, 'E'
    if $I0 >= 0 goto assign_val
    $I0 = index $S0, 'e'
    if $I0 >= 0 goto assign_val
    concat $S0, '.'
    goto assign_val
  assign_string:
    $S0 = escape $S0
    $S0 = concat '"', $S0
    $S0 = concat $S0, '"'
  assign_val:
    pir.emit('    assign %0, %1', ret, $S0)
  end:
    node['ret'] = ret
    node['istemp'] = 1
    .return (pir)
}

transform pir (PAST::Var) {
    .local pmc pir, ret
    pir = new 'PGE::CodeString'
    ret = pir.unique('$P')
    node['ret']    = ret
    node['istemp'] = 1
    
    .local string name
    name = node['name']

    $I0 = exists node['index']
    if $I0 goto array

    pir.emit(<<'END_PIR', ret, name)
  .local pmc __read
  __read = get_root_global ['_tcl'], '__read'
  %0 = __read('%1')
END_PIR
    .return(pir)

array:
    .local pmc    index
    index = node['index']
    
    $P0 = tree.get('pir', index)
    pir .= $P0
    $S0 = index['ret']
    pir.emit(<<'END_PIR', ret, name, $S0)
  .local pmc __read
  __read = get_root_global ['_tcl'], '__read'
  $S0 = %2
  $S0 = '%1(' . $S0
  $S0 = $S0 . ')'
  %0 = __read($S0)
END_PIR
    .return(pir)
}

transform pir (PAST::Op) {
    .local pmc args,iter,pir
    .local pmc return_register
 
    pir = new 'PGE::CodeString'
    args = new .ResizablePMCArray
    iter = node.'child_iter'()
  iter_loop: 
    unless iter goto iter_done
    $P1 = shift iter
    $P0 = tree.get('pir', $P1)
    return_register = $P1['ret']
    push args, return_register
    pir .= $P0
    goto iter_loop
  iter_done:
    # get a result PMC
    .local pmc retval
    retval = pir.unique('$P')
    pir .= retval
    pir .= " = '"
    $S0 = node['opfunc']
    pir .= $S0
    pir .= "'("
    $S0 = join ", ", args
    pir .= $S0
    pir .= ")\n" 
    node['ret'] = retval
    .return (pir)
}

transform pir (PAST::MathFunc) {
    .local pmc args,iter,pir
    .local pmc return_register
 
    pir  = new 'PGE::CodeString'
    args = new .ResizablePMCArray
    iter = node.'child_iter'()
  iter_loop: 
    unless iter goto iter_done
    $P1 = shift iter
    $P0 = tree.get('pir', $P1)
    return_register = $P1['ret']
    push args, return_register
    pir .= $P0
    goto iter_loop
  iter_done:
    # get a result PMC
    .local pmc retval
    retval = pir.unique('$P')
    $S0    = node['mathfunc']
    pir.emit("%0 = get_hll_global ['tcl'; 'mathfunc'], '&%1'", retval, $S0)
    pir .= retval
    pir .= " = "
    pir .= retval
    pir .= "("
    $S0 = join ", ", args
    pir .= $S0
    pir .= ")\n" 
    node['ret'] = retval
    .return (pir)
}

transform pir (PAST::Command) {
    .local pmc args, iter, pir, reg
    
    pir  = new 'PGE::CodeString'
    args = new .ResizablePMCArray
    iter = node.'child_iter'()
  iter_loop: 
    unless iter goto iter_done
    $P1 = shift iter
    $P0 = tree.get('pir', $P1)
    reg = $P1['ret']
    push args, reg
    pir .= $P0
    goto iter_loop
  iter_done:
    .local pmc retval, name
    retval = pir.unique('$P')
    name = shift args
    $S0 = join ", ", args
    
    pir.emit(<<'END_PIR', retval, name, $S0)
  %0 = get_hll_namespace
  $S0 = %1
  $S0 = '&' . $S0
  %0  = %0[$S0]
  %0  = %0(%2)
END_PIR
    node['ret'] = retval
    .return(pir)
}

transform pir (PAST::Cond) {
    .local pmc args, pir, ret, label
    .local pmc children, cond, then, else
    .local string cond_result, then_result, else_result

    pir = new 'PGE::CodeString'
    pir.emit('  .local pmc __boolean')
    pir.emit('  __boolean = get_root_global ["_tcl"], "__boolean"')

    # This node has 3 children. generate PIR so that:
    # if node1 then node2 else node3

    # pick a unique register to store our result in.
    ret = pir.unique('$P')

    #  pick a unique number for our labels..
    label = pir.unique('label_')

    children = node.'get_children'()

    cond = children[0] 
    $S0 = tree.get('pir', cond)
    pir .= $S0
    cond_result = cond['ret']

    pir.emit("  %0 = __boolean(%0)",    cond_result)
    pir.emit("  unless %0 goto else_%1", cond_result, label)

    then = children[1] 
    $S0 = tree.get('pir', then)
    pir .= $S0
    then_result = then['ret']

    pir.emit('    %0 = %1', ret, then_result)
    pir.emit("  goto end_if_%0", label)
 
    #set the result register to the answer from this section  
 
   #then jump to custom end label..

    pir.emit("  else_%0:",label)

    else = children[2] 
    $S0 = tree.get('pir', else)
    pir .= $S0
    else_result = else['ret']

    pir.emit('    %0 = %1', ret, else_result)

    #set the result register to the answer from this section  

    pir.emit("  end_if_%0:",label)

    node['ret'] = ret

    .return (pir)
}

