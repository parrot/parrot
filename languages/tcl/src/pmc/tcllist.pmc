/*
Copyright (C) 2001-2008, The Perl Foundation.
$Id$

=head1 NAME

pmc/tcllist.pmc - Tcl List

=head1 DESCRIPTION

These are the vtable functions for the TclList base class

=head2 Methods

=over 4

=cut

*/

#include "parrot/embed.h"

/* cache of classes referenced */

pmclass TclList
    dynpmc
    need_ext
    extends ResizablePMCArray
    provides    array
    group   tcl_group
    hll     Tcl
    maps    Array
    maps    ResizablePMCArray
{

/*

=item C<STRING *get_string()>

Returns the list as a string

=cut

*/

    VTABLE STRING* get_string() {
        STRING *retval  = string_from_literal(INTERP, "");
        STRING *replace = string_from_literal(INTERP, "replace");
        INTVAL  elems   = VTABLE_get_integer(INTERP, SELF);
        INTVAL  i;
        STRING *orig, *repl;
        PMC    *P0;
        INTVAL  count, pos;

        for (i = 0; i < elems; i++) {
            STRING *str    = VTABLE_get_string_keyed_int(INTERP, SELF, i);
            INTVAL str_len = string_length(INTERP, str);

            if (str_len == 0) {
                /* empty element */
                str = string_from_literal(INTERP, "{}");
                goto append_elem;
            }

            count = pos = 0;
            while (pos < str_len) {
                switch (string_ord(INTERP, str, pos)) {
                    case '{':
                        count++;
                        break;
                    case '}':
                        if (--count < 0) goto escape;
                        break;

                }
                pos++;
            }

            if (count != 0) goto escape;

            if (-1 != string_str_index(INTERP,  str, string_from_literal(INTERP, "["), 0))
                 goto quote;

            /* only check hashes on first elem.*/
            if (i == 0 && -1 != string_str_index(INTERP, str, string_from_literal(INTERP, "#"), 0))
                goto quote;

            if (-1 != string_str_index(INTERP, str, string_from_literal(INTERP, "$"), 0))
                goto quote;

            if (-1 != string_str_index(INTERP, str, string_from_literal(INTERP, ";"), 0))
                goto quote;

            /* \'d constructs */
            if (-1 != string_str_index(INTERP, str, string_from_literal(INTERP, "]"), 0))
                goto escape;

            if (-1 != string_str_index(INTERP, str, string_from_literal(INTERP, "\\"), 0))
                goto escape;

            /* {}'d constructs */
            if (str_len != CHARSET_FIND_CCLASS(INTERP, enum_cclass_whitespace, str, 0, str_len))
                goto quote;

            goto append_elem;

          escape:
            P0 = pmc_new(INTERP, enum_class_String);
            VTABLE_set_string_native(INTERP, P0, str);

            orig = string_from_literal(INTERP, "\\");
            repl = string_from_literal(INTERP, "\\\\");
            Parrot_PCCINVOKE(INTERP, P0, replace, "SS->", orig, repl);

            orig = string_from_literal(INTERP, "\t");
            repl = string_from_literal(INTERP, "\\t");
            Parrot_PCCINVOKE(INTERP, P0, replace, "SS->", orig, repl);

            orig = string_from_literal(INTERP, "\f");
            repl = string_from_literal(INTERP, "\\f");
            Parrot_PCCINVOKE(INTERP, P0, replace, "SS->", orig, repl);

            orig = string_from_literal(INTERP, "\n");
            repl = string_from_literal(INTERP, "\\n");
            Parrot_PCCINVOKE(INTERP, P0, replace, "SS->", orig, repl);

            orig = string_from_literal(INTERP, "\r");
            repl = string_from_literal(INTERP, "\\r");
            Parrot_PCCINVOKE(INTERP, P0, replace, "SS->", orig, repl);

            orig = string_from_literal(INTERP, "\v");
            repl = string_from_literal(INTERP, "\\v");
            Parrot_PCCINVOKE(INTERP, P0, replace, "SS->", orig, repl);

            orig = string_from_literal(INTERP, ";");
            repl = string_from_literal(INTERP, "\\;");
            Parrot_PCCINVOKE(INTERP, P0, replace, "SS->", orig, repl);

            orig = string_from_literal(INTERP, "$");
            repl = string_from_literal(INTERP, "\\$");
            Parrot_PCCINVOKE(INTERP, P0, replace, "SS->", orig, repl);

            orig = string_from_literal(INTERP, "}");
            repl = string_from_literal(INTERP, "\\}");
            Parrot_PCCINVOKE(INTERP, P0, replace, "SS->", orig, repl);

            orig = string_from_literal(INTERP, "{");
            repl = string_from_literal(INTERP, "\\{");
            Parrot_PCCINVOKE(INTERP, P0, replace, "SS->", orig, repl);

            orig = string_from_literal(INTERP, " ");
            repl = string_from_literal(INTERP, "\\ ");
            Parrot_PCCINVOKE(INTERP, P0, replace, "SS->", orig, repl);

            orig = string_from_literal(INTERP, "[");
            repl = string_from_literal(INTERP, "\\[");
            Parrot_PCCINVOKE(INTERP, P0, replace, "SS->", orig, repl);

            orig = string_from_literal(INTERP, "]");
            repl = string_from_literal(INTERP, "\\]");
            Parrot_PCCINVOKE(INTERP, P0, replace, "SS->", orig, repl);

            orig = string_from_literal(INTERP, "\"");
            repl = string_from_literal(INTERP, "\\\"");
            Parrot_PCCINVOKE(INTERP, P0, replace, "SS->", orig, repl);

            str = VTABLE_get_string(INTERP, P0);
            goto append_elem;

          quote:
            str = string_append(INTERP, string_from_literal(INTERP, "{"), str);
            str = string_append(INTERP, str, string_from_literal(INTERP, "}"));

          append_elem:
            retval = string_append(INTERP, retval, str);
            retval = string_append(INTERP, retval, string_from_literal(INTERP, " "));
        }

        /* remove the extra space at the end, if necessary*/
        if (string_length(INTERP, retval))
            string_chopn_inplace(INTERP, retval, 1);

        return retval;
    }

/*

=item C<void set_pmc(PMC *other)>

An alias to assign_pmc to make other things happy before set_pmc is removed.

=cut

*/

    void set_pmc(PMC *other) {
        VTABLE_assign_pmc(INTERP, SELF, other);
    }

/*

=item C<void assign_pmc(PMC *other)>

Copy the contents of other to self.

=back

=cut

*/

    void assign_pmc(PMC *other) {
        STRING *array  = string_from_cstring(INTERP, "array", 5);
        STRING *string = string_from_cstring(INTERP, "String", 6);
        STRING *undef  = string_from_cstring(INTERP, "Undef", 5);

        if (VTABLE_does(INTERP, other, array))
        {
            INTVAL size;
            INTVAL i;

            size = VTABLE_elements(INTERP, other);
            SELF.set_integer_native(size);
            for (i = 0; i < size; i++) {
                PMC* elem = VTABLE_get_pmc_keyed_int(INTERP, other, i);
                SELF.set_pmc_keyed_int(i, elem);
            }
        }
        else if (VTABLE_isa(INTERP, other, string))
        {
            STRING *v = VTABLE_get_string(INTERP, other);
            pmc_reuse(INTERP, SELF, other->vtable->base_type, 0);
            SELF.set_string_native(v);
        }
        else if (VTABLE_isa(INTERP, other, undef))
        {
            pmc_reuse(INTERP, SELF, other->vtable->base_type, 0);
        }
        else
        {
            real_exception(INTERP, NULL, E_TypeError,
                           "unable to assign self to TclList");
        }
    }

}

/*
 * Local variables:
 *   c-file-style: "parrot"
 * End:
 * vim: expandtab shiftwidth=4:
 */
