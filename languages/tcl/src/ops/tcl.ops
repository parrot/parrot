/*
 * $Id$
 * Copyright (C) 2006-2008, The Perl Foundation.
 */

/*
** tcl.ops
*/

#include "parrot/parrot.h"
#include "parrot/string_funcs.h"
#include "parrot/exceptions.h"

#include "../binary.h"

VERSION = PARROT_VERSION;

=head1 NAME

tcl.ops

=cut

=head1 DESCRIPTION

A dynamic opcode library for tcl on parrot that provides a few opcodes
that simplify PIR generation for tclPIR generation for tcl

BUGS: pull out the TCL_ constants, as well as the code slot(#9)

=cut

=head1 C<[binary]> opcodes

=over 4

=item B<tcl_binary_scan>(out PMC, in STR, in STR)

Scan $2 for the fields specified in $3 and return their values in $1.

=cut

inline op tcl_binary_scan(out PMC, in STR, in STR) {
    $1 = ParTcl_binary_scan(interp, $2, $3);
}

=item B<tcl_binary_format>(out STR, in STR, in PMC)

Format the values in $3 into a string $1 according to the format in $2.

=cut

inline op tcl_binary_format(out STR, in STR, in PMC) {
    $1 = ParTcl_binary_format(interp, $2, $3);
}

=back

=head1 Flow control opcodes

These opcodes are used to generate exception return values. (Anything that
isn't a TCL_OK).

=over 4

=item B<tcl_error>(in STR, in PMC)

Generate a TCL_ERROR with $1 as the value, and set $errorCode to $2

=cut

inline op tcl_error(in STR, in PMC) :flow {
    PMC      *errorCode, *ns;
    PMC      *const root_ns = interp->root_namespace;
    PMC      *tcl_key        = pmc_new(interp, enum_class_Key);
    PMC *exception = Parrot_ex_build_exception(interp, EXCEPT_error,
            CONTROL_ERROR, $1);
    opcode_t * const ret  = expr NEXT();
    opcode_t * dest;

    /* Set the global $errorCode */
    VTABLE_set_string_native(interp, tcl_key, string_from_literal(interp, "tcl"));
    ns = Parrot_get_namespace_keyed(interp, root_ns, tcl_key);

    errorCode = Parrot_find_global_n(interp, ns, string_from_literal(interp, "$errorCode"));
    VTABLE_assign_pmc(interp, errorCode, $2);

    /* Throw the exception */
    dest = Parrot_ex_throw_from_op(interp, exception, ret);
    goto ADDRESS(dest);
}

=item B<tcl_return>(in PMC)

=item B<tcl_return>(in STR)

Generate a TCL_RETURN, returning the specified value

=cut

inline op tcl_return(in PMC) :flow {
    opcode_t * const ret = expr NEXT();
    STRING          *msg = PMC_IS_NULL($1)
                         ? NULL : VTABLE_get_string(interp, $1);
    PMC            *exception =
        Parrot_ex_build_exception(interp, EXCEPT_error, CONTROL_RETURN, msg);
    opcode_t       *dest = Parrot_ex_throw_from_op(interp, exception, ret);
    goto ADDRESS(dest);
}

inline op tcl_return(in STR) :flow {
    PMC *exception = Parrot_ex_build_exception(interp, EXCEPT_error,
            CONTROL_RETURN, $1);
    opcode_t * const ret  = expr NEXT();
    opcode_t * const dest = Parrot_ex_throw_from_op(interp, exception, ret);
    goto ADDRESS(dest);
}

=item B<tcl_break>()

Generate a TCL_BREAK

=cut

inline op tcl_break() :flow {
    STRING   *empty     = string_make_empty(interp, enum_stringrep_one, 0);
    PMC *exception = Parrot_ex_build_exception(interp, EXCEPT_error,
            CONTROL_BREAK, empty);
    opcode_t * const ret  = expr NEXT();
    opcode_t * const dest = Parrot_ex_throw_from_op(interp, exception, ret);
    goto ADDRESS(dest);
}

=item B<tcl_continue>()

Generate a TCL_CONTINUE

=cut

inline op tcl_continue() :flow {
    STRING   *empty     = string_make_empty(interp, enum_stringrep_one, 0);
    PMC *exception = Parrot_ex_build_exception(interp, EXCEPT_error,
            CONTROL_CONTINUE, empty);
    opcode_t * const ret  = expr NEXT();
    opcode_t * const dest = Parrot_ex_throw_from_op(interp, exception, ret);
    goto ADDRESS(dest);
}

=back

=cut

/*
 * Local variables:
 *   c-file-style: "parrot"
 * End:
 * vim: expandtab shiftwidth=4:
 */
