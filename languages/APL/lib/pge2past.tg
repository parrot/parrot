transform result (ROOT) :language('PIR') {
    .local pmc result
    .local pmc children
    .local pmc iter

    result = new 'PAST::Stmts'
    result.'set_node'(node)

    children = new 'APLVector'
    $P0 = node['statement']
    iter = new .Iterator, $P0
    iter = 0
  iter_loop:
    unless iter goto iter_end
    $P1 = shift iter
    $P2 = tree.get('result', $P1, 'APL::Grammar::statement')
    if null $P2 goto iter_loop
    push children, $P2
    goto iter_loop
  iter_end:
    result['children'] = children
    .return(result)
} 
    

transform result (APL::Grammar::statement) :language('PIR') {
    .local pmc result
    result = new 'PAST::Stmt'
    result.'set_node'(node)
    
    $P0 = node['expression']
    $P1 = tree.get('result', $P0, 'APL::Grammar::expression')
    result['statement'] = $P1
    .return (result)
}


transform result (APL::Grammar::expression) :language('PIR') {
    .local pmc result
    .local string op
    .local pmc children

    $I0 = exists node['target']
    if $I0 goto assignment
    $I0 = exists node['dyadic_identifier']
    if $I0 goto dyadic
    $I0 = exists node['monadic_identifier']
    if $I0 goto monadic

  subexpression:
    # A simple subexpression
    $P0 = node['subexpression']
    .return tree.get('result', $P0, 'APL::Grammar::subexpression')

  assignment:
    result = new 'PAST::Assign'
    result.set_node(node)
    $P0 = node['target']
    $P1 = tree.get('result', $P0, 'APL::Grammar::target')
    result['target'] = $P1
    $P0 = node['expression']
    $P1 = tree.get('result', $P0, 'APL::Grammar::expression')
    result['expression'] = $P1
    .return (result)

  dyadic:
    # create a new PAST::Op node
    result = new 'PAST::Op'
    result.set_node(node)

    # set the function name for this operator
    op = node['dyadic_identifier';0]
    op = concat 'dyadic:', op
    result['op'] = op

    # build a 'children' array of our (two) operands   
    children = new 'APLVector'
    $P0 = node['subexpression']
    $P1 = tree.get('result', $P0, 'APL::Grammar::subexpression')
    push children, $P1
    $P0 = node['expression']
    $P0 = $P0[0]
    $P1 = tree.get('result', $P0, 'APL::Grammar::expression')
    push children, $P1
    result['children'] = children
    .return (result)

  monadic:
    # create a new PAST::Op
    result = new 'PAST::Op'
    result.set_node(node)

    # set the function name for this operator
    op = node['monadic_identifier']
    op = op[0]
    op = concat 'monadic:', op
    result['op'] = op

    # build a "children" array of our (one) operand
    children = new 'APLVector'
    $P0 = node['expression']
    $P1 = tree.get('result', $P0, 'APL::Grammar::expression')
    push children, $P1
    result['children'] = children
    .return (result)
}


transform result (APL::Grammar::subexpression) :language('PIR') {
    $P0 = node['simple_expression']
    .return tree.get('result', $P0, 'APL::Grammar::simple_expression')
}


transform result (APL::Grammar::simple_expression) :language('PIR') {
    $I0 = exists node['expression']
    if $I0 goto paren_expression
    $P0 = node['array_identifier']
    .return tree.'get'('result', $P0, 'APL::Grammar::array_identifier')
  paren_expression:
    $P0 = node['expression']
    .return tree.'get'('result', $P0, 'APL::Grammar::expression')
}


transform result (APL::Grammar::target) :language('PIR') {
    $P0 = node['variable_identifier']
    .return tree.get('result', $P0, 'APL::Grammar::variable_identifier')
}


transform result (APL::Grammar::array_identifier) :language('PIR') {
    $P0 = node['constant']
    unless $P0 goto variable_name
    .return tree.get('result', $P0, 'APL::Grammar::constant')

  variable_name:
    $P0 = node['variable_identifier']
    .return tree.get('result', $P0, 'APL::Grammar::variable_identifier')
}


transform result (APL::Grammar::constant) :language('PIR') {
    .local pmc result

    $P0 = node['numeric_constant']
    unless $P0 goto char_single
    .return tree.get('result', $P0, 'APL::Grammar::numeric_constant')

  char_single:
    $P0 = node['character_constant_single']
    unless $P0 goto char_double
    .return tree.get('result', $P0, 'APL::Grammar::character_constant_single')

  char_double:
    $P0 = node['character_constant_double']
    .return tree.get('result', $P0, 'APL::Grammar::character_constant_double')
}


transform result (APL::Grammar::numeric_constant) :language('PIR') {

    $P0 = node['decimal_representation']
    $I0 = elements $P0
    if $I0 > 1 goto vector
    $P0 = $P0[0]
    .return tree.get('result', $P0, 'APL::Grammar::decimal_representation')

  vector:
    .local pmc result
    .local pmc children
    .local pmc iter
    result = new 'PAST::Vector'
    result.set_node(node)

    children = new 'APLVector'
    iter = new .Iterator, $P0
    iter = 0
  iter_loop:
    unless iter goto iter_end
    $P0 = shift iter
    $P1 = tree.get('result', $P0, 'APL::Grammar::decimal_representation')
    if null $P1 goto iter_loop
    push children, $P1
    goto iter_loop
  iter_end:

    result['children'] = children
    .return (result)
}

    
transform result (APL::Grammar::decimal_representation) :language('PIR') {
    .local pmc result
    result = new 'PAST::Val'
    result.set_node(node)
    $S0 = node
    # replace any \u207b chars with "-"
  minus_loop:
    $I0 = index $S0, unicode:"\u207b"
    if $I0 < 0 goto set_value
    substr $S0, $I0, 1, "-"
    goto minus_loop
  set_value:
    $N0 = $S0
    result['value'] = $N0
    result['class'] = '.Float'
    .return (result)
}

transform result (APL::Grammar::character_constant_double) :language('PIR') {
    .local pmc result, iter, children
    result = new 'PAST::Vector'
    result.set_node(node)

    children = new 'APLVector'
    $P0 = node['double_quoted_character'] 

    iter = new .Iterator, $P0
  iter_loop:
    unless iter goto iter_end
    $P1 = shift iter
    $P2 = tree.get('result', $P1, 'APL::Grammar::double_quoted_character')
    if null $P2 goto iter_loop
    push children, $P2
    goto iter_loop 
  iter_end:
    result['children'] = children
    .return (result)
}

transform result (APL::Grammar::character_constant_single) :language('PIR') {
    .local pmc result, iter, children
    result = new 'PAST::Vector'
    result.set_node(node)

    children = new 'APLVector'
    $P0 = node['single_quoted_character'] 

    iter = new .Iterator, $P0
  iter_loop:
    unless iter goto iter_end
    $P1 = shift iter
    $P2 = tree.get('result', $P1, 'APL::Grammar::single_quoted_character')
    if null $P2 goto iter_loop
    push children, $P2
    goto iter_loop 
  iter_end:
    result['children'] = children
    .return (result)
}

transform result (APL::Grammar::single_quoted_character) :language('PIR') {
    .local pmc result
    result = new 'PAST::Val'
    result.set_node(node)
    $S0 = node
    if $S0 != "''" goto done
    $S0 = "'"
done:
    result['value'] = $S0
    result['class'] = '.String'
    .return (result)
}

transform result (APL::Grammar::double_quoted_character) :language('PIR') {
    .local pmc result
    result = new 'PAST::Val'
    result.set_node(node)
    $S0 = node
    if $S0 != '""' goto done
    $S0 = '"'
done:
    result['value'] = $S0
    result['class'] = '.String'
    .return (result)
}

transform result (APL::Grammar::variable_identifier) :language('PIR') {
    .local pmc result
    result = new 'PAST::Var'
    result.set_node(node)
    $S0 = node
    result['name'] = $S0
    .return (result)
}

