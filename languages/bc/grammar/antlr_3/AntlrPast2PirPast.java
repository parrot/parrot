// $ANTLR 3.0ea10 grammar/antlr_3/antlr_past2pir_past.g 2006-06-19 20:24:05

import org.antlr.runtime.*;
import org.antlr.runtime.tree.*;import java.util.Stack;
import java.util.List;
import java.util.ArrayList;

public class AntlrPast2PirPast extends TreeParser {
    public static final String[] tokenNames = new String[] {
        "<invalid>", "<EOR>", "<DOWN>", "<UP>", "PROGRAM", "UNARY_MINUS", "INT", "ML_COMMENT", "WS", "'-'", "'quit'"
    };
    public static final int UNARY_MINUS=5;
    public static final int INT=6;
    public static final int EOF=-1;
    public static final int WS=8;
    public static final int ML_COMMENT=7;
    public static final int PROGRAM=4;
        public AntlrPast2PirPast(TreeNodeStream input) {
            super(input);    }
        

    public String[] getTokenNames() { return tokenNames; }
    public String getGrammarFileName() { return "grammar/antlr_3/antlr_past2pir_past.g"; }


      int reg_num = 0;  // for generation register numbers



    // $ANTLR start gen_pir_past
    // grammar/antlr_3/antlr_past2pir_past.g:19:1: gen_pir_past : ^( PROGRAM ( expr )+ ) ;
    public void gen_pir_past() throws RecognitionException {   
        try {
            // grammar/antlr_3/antlr_past2pir_past.g:21:3: ( ^( PROGRAM ( expr )+ ) )
            // grammar/antlr_3/antlr_past2pir_past.g:21:3: ^( PROGRAM ( expr )+ )
            {

                String pirBefore = "" 
                      + "#!/usr/bin/env parrot" + "\n"
                      + "\n"
                      + "# Do not edit this file." + "\n"
                      + "# This file has been generated by Bc.java." + "\n"
                      + "\n"
                      + ".sub bc :main" + "\n"
                      + "  load_bytecode 'languages/punie/lib/ASTGrammar.pir'" + "\n"
                      + "  load_bytecode 'TGE.pbc'" + "\n"
                      + "  load_bytecode 'PAST.pbc'" + "\n"
                      + "  load_bytecode 'languages/punie/lib/POST.pir'" + "\n"
                      + "  load_bytecode 'languages/punie/lib/OSTGrammar.pir'" + "\n"
                      + "\n"
                      ;

                System.out.println( pirBefore );    
              
            match(input,PROGRAM,FOLLOW_PROGRAM_in_gen_pir_past61); 

            match(input, Token.DOWN, null); 
            // grammar/antlr_3/antlr_past2pir_past.g:39:15: ( expr )+
            int cnt1=0;
            loop1:
            do {
                int alt1=2;
                int LA1_0 = input.LA(1);
                if ( LA1_0==INT ) {
                    alt1=1;
                }


                switch (alt1) {
            	case 1 :
            	    // grammar/antlr_3/antlr_past2pir_past.g:39:15: expr
            	    {
            	    pushFollow(FOLLOW_expr_in_gen_pir_past63);
            	    expr();
            	    _fsp--;


            	    }
            	    break;

            	default :
            	    if ( cnt1 >= 1 ) break loop1;
                        EarlyExitException eee =
                            new EarlyExitException(1, input);
                        throw eee;
                }
                cnt1++;
            } while (true);


            match(input, Token.UP, null); 

                  String pirAfter = "" 
                      + "# entering gen_pir_past" + "\n"
                      + "  .local pmc stmts" + "\n"
                      + "  stmts = new 'PAST::Stmts'" + "\n"
                      + "  stmts.'add_child'( $P50 )" + "\n"
                      + "  stmts.'add_child'( $P100 )" + "\n"
                      + "  stmts.'source'('1')" + "\n"
                      + "  stmts.'pos'(1)" + "\n"
                      + "\n"
                      + "  # Compile the abstract syntax tree down to an opcode syntax tree" + "\n"
                      + "  .local string ost_tg_source" + "\n"
                      + "  ost_tg_source = _slurp_file('languages/punie/lib/OSTGrammar.tg')" + "\n"
                      + "  .local pmc tge_compiler, ost_grammar" + "\n"
                      + "  tge_compiler = new 'TGE::Compiler'" + "\n"
                      + "  ost_grammar = tge_compiler.'compile'(ost_tg_source)" + "\n"
                      + "  .local pmc ost_builder" + "\n"
                      + "  ost_builder = ost_grammar.apply(stmts)" + "\n"
                      + "  .local pmc ost" + "\n"
                      + "  ost = ost_builder.get('result')" + "\n"
                      + "  $I0 = defined ost" + "\n"
                      + "  unless $I0 goto err_no_ost # if OST fails stop" + "\n"
                      + "\n"
                      + "  # Compile the OST down to PIR" + "\n"
                      + "  .local string pir_tg_source" + "\n"
                      + "  pir_tg_source = _slurp_file('languages/punie/lib/PIRGrammar.tg')" + "\n"
                      + "  .local pmc pir_grammar" + "\n"
                      + "  pir_grammar = tge_compiler.'compile'(pir_tg_source)" + "\n"
                      + "  .local pmc pir_builder" + "\n"
                      + "  pir_builder = pir_grammar.apply(ost)" + "\n"
                      + "  .local pmc pir" + "\n"
                      + "  pir = pir_builder.get('result')" + "\n"
                      + "  unless pir goto err_no_pir # if PIR not generated, stop" + "\n"
                      + "\n"
                      + "  # Execute" + "\n"
                      + "  .local pmc pir_compiler" + "\n"
                      + "  .local pmc pir_compiled" + "\n"
                      + "  pir_compiler = compreg \"PIR\"" + "\n"
                      + "  pir_compiled = pir_compiler( pir )" + "\n"
                      + "\n"
                      + "  pir_compiled()" + "\n"
                      + "\n"
                      + "  print \"\\n\"" + "\n"
                      + "\n"
                      + "  end" + "\n"
                      + "\n"
                      + "  err_match_fail:" + "\n"
                      + "    print \"parse failed\\n\"" + "\n"
                      + "    goto cleanup" + "\n"
                      + "\n"
                      + "  err_no_ast:" + "\n"
                      + "    print 'Unable to construct AST.'" + "\n"
                      + "    goto cleanup" + "\n"
                      + "\n"
                      + "  err_no_ost:" + "\n"
                      + "    print 'Unable to construct OST.'" + "\n"
                      + "    goto cleanup" + "\n"
                      + "\n"
                      + "  err_no_pir:" + "\n"
                      + "    print 'Unable to construct PIR.'" + "\n"
                      + "    goto cleanup" + "\n"
                      + "\n"
                      + "  cleanup:" + "\n"
                      + ".end" + "\n"
                      + "\n"
                      + ".sub _slurp_file" + "\n"
                      + "  .param string filename" + "\n"
                      + "  .local pmc filehandle" + "\n"
                      + "  filehandle = open filename, '<'" + "\n"
                      + "  unless filehandle goto err_no_file" + "\n"
                      + "  $S1 = read filehandle, 65535" + "\n"
                      + "  close filehandle" + "\n"
                      + "  .return ($S1)" + "\n"
                      + "  err_no_file:" + "\n"
                      + "    print 'Unable to open file: '" + "\n"
                      + "    print filename" + "\n"
                      + "    end" + "\n"
                      + ".end" + "\n"
                      + "# leaving gen_pir_past" + "\n"
                      ;

                   System.out.print( pirAfter );    
                

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }
        finally {
        }
        return ;
    }
    // $ANTLR end gen_pir_past

    public static class expr_int_1_return extends TreeRuleReturnScope {
    };

    // $ANTLR start expr_int_1
    // grammar/antlr_3/antlr_past2pir_past.g:125:1: expr_int_1 : INT ;
    public expr_int_1_return expr_int_1() throws RecognitionException {   
        expr_int_1_return retval = new expr_int_1_return();
        retval.start = input.LT(1);

        try {
            // grammar/antlr_3/antlr_past2pir_past.g:126:5: ( INT )
            // grammar/antlr_3/antlr_past2pir_past.g:126:5: INT
            {
            match(input,INT,FOLLOW_INT_in_expr_int_185); 

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }
        finally {
            retval.stop = input.LT(-1);

        }
        return retval;
    }
    // $ANTLR end expr_int_1


    // $ANTLR start expr
    // grammar/antlr_3/antlr_past2pir_past.g:130:1: expr returns [String reg] : expr_int_1 ;
    public String expr() throws RecognitionException {   
        String reg;
        expr_int_1_return expr_int_11 = null;



            reg = "reg_expr";
          
        try {
            // grammar/antlr_3/antlr_past2pir_past.g:135:5: ( expr_int_1 )
            // grammar/antlr_3/antlr_past2pir_past.g:135:5: expr_int_1
            {
            pushFollow(FOLLOW_expr_int_1_in_expr112);
            expr_int_11=expr_int_1();
            _fsp--;


                  String pir = "" 
                      + "# entering expr" + "\n"
                      + ".local pmc " + reg + "\n"
                      + reg + " = new 'PAST::Val'" + "\n"
                      + reg + ".value( " + input.toString(expr_int_11.start,expr_int_11.stop) + " )" + "\n"
                      + reg + ".'source'('1')" + "\n"
                      + reg + ".'pos'(0)" + "\n"
                      + reg + ".valtype( 'num' )" + "\n"
                      + "# leaving expr" + "\n"
                      + "               $P20 = new 'PAST::Exp' " + "\n"
                      + "               $P20.'add_child'( " + reg + " )" + "\n"
                      + "               $P20.'source'('1')" + "\n"
                      + "               $P20.'pos'(1)" + "\n"
                      + "       $P30 = new 'PAST::Op' " + "\n"
                      + "       $P30.'add_child'( $P20 )" + "\n"
                      + "       $P30.'op'( 'print' )" + "\n"
                      + "       $P30.'source'('1')" + "\n"
                      + "       $P30.'pos'(1)" + "\n"
                      + "               $P40 = new 'PAST::Exp' " + "\n"
                      + "               $P40.'add_child'( $P30 )" + "\n"
                      + "               $P40.'source'('1')" + "\n"
                      + "               $P40.'pos'(1)" + "\n"
                      + "  $P50 = new 'PAST::Stmt' " + "\n"
                      + "  $P50.'add_child'( $P40 )" + "\n"
                      + "  $P50.'source'('1')" + "\n"
                      + "  $P50.'pos'(1)" + "\n"
                      + "               $P60 = new 'PAST::Val' " + "\n"
                      + "               $P60.value( '\\n' ) " + "\n"
                      + "               $P60.'source'('1')" + "\n"
                      + "               $P60.'pos'(0)" + "\n"
                      + "               $P60.valtype( 'strqq' ) " + "\n"
                      + "               $P70 = new 'PAST::Exp' " + "\n"
                      + "               $P70.'add_child'( $P60 )" + "\n"
                      + "               $P70.'source'('1')" + "\n"
                      + "               $P70.'pos'(1)" + "\n"
                      + "       $P80 = new 'PAST::Op' " + "\n"
                      + "       $P80.'add_child'( $P70 )" + "\n"
                      + "       $P80.'op'( 'print' )" + "\n"
                      + "       $P80.'source'('1')" + "\n"
                      + "       $P80.'pos'(1)" + "\n"
                      + "               $P90 = new 'PAST::Exp' " + "\n"
                      + "               $P90.'add_child'( $P80 )" + "\n"
                      + "               $P90.'source'('1')" + "\n"
                      + "               $P90.'pos'(1)" + "\n"
                      + "  $P100 = new 'PAST::Stmt' " + "\n"
                      + "  $P100.'add_child'( $P90 )" + "\n"
                      + "  $P100.'source'('1')" + "\n"
                      + "  $P100.'pos'(1)" + "\n"
                      + "\n"
                      ;
                  System.out.println( pir );    
                

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }
        finally {
        }
        return reg;
    }
    // $ANTLR end expr





    public static final BitSet FOLLOW_PROGRAM_in_gen_pir_past61 = new BitSet(new long[]{0x0000000000000004L});
    public static final BitSet FOLLOW_expr_in_gen_pir_past63 = new BitSet(new long[]{0x0000000000000048L});
    public static final BitSet FOLLOW_INT_in_expr_int_185 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_expr_int_1_in_expr112 = new BitSet(new long[]{0x0000000000000002L});

}