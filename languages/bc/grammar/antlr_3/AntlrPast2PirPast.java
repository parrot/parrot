// $ANTLR 3.0ea7 grammar/antlr_3/antlr_past2pir_past.g 2006-02-22 22:44:03

import org.antlr.runtime.*;
import org.antlr.runtime.tree.*;import java.util.Stack;
import java.util.List;
import java.util.ArrayList;

public class AntlrPast2PirPast extends TreeParser {
    public static final String[] tokenNames = new String[] {
        "<invalid>", "<EOR>", "<DOWN>", "<UP>", "PROGRAM", "INT", "WS"
    };
    public static final int INT=5;
    public static final int WS=6;
    public static final int PROGRAM=4;
        public AntlrPast2PirPast(TreeNodeStream input) {
            super(input);
        }
        

    public String[] getTokenNames() { return tokenNames; }




    // $ANTLR start gen_pir_past
    // grammar/antlr_3/antlr_past2pir_past.g:20:1: gen_pir_past : ^( PROGRAM ( expr )+ ) ;
    public void gen_pir_past() throws RecognitionException {   



        String expr1 = null;


        try {
            // grammar/antlr_3/antlr_past2pir_past.g:22:3: ( ^( PROGRAM ( expr )+ ) )
            // grammar/antlr_3/antlr_past2pir_past.g:22:3: ^( PROGRAM ( expr )+ )
            {


                String pirBefore = "" 
                      + "#!/usr/bin/env parrot" + "\n"
                      + "\n"
                      + "# Do not edit this file." + "\n"
                      + "# This file has been generated by Bc.java." + "\n"
                      + "\n"
                      + ".sub bc :main" + "\n"
                      + "  load_bytecode 'languages/punie/lib/PAST.pir'" + "\n"
                      + "  load_bytecode 'TGE.pbc'" + "\n"
                      + "  load_bytecode 'languages/punie/lib/POST.pir'" + "\n"
                      + "\n"
                      + "  .local pmc stmts_children" + "\n"
                      + "  stmts_children = new PerlArray" + "\n"
                      ;

                System.out.println( pirBefore );    
              


            match(input,PROGRAM,FOLLOW_PROGRAM_in_gen_pir_past62);

            match(input, Token.DOWN, null);

            // grammar/antlr_3/antlr_past2pir_past.g:40:15: ( expr )+
            int cnt1=0;
            loop1:
            do {
                int alt1=2;
                int LA1_0 = input.LA(1);
                if ( LA1_0==INT ) {
                    alt1=1;
                }


                switch (alt1) {
            	case 1 :
            	    // grammar/antlr_3/antlr_past2pir_past.g:40:15: expr
            	    {

            	    following.push(FOLLOW_expr_in_gen_pir_past64);
            	    expr1=expr();
            	    following.pop();


            	    }
            	    break;

            	default :
            	    if ( cnt1 >= 1 ) break loop1;
                        EarlyExitException eee =
                            new EarlyExitException(1, input);
                        throw eee;
                }
                cnt1++;
            } while (true);


            match(input, Token.UP, null);


                  String pirAfter = "" 
                      + "# entering gen_pir_past" + "\n"
                      + "               $P20 = new 'PAST::Exp' " + "\n"
                      + "               $P21 = new PerlArray " + "\n"
                      + "               push $P21, " + expr1 + " \n"
                      + "               $P20.set_node('1', 1, $P21) " + "\n"
                      + "       $P30 = new 'PAST::Op' " + "\n"
                      + "       $P31 = new PerlArray " + "\n"
                      + "       push $P31, $P20 " + "\n"
                      + "       $P30.set_node('1', 1, 'print' ,$P31) " + "\n"
                      + "               $P40 = new 'PAST::Exp' " + "\n"
                      + "               $P41 = new PerlArray " + "\n"
                      + "               push $P41, $P30 " + "\n"
                      + "               $P40.set_node('1', 1, $P41) " + "\n"
                      + "  $P50 = new 'PAST::Stmt' " + "\n"
                      + "  $P51 = new PerlArray " + "\n"
                      + "  push $P51, $P40 " + "\n"
                      + "  $P50.set_node('1', 1 ,$P51) " + "\n"
                      + "  push stmts_children, $P50 " + "\n"
                      + "               $P60 = new 'PAST::Val' " + "\n"
                      + "               $P60.set_node( '1', 0, '\\n' ) " + "\n"
                      + "               $P60.valtype( 'strqq' ) " + "\n"
                      + "               $P70 = new 'PAST::Exp' " + "\n"
                      + "               $P71 = new PerlArray " + "\n"
                      + "               push $P71, $P60 " + "\n"
                      + "               $P70.set_node('1', 1, $P71) " + "\n"
                      + "       $P80 = new 'PAST::Op' " + "\n"
                      + "       $P81 = new PerlArray " + "\n"
                      + "       push $P81, $P70 " + "\n"
                      + "       $P80.set_node('1', 1, 'print' ,$P81) " + "\n"
                      + "               $P90 = new 'PAST::Exp' " + "\n"
                      + "               $P91 = new PerlArray " + "\n"
                      + "               push $P91, $P80 " + "\n"
                      + "               $P90.set_node('1', 1, $P91) " + "\n"
                      + "  $P100 = new 'PAST::Stmt' " + "\n"
                      + "  $P101 = new PerlArray " + "\n"
                      + "  push $P101, $P90 " + "\n"
                      + "  $P100.set_node('1', 1 ,$P101) " + "\n"
                      + "  push stmts_children, $P100 " + "\n"
                      + "\n"
                      + "  .local pmc stmts" + "\n"
                      + "  stmts = new 'PAST::Stmts'" + "\n"
                      + "  stmts.set_node('1', 1, stmts_children)" + "\n"
                      + "\n"
                      + "  # Compile the abstract syntax tree down to an opcode syntax tree" + "\n"
                      + "  .local string ost_tg_source" + "\n"
                      + "  ost_tg_source = _slurp_file('languages/punie/lib/past2post.g')" + "\n"
                      + "  .local pmc ostgrammar" + "\n"
                      + "  ostgrammar = new 'TGE'" + "\n"
                      + "  ostgrammar.agcompile(ost_tg_source)" + "\n"
                      + "  .local pmc ostbuilder" + "\n"
                      + "  ostbuilder = ostgrammar.apply(stmts)" + "\n"
                      + "  .local pmc ost" + "\n"
                      + "  ost = ostbuilder.get('result')" + "\n"
                      + "  $I0 = defined ost" + "\n"
                      + "  unless $I0 goto err_no_ost # if OST fails stop" + "\n"
                      + "\n"
                      + "  # Compile the OST down to PIR" + "\n"
                      + "  .local string pir_tg_source" + "\n"
                      + "  pir_tg_source = _slurp_file('languages/punie/lib/post2pir.g')" + "\n"
                      + "  .local pmc pirgrammar" + "\n"
                      + "  pirgrammar = new 'TGE'" + "\n"
                      + "  pirgrammar.agcompile(pir_tg_source)" + "\n"
                      + "  .local pmc pirbuilder" + "\n"
                      + "  pirbuilder = pirgrammar.apply(ost)" + "\n"
                      + "  .local pmc pir" + "\n"
                      + "  pir = pirbuilder.get('result')" + "\n"
                      + "  unless pir goto err_no_pir # if PIR not generated, stop" + "\n"
                      + "\n"
                      + "  # Execute" + "\n"
                      + "  .local pmc pir_compiler" + "\n"
                      + "  .local pmc pir_compiled" + "\n"
                      + "  pir_compiler = compreg \"PIR\"" + "\n"
                      + "  pir_compiled = pir_compiler( pir )" + "\n"
                      + "\n"
                      + "  pir_compiled()" + "\n"
                      + "\n"
                      + "  print \"\\n\"" + "\n"
                      + "\n"
                      + "  end" + "\n"
                      + "\n"
                      + "  err_match_fail:" + "\n"
                      + "    print \"parse failed\\n\"" + "\n"
                      + "    goto cleanup" + "\n"
                      + "\n"
                      + "  err_no_ast:" + "\n"
                      + "    print 'Unable to construct AST.'" + "\n"
                      + "    goto cleanup" + "\n"
                      + "\n"
                      + "  err_no_ost:" + "\n"
                      + "    print 'Unable to construct OST.'" + "\n"
                      + "    goto cleanup" + "\n"
                      + "\n"
                      + "  err_no_pir:" + "\n"
                      + "    print 'Unable to construct PIR.'" + "\n"
                      + "    goto cleanup" + "\n"
                      + "\n"
                      + "  cleanup:" + "\n"
                      + ".end" + "\n"
                      + "\n"
                      + ".sub _slurp_file" + "\n"
                      + "  .param string filename" + "\n"
                      + "  .local pmc filehandle" + "\n"
                      + "  filehandle = open filename, '<'" + "\n"
                      + "  unless filehandle goto err_no_file" + "\n"
                      + "  $S1 = read filehandle, 65535" + "\n"
                      + "  close filehandle" + "\n"
                      + "  .return ($S1)" + "\n"
                      + "  err_no_file:" + "\n"
                      + "    print 'Unable to open file: '" + "\n"
                      + "    print filename" + "\n"
                      + "    end" + "\n"
                      + ".end" + "\n"
                      + "# leaving gen_pir_past" + "\n"
                      ;

                   System.out.print( pirAfter );    
                

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }
        finally {


        }

    }
    // $ANTLR end gen_pir_past


    public static class expr_int_1_return extends TreeRuleReturnScope {
    };

    // $ANTLR start expr_int_1
    // grammar/antlr_3/antlr_past2pir_past.g:162:1: expr_int_1 : INT ;
    public expr_int_1_return expr_int_1() throws RecognitionException {   

        expr_int_1_return retval = new expr_int_1_return();
        retval.start = (CommonTree)input.LT(1);



        try {
            // grammar/antlr_3/antlr_past2pir_past.g:163:5: ( INT )
            // grammar/antlr_3/antlr_past2pir_past.g:163:5: INT
            {

            match(input,INT,FOLLOW_INT_in_expr_int_186);

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }
        finally {

            retval.stop = (CommonTree)input.LT(-1);
        }

        return retval;

    }
    // $ANTLR end expr_int_1



    // $ANTLR start expr
    // grammar/antlr_3/antlr_past2pir_past.g:167:1: expr returns [String reg] : expr_int_1 ;
    public String expr() throws RecognitionException {   

        String reg;

        expr_int_1_return expr_int_12 = null;



            reg = "reg_expr";
          
        try {
            // grammar/antlr_3/antlr_past2pir_past.g:172:5: ( expr_int_1 )
            // grammar/antlr_3/antlr_past2pir_past.g:172:5: expr_int_1
            {

            following.push(FOLLOW_expr_int_1_in_expr113);
            expr_int_12=expr_int_1();
            following.pop();



                  String pir = "" 
                      + "# entering expr" + "\n"
                      + ".local pmc " + reg + "\n"
                      + reg + " = new 'PAST::Val'" + "\n"
                      + reg + ".set_node( '1', 0, " + input.toString(expr_int_12.start,expr_int_12.stop) + " )" + "\n"
                      + reg + ".valtype( 'num' )" + "\n"
                      + "# leaving expr" + "\n"
                      ;
                  System.out.println( pir );    
                

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }
        finally {


        }

        return reg;

    }
    // $ANTLR end expr




    public static final BitSet FOLLOW_PROGRAM_in_gen_pir_past62 = new BitSet(new long[]{4L});
    public static final BitSet FOLLOW_expr_in_gen_pir_past64 = new BitSet(new long[]{40L});
    public static final BitSet FOLLOW_INT_in_expr_int_186 = new BitSet(new long[]{2L});
    public static final BitSet FOLLOW_expr_int_1_in_expr113 = new BitSet(new long[]{2L});

}