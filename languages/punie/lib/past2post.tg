ROOT: result(.) = {
    .local pmc result
    result = new 'POST::Sub'
    result.'clone_node'(node)

    $P1 = node.children()
    .local pmc iter
    iter = new Iterator, $P1    # setup iterator for node
    iter = 0
  iter_loop:
    unless iter, iter_end         # while (entries) ...
      shift $P2, iter
      $P3 = tree.get('result', $P2)
      result.'add_child'($P3)
      goto iter_loop
  iter_end:

    .return (result)
}

PAST::Stmts: result(.) = {
    .local pmc result
    result = new 'POST::Ops'
    result.'clone_node'(node)

    $P1 = node.children()
    .local pmc iter
    iter = new Iterator, $P1    # setup iterator for node
    iter = 0
  iter_loop:
    unless iter, iter_end         # while (entries) ...
      shift $P2, iter
      $P3 = tree.get('result', $P2)
      result.'add_child'($P3)
      goto iter_loop
  iter_end:
    .return (result)
}

PAST::Stmt: result(.) = {
    $P1 = node.children()
    $P2 = $P1[0]
    $P3 = tree.get('result', $P2)
    .return ($P3)
}

PAST::Exp: result(.) = {
    $P1 = node.children()
    $P2 = $P1[0]
    $P3 = tree.get('result', $P2)
    .return ($P3)
}

PAST::Op: result(.) = {
     .local string opname
     opname = node.op()
    $S1 = substr opname, 0, 5
    if $S1 == 'infix' goto infix
    goto not_infix
  infix:
      $P4 = tree.get('infix', node)
      .return ($P4)
  not_infix:
    if opname == 'print' goto print_op
    goto not_print_op
  print_op:
      $P4 = tree.get('print_op', node)
      .return ($P4)
  not_print_op:
    if opname == 'if' goto conditional
    if opname == 'unless' goto conditional
    if opname == 'elsif' goto conditional
    goto not_conditional
  conditional:
      $P4 = tree.get('conditional', node)
      .return ($P4)
  not_conditional:
    if opname == 'else' goto nullop
    goto not_nullop
  nullop:
      $P4 = tree.get('nullop', node)
      .return ($P4)
  not_nullop:
    # Iterate through the children of the node, and generate the result
    # for each child.
    .local pmc childop
    childop = new 'POST::Op'
    childop.'clone_node'(node)
    $S2 = node.op()
    childop.op($S2)

    # Create a node to contain the generated ops.
    .local pmc newops
    newops = new 'POST::Ops'
    $P1 = node.children()
    .local pmc iter
    iter = new Iterator, $P1    # setup iterator for node
    iter = 0
  iter_loop:
    unless iter, iter_end         # while (entries) ...
      shift $P2, iter
      $P3 = tree.get('result', $P2)
      $S1 = typeof $P3
      # Does the argument have setup code?
      unless $S1 == 'POST::Ops' goto simple_result
        $P1 = $P3.tmpvar()
      if null $P1 goto simple_result
        childop.'add_child'($P1)
        newops.'add_child'($P3)
        goto iter_loop
      simple_result:
        childop.'add_child'($P3)
      goto iter_loop
  iter_end:

    # In the context of an Op node, collapse a child comma op, so the
    # child's children become the children of the current node.
#    $I0 = elements newchildren
#    if $I0 > 1 goto no_munge
#      $P5 = newchildren[0]
#      $S3 = typeof $P5
#    unless $S3 == 'POST::Op' goto no_munge
#      $S4 = $P5.op()
#    unless $S4 == 'O_COMMA' goto no_munge
#      newchildren = $P5.children()

  no_munge:
    
    # Check if we had setup code for one of the children. If so, bundle
    # it up in an Ops node.
    $I0 = elements newops
    if $I0 > 0 goto bundle_ops
      .return (childop)
  bundle_ops:
    newops.'add_child'(childop)

    .return (newops)
}

PAST::Op: infix(.) = {
    # Create the node to contain all the generated ops.
    .local pmc newops
    newops = new 'POST::Ops'
    newops.'clone_node'(node)

    # Create the op for the current node
    .local pmc childop
    childop = new 'POST::Op'

    .local string opname
    .local pmc oplookup
    oplookup = find_global 'PunieOpLookup', 'lookup'
    $S1 = node.op()
    opname = oplookup($S1)
    childop.'op'(opname)

    # Create a temporary variable
    .local pmc temp_var
    temp_var = new 'POST::Var'
    temp_var.'clone_node'(node)
    $P8 = temp_var.new_dummy()
    newops.'add_child'($P8)

    # Add the temporary variable as the destination register of the op
    childop.'add_child'(temp_var)

    $P1 = node.children()
    .local pmc iter
    iter = new Iterator, $P1    # setup iterator for node
    iter = 0
  iter_loop:
    unless iter, iter_end         # while (entries) ...
      shift $P2, iter
      $P3 = tree.get('result', $P2)
      $S1 = typeof $P3
      if $S1 == 'POST::Ops' goto complex_result # the argument has setup
      if $S1 == 'POST::Val' goto create_tmp # the argument needs setup
        childop.'add_child'($P3)
        goto iter_loop
      create_tmp:
        # Create a temp variable
        $P4 = new 'POST::Var'
        $P4.'clone_node'(node)
        $P5 = $P4.new_dummy()
        newops.'add_child'($P5)
        childop.'add_child'($P4)
        # Assign the value node to the variable
        $P7 = new 'POST::Op'
        $P7.'clone_node'(node)
        $P7.'op'('set')
        $P7.'add_child'($P4) # the first argument is the variable
        $P7.'add_child'($P3) # the second argument is the value
        newops.'add_child'($P7)
        goto iter_loop
      complex_result:
        $P1 = $P3.tmpvar()
        childop.'add_child'($P1)
        newops.'add_child'($P3)
      goto iter_loop
  iter_end:

    # The childop goes after all the setup code.
    newops.'add_child'(childop)

    newops.'tmpvar'(temp_var)

    .return (newops)
}

PAST::Op: conditional(.) = {
    # Create the node to contain all the generated ops.
    .local pmc newops
    newops = new 'POST::Ops'

    .local string opname
    .local pmc oplookup
    oplookup = find_global 'PunieOpLookup', 'lookup'
    $S1 = node.op()
    opname = oplookup($S1)
    .local pmc childop
    childop = new 'POST::Op'
    childop.'clone_node'(node)
    childop.'op'(opname)

    # Set up to handle children of Op node.
    $P1 = node.children()
    .local pmc iter
    iter = new Iterator, $P1    # setup iterator for node
    iter = 0

    # First, handle the condition, which may be a series of statements
    # resulting in a single value.
    shift $P2, iter
    $P3 = tree.get('result', $P2)
    $S1 = typeof $P3
    if $S1 == 'POST::Ops' goto complex_result # the argument has setup
      childop.'add_child'($P3)
      goto end_condition
    complex_result:
      $P1 = $P3.'tmpvar'()
      childop.'add_child'($P1)
      newops.'add_child'($P3)
  end_condition:

    # Second, create the branching op. The first child is the result of
    # the condition, the second argument is a label.
    .local pmc falselabel
    falselabel = new 'POST::Label'
    falselabel.'new_dummy'('false')
    childop.'add_child'(falselabel)

    newops.'add_child'(childop)

    # Next handle the conditional body
    shift $P2, iter
    $P3 = tree.'get'('result', $P2)
    newops.'add_child'($P3)

    # When conditional body is selected, skip over any else/elsif
    .local pmc endlabel
    endlabel = new 'POST::Label'
    endlabel.'new_dummy'('endcond')
    $P4 = new 'POST::Op'
    $P4.'clone_node'(node)
    $P4.'op'('goto')
    $P4.'add_child'(endlabel)
    newops.'add_child'($P4)

    # Destination for the branching op
    $P6 = clone falselabel
    $P6.dest(1)
    newops.'add_child'($P6)

    # Finally handle the else/elsif block if it exists
    unless iter goto no_else_elsif
    shift $P2, iter
    $P3 = tree.'get'('result', $P2)
    newops.'add_child'($P3)
  no_else_elsif:

    # Destination for the end of the conditional
    $P6 = clone endlabel
    $P6.dest(1)
    newops.'add_child'($P6)

    .return (newops)
}

PAST::Op: nullop(.) = {
    $P1 = node.children()
    $P2 = $P1[0]
    $P3 = tree.get('result', $P2)
    .return ($P3)
}

PAST::Op: print_op(.) = {
    # This fairly lengthy bit collapses comma ops, by traversing down
    # the tree and yanking up the children of the comma op to the
    # current level.
    $P1 = node.children()
    $I0 = elements node 
    if $I0 > 1 goto no_munge
      $P2 = $P1[0]
      $S3 = typeof $P2
    unless $S3 == 'PAST::Exp' goto no_munge
      $P3 = $P2.children()
      $P4 = $P3[0]
      $S3 = typeof $P4
    unless $S3 == 'PAST::Op' goto no_munge
      $S4 = $P4.op()
    unless $S4 == 'O_COMMA' goto no_munge
      $P1 = $P4.children()
  no_munge:
     # Done collapsing comma ops

    # Create a node to contain the generated ops.
    .local pmc newops
    newops = new 'POST::Ops'
    newops.'clone_node'(node)

    # Store the opname for later reuse
    .local string opname
    opname = node.op()

    # Iterate through the children of the node, and generate the result
    # for each child.
    .local pmc iter
    iter = new Iterator, $P1    # setup iterator for node
    iter = 0
  iter_loop:
    unless iter, iter_end         # while (entries) ...
      shift $P2, iter
      $P3 = tree.get('result', $P2)
      $S1 = typeof $P3
      $P5 = new 'POST::Op'
      $P5.'clone_node'(node)
      $P5.'op'(opname)
      $S1 = typeof $P3
      if $S1 == 'POST::Ops' goto complex_result # the argument has setup
	# The default case, create a new 'print' op node with the child
	# as an argument and push it on the list of new ops.
        $P5.'add_child'($P3)
        newops.'add_child'($P5)
        goto iter_loop
      complex_result:
	# The complex case, retrieve the temp variable from the Ops
	# node, and push the Ops node on the list of new ops. Then
	# create a new 'print' op node with the temp variable as an
	# argument and push it on the list of new ops.
        $P1 = $P3.tmpvar()
        newops.'add_child'($P3)
        $P5.'add_child'($P1)
        newops.'add_child'($P5)
      goto iter_loop
  iter_end:

    .return (newops)
}

PAST::Val: result(.) = {
    .local pmc result
    result = new 'POST::Val'
    result.'clone_node'(node)
    $P1 = node.'value'()
    result.'value'($P1)
    $P2 = node.'valtype'()
    result.'valtype'($P2)
    .return (result)
}
