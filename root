{"version":1,"ops":[{"type":1,"author":{"id":"86141a663c2eb7543d1a51ec6253a1d54de912fd"},"timestamp":1353512799,"metadata":{"github-id":"MDU6SXNzdWU4NTQ4MDAz","github-url":"https://github.com/parrot/parrot/issues/869","origin":"github"},"title":"threads: crash in nqp with proxy NQPLexPad","message":"Crash in nqp with wrong Parrot_NQPLexPad_set_pointer info-\u003evtable-\u003ebase_type 78 enum_class_Proxy\nThis is probably a nqp bug but still marked here as potential blocker for the threads branch.\nwhiteknight argued to merge threads into parrot, and to fix the remaining nqp issues later.\n\nnqp needs to get the real lexpad from the other thread, not the Proxy .\nThis can be a can of worms. Does nqp need to check all pmc's for proxies, \ni.e. when they were created in another thread?\n\nAlso, all 6model related nqp ops expect a SixModelObject PMC and not a proxy, \nwhich will need to access the PARROT_PROXY(self)-\u003etarget instead.\n\nAfter \n    --- a/src/pmc/nqplexpad.pmc\n    +++ b/src/pmc/nqplexpad.pmc\n    @@ -111,6 +111,8 @@ Return the LexInfo PMC, if any or a Null PMC.\n             if (info-\u003evtable-\u003ebase_type != enum_class_LexInfo) {\n                 PMC *name_map;\n                 GETATTR_NQPLexInfo_name_to_register_map(INTERP, info, name_map);\n    +           if (info-\u003evtable-\u003ebase_type != 97)\n    +printf(\"Parrot_NQPLexPad_set_pointer info-\u003evtable-\u003ebase_type %d\\n\",info-\u003evtable-\u003ebase_type);\n                 hash = (Hash *)VTABLE_get_pointer(INTERP, name_map);\n             }\n             else {\n\nWe get with threads-crash.nqp:\n\n```\nsay(\"alive\");\n\nmy $x := 5;\n\nmy $a := sub foo() {\n    say($x);\n    say(5);\n}\n\nmy $b := pir::new__PSP('Task', $a);\npir::schedule__0P($b);\npir::wait__0P($b);\n\nsay(7);\n```\n\n$ ./nqp threads-crash.nqp\nalive\nParrot_NQPLexPad_set_pointer info-\u003evtable-\u003ebase_type 78 i.e. enum_class_Proxy\nSEGV","files":null}]}