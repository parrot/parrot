{"version":1,"ops":[{"type":1,"author":{"id":"8c86ede03c8e80b0dad5131138f96e957a4ee66b"},"timestamp":1383419596,"metadata":{"github-id":"MDU6SXNzdWUyMjAwNzU1NQ==","github-url":"https://github.com/parrot/parrot/issues/1025","origin":"github"},"title":"I/O handle fake methods on ParrotInterpreter","message":"Reported by: zefram@fysh.org\n\nThe methods \"stdin_handle\", \"stdout_handle\", and \"stderr_handle\" on ParrotInterpreter operate on the currently running interpreter, not on the interpreter represented by the invocant. Example:\n\n```\n$ cat t58.pir\n.sub foo\n        $P0 = get_global \"maininterp\"\n        $P2 = $P0.\"stdout_handle\"()\n        $P1 = $P0.\"stderr_handle\"()\n        $P0.\"stdout_handle\"($P1)\n        print $P2, \"A\\n\"\n        .return ()\n.end\n.sub main :main\n        $P0 = getinterp\n        set_global \"maininterp\", $P0\n        .const \"Sub\" foo = \"foo\"\n        $P1 = new \"Task\", foo\n        schedule $P1\n        sleep 0.1\n        say \"B\"\n.end\n```\n\n```\n$ ./parrot t58.pir  2\u003e/dev/null\nA\nB\n```\n\nThe \"B\" should have gone to stderr, and thus to /dev/null.\n\nWhat I said in previous bug report about the \"recursion_limit\" method applies here too: reading and writing the standard I/O handles of the currently running interpreter are perfectly reasonable operations to support, but they should be presented as opcodes or as standalone subroutines. It is highly misleading to present them as methods on some invocant object that is unrelated to the operation. On the other hand, if there are to be these methods on interpreter objects, they should operate on the interpreter represented by their invocant. (It's also fine to have both types of interface, as long as each is individually in a sensible form.)\n\n-zefram\n\n```\nSummary of my parrot 5.7.0 configuration:\n  configdate='Sat Oct  5 12:42:43 2013 GMT'\n  Platform:\n    osname=linux, archname=x86_64-linux-gnu-thread-multi\n    perl=/usr/bin/perl\n```","files":null}]}