{"version":1,"ops":[{"type":1,"author":{"id":"8c86ede03c8e80b0dad5131138f96e957a4ee66b"},"timestamp":1380989341,"metadata":{"github-id":"MDU6SXNzdWUyMDU2NjY4NQ==","github-url":"https://github.com/parrot/parrot/issues/1003","origin":"github"},"title":"Class names do not obey namespacing","message":"Reported by: zefram@fysh.org\n\nWhere classes are given a name, that name is required to be unique among classes. This is not documented. As the class's method namespace is stored in the currently-selected dynamic namespace under the class name, the impression is given that the class name is relative to the currently-selected dynamic namespace.\n\nActually, there's effectively a separate \"class namespace\", in which classes are referred to by their unqualified names. The class namespace is not directly visible, but the get_class opcode performs lookups in it. Example of clashing unqualified names that seem like they shouldn't be a problem:\n\n```\n$ cat t36.pir \n.namespace [\"yy\"]\n.sub \"\" :init :load\n       $P0 = newclass \"Foo\"\n       say $P0\n       set_global \"Foo-class\", $P0\n.end\n.namespace [\"zz\"]\n.sub \"\" :init :load\n       $P0 = newclass \"Foo\"\n       say $P0\n       set_global \"Foo-class\", $P0\n.end\n.namespace []\n.sub main :main\n       $P0 = get_global [\"yy\"], \"Foo-class\"\n       say $P0\n       $P1 = get_global [\"zz\"], \"Foo-class\"\n       say $P1\n.end\n```\n\n```\n$ ./parrot t36.pir \nFoo\nClass Foo already registered!\n\ncurrent instr.: 'parrot;zz;' pc 11 (t36.pir:9)\n```\n\nIt's not inherently wrong to have a separate class namespace, but in this form it's seriously unhelpful, and it's totally unnecessary. The characteristics of the namespace, especially it being not directly visible, make it act quite contrary to naming in the rest of Parrot.\n\nThe regular dynamic namespace system is entirely adequate for the task of looking up classes by name, provided that one stores the class metaobjects there. (Currently classes' method namespaces are stored in the dynamic namespace, which is an abstraction inversion as discussed elsewhere. Storing the class metaobjects there instead would be more logical.) Using the regular namespace would naturally make name qualification work for class names.\n\nIf there is to be a separate class namespace, there are better ways to go about it. Firstly, it needs to be clearly documented. If the mechanism remains as it is, the documentation needs to contain a bunch of caveats about the problems with using the namespace: you can't delete or overwrite entries; everyone uses the same namespace with no name qualification, so clashes will happen a lot; it will prevent GC of a class that you don't reference any more. In fact, the documentation ought to sum this up with a prominent notice to the effect of \"you probably don't want to give your classes names in this namespace\". Once you've reached that conclusion, there doesn't seem to be any value in having this mechanism at all.\n\nIf you want to make the class namespace more useful, you need to add name qualification, reification, the possibility of deleting entries, and so on. In short, you need to make it just like the regular dynamic namespace. But once you've done that, there's no point keeping an identical parallel system. You might as well just use the regular namespace.\n\n-zefram\n\n```\nSummary of my parrot 5.5.0 configuration:\n configdate='Sun Sep 22 18:01:32 2013 GMT'\n Platform:\n   osname=linux, archname=x86_64-linux-gnu-thread-multi\n   perl=/usr/bin/perl\n```","files":null}]}