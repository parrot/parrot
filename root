{"version":1,"ops":[{"type":1,"author":{"id":"bca615f854f7ca1044265d74ef4974a08d695fb1"},"timestamp":1302151848,"metadata":{"github-id":"MDU6SXNzdWUyODQ4NDU5","github-url":"https://github.com/parrot/parrot/issues/262","origin":"github"},"title":"Register allocator and lexicals bug","message":"Code:\n\n```\n.sub ''\n$P42 = new ['Integer']\n.lex 'i', $P42\n$P69 = new ['Integer']\n.lex 'j', $P69\n.lex 'foo', $P10\n.lex 'bar', $P11\n.lex 'baz', $P12\n$P3 = new ['String']\n.lex 'k', $P3\n\n$P100 = new ['String']\n$P100 = \"oh no\"\nstore_lex 'foo', $P100\n$P101 = find_lex 'bar'\nsay $P101\n.end\n```\n\nShould be a null PMC access, but prints \"oh no\". It looks like\n\n```\n.lex 'foo', $P0\n```\n\nisn't considered an instruction, but just saying \"this lexical goes in this register\". If that's the only mention of $P0, then there's no \"first instruction\". It builds a du-chain, then based on that throws away $P0 from the \"needs allocation\" list because it confuses it with an unused register (e.g. it thinks it got optimized out, which is not the case at all here).\n\nThis patch makes the issue go away:\n\n```\ndiff --git a/compilers/imcc/reg_alloc.c b/compilers/imcc/reg_alloc.c\nindex de0f3e0..300216d 100644\n--- a/compilers/imcc/reg_alloc.c\n+++ b/compilers/imcc/reg_alloc.c\n@@ -391,6 +391,9 @@ reg_sort_f(ARGIN(const void *a), ARGIN(const void *b))\n     const SymReg * const ra = *(const SymReg * const *)a;\n     const SymReg * const rb = *(const SymReg * const *)b;\n\n+    if (!ra-\u003efirst_ins || !rb-\u003efirst_ins)\n+        return 0;\n+    \n     if (ra-\u003efirst_ins-\u003eindex \u003c rb-\u003efirst_ins-\u003eindex)\n         return -1;\n\n@@ -473,7 +476,7 @@ build_reglist(PARROT_INTERP, ARGMOD(IMC_Unit *unit))\n\n     /* we might have unused symbols here, from optimizations */\n     for (i = count = unused = 0; i \u003c n_symbols; i++) {\n-        if (!unit-\u003ereglist[i]-\u003efirst_ins)\n+        if (!unit-\u003ereglist[i]-\u003efirst_ins \u0026\u0026 !(unit-\u003ereglist[i]-\u003eusage \u0026 U_LEXICAL))\n             unused++;\n         else if (i == count)\n             count++;\n@@ -716,7 +719,7 @@ vanilla_reg_alloc(PARROT_INTERP, ARGMOD(IMC_Unit *unit))\n         SymReg *r;\n         for (r = hsh-\u003edata[i]; r; r = r-\u003enext) {\n             /* TODO Ignore non-volatiles */\n-            if (REG_NEEDS_ALLOC(r) \u0026\u0026 r-\u003euse_count)\n+            if (REG_NEEDS_ALLOC(r))\n                 r-\u003ecolor = -1;\n         }\n     }\n@@ -732,7 +735,7 @@ vanilla_reg_alloc(PARROT_INTERP, ARGMOD(IMC_Unit *unit))\n             for (r = hsh-\u003edata[i]; r; r = r-\u003enext) {\n                 if (r-\u003eset != reg_set)\n                     continue;\n-                if (REG_NEEDS_ALLOC(r) \u0026\u0026 (r-\u003ecolor == -1) \u0026\u0026 r-\u003euse_count) {\n+                if (REG_NEEDS_ALLOC(r) \u0026\u0026 (r-\u003ecolor == -1)) {\n                     if (set_contains(avail, first_reg))\n                         first_reg = first_avail(interp, unit, reg_set, NULL);\n\n```\n\nBut it's kinda hacky. OTOH, so is the register allocator as a whole, and this is blocking me on NQP, so provided we can be sure we don't make the quicksort of symbols to allocate unstable I'd be OK with something like this going in. Will leave it until tomorrow to see if anyone has any better ideas.\n\nOriginally http://trac.parrot.org/parrot/ticket/2087","files":null}]}