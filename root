{"version":1,"ops":[{"type":1,"author":{"id":"8c86ede03c8e80b0dad5131138f96e957a4ee66b"},"timestamp":1380771794,"metadata":{"github-id":"MDU6SXNzdWUyMDQzNTg3Mw==","github-url":"https://github.com/parrot/parrot/issues/991","origin":"github"},"title":"Recursion limit is a bad default","message":"Reported by: zefram@fysh.org\n\nBy default, Parrot imposes an arbitrary limit on recursion, of 1000 nested calls. The limit is changeable: it can be set via the \"recursion_limit\" method on the interpreter object obtained from getinterp, and setting it to -1 effectively removes the limit entirely. I think having a reachable limit by default is a bad idea. The limit means that whether code works depends not just on its intrinsic characteristics but also on the nesting depth from which it is called.\n\nFor example:\n\n```\n$ cat t27.pir\n.sub foo\n        .param int i\n        if i == 0 goto done\n        $I0 = i - 1\n        $S0 = foo($I0)\n        .return($S0)\n        done:\n        .return(\"ok\")\n.end\n.sub bar\n        .tailcall foo(997)\n.end\n.sub baz\n        $S0 = bar()\n        say $S0\n.end\n.sub main :main\n        $S0 = bar()\n        say $S0\n        baz()\n.end\n$ ./parrot t27.pir\nok\nmaximum recursion depth exceeded\ncurrent instr.: 'foo' pc 0 (t27.pir:1)\ncalled from Sub 'foo' pc 19 (t27.pir:5)\n... call repeated 996 times\ncalled from Sub 'baz' pc 45 (t27.pir:14)\ncalled from Sub 'main' pc 72 (t27.pir:20)\n```\n\n(Never mind that foo could use tailcalling or just return \"ok\" immediately: it's standing in for any complex code that would actually require recursion.) The first time bar() is called, from main, it succeeds. The second time, when it's called from baz, it fails. The two calls to bar() look identical. One would expect that, if the call from main works, then it would still work if it's placed in a subroutine (baz) that is called from main. This is a very basic kind of transformation of a program, that we rely on all the time, and the recursion limit means that it doesn't work in the general case.\n\nIf you expect Parrot code to normally run with this limit in place, then a lot of documentation needs to change to reflect it. For example, the invokecc op is documented as:\n\n\u003e Call the subroutine in $1 and generate a new return continuation,\n\u003e if needed.\n\nwith the recursion limit, it should be documented as:\n\n\u003e If the current call context is nested less than 999 levels from\n\u003e the top level then call the subroutine in $1, generating a new\n\u003e return continuation if needed.    Otherwise generate an exception.\n\nBut, worse, every subroutine that runs on Parrot needs documentation of the form:\n\n\u003e =item munge_frobnitz()\n\u003e \n\u003e If called from a context that is nested less than 987 levels from\n\u003e the top level then munge the frobnitz, returning the number of\n\u003e flanges that were frobbed.  Otherwise generate an exception.\n\nand an internal implementation detail (the number of call nesting levels used internally) leaks out all over the place. This is a maintenance nightmare.\n\nIf you're _not_ expecting Parrot code to normally run with this limit in place, but the default is to have the limit, then every top-level program is effectively expected to contain the boilerplate to switch the limit off. It's only two lines of boilerplate, not an appalling imposition on the programmers who are paying attention. But inevitably the vast majority of programs won't get the boilerplate inserted, and will thus break functions that relied on the top level doing this job.\n\nSomeone's going to say \"but it's just like the fact that you can unpredictably run out of memory\". It's not like that: this is a small and arbitrary limit that affects programs that are in no danger of exhausting memory. Adding more memory to the system doesn't change the recursion limit.\n\nNor is the limit a systematic attempt to catch runaway programs before they exhaust memory. You're free to consume as much memory as you like as long as you do it iteratively, or via tailcalling, or if you disguise your recursion as tailcalling by using explicit continuation passing. The recursion limit seems to be just... training wheels, to prevent n00bs getting themselves confused by this newfangled recursion trickery.\n\nAs having a recursion limit breaks ordinary function composition semantics, I think the training wheels shouldn't be in place by default. I have no objection to the training wheels being a non-default option. It's being semantically broken _by default_ that's the problem.\n\n-zefram\n\n```\nSummary of my parrot 5.5.0 configuration:\n  configdate='Sun Sep 22 18:01:32 2013 GMT'\n  Platform:\n    osname=linux, archname=x86_64-linux-gnu-thread-multi\n```","files":null}]}