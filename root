{"version":1,"ops":[{"type":1,"author":{"id":"e6ebaecce565c58b3e91ddb32c09e93c5f646822"},"timestamp":1328039341,"metadata":{"github-id":"MDU6SXNzdWUzMDQxNDY5","github-url":"https://github.com/parrot/parrot/issues/711","origin":"github"},"title":"Look at FORTIFY_SOURCE in GCC","message":"From http://gcc.gnu.org/ml/gcc-patches/2004-09/msg02055.html\n\n```\nThe attached patch (which relies on\nhttp://gcc.gnu.org/ml/gcc-patches/2004-09/msg01993.html\n) provides a lightweight buffer overflow protection to\nsome memory and string functions.\nI'm well aware of mudflap, but it has too big runtime overhead\nto be used by all programs.  The intent of this patch\nis to add some checks that have no or non-measurable\nruntime overhead, so something that can be enabled for\nall programs and libraries in an operating system.\nThe patch certainly doesn't prevent all buffer overflows,\nbut should prevent many common ones.\nIt works by computing a constant (conservative) number\nof bytes remaining to the end of object(s) each destination\npointer passed to memory and string functions, if possible\nchecking for overflows at compile time, if not possible\npassing that constant size to special checking alternatives\nof the memory/string functions.\n\nhttp://people.redhat.com/jakub/glibc-chk.patch\ncontains the glibc counterpart to this patch, although\nit doesn't have to be glibc/Linux specific at all.\nOne could easily take bits/string3.h and part of bits/stdio2.h\nfrom the above patch, rename to \u003cstring.h\u003e resp. \u003cstdio.h\u003e,\n#include_next \u003cstring.h\u003e/\u003cstdio.h\u003e in these headers and\ncreate a library containing the checking functions.\n\nThe intended use in glibc is that by default no protection is\ndone, when the above GCC 4.0+ and -D_FORTIFY_SOURCE=1 is used\nat optimization level 1 and above, security measures that\nshouldn't change behaviour of conforming programs are taken.\nWith -D_FORTIFY_SOURCE=2 some more checking is added, but\nsome conforming programs might fail.\n\nBuffer overflows can be detected at compile time\nor at runtime, if the compiler can detect they will not\nhappen, normal functions as opposed to their checking\nalternatives are used.\n\nBelow are four different cases that can happen:\n\nchar buf[5];\n/* 1) Known correct.\n      No runtime checking is needed, memcpy/strcpy\n      functions are called (or their equivalents inline).  */\nmemcpy (buf, foo, 5);\nstrcpy (buf, \"abcd\");\n/* 2) Not known if correct, but checkable at runtime.\n      The compiler knows the number of bytes remaining in object,\n      but doesn't know the length of the actual copy that will happen.\n      Alternative functions __memcpy_chk or __strcpy_chk are used in\n      this case that check whether buffer overflow happened.  If buffer\n      overflow is detected, __chk_fail () is called (the normal action\n      is to abort () the application, perhaps by writing some message\n      to stderr.  */\nmemcpy (buf, foo, n);\nstrcpy (buf, bar);\n/* 3) Known incorrect.\n      The compiler can detect buffer overflows at compile\n      time.  It issues warnings and calls the checking alternatives\n      at runtime.  */\nmemcpy (buf, foo, 6);\nstrcpy (buf, \"abcde\");\n/* 4) Not known if correct, not checkable at runtime.\n      The compiler doesn't know the buffer size, no checking\n      is done.  Overflows will go undetected in these cases.  */\nmemcpy (p, q, n);\nstrcpy (p, q);\n\nIn the current implementation mem{cpy,pcpy,move,set},\nst{r,p,nc}py, str{,n}cat, {,v}s{,n}printf and gets functions\nare checked this way.\n\nThe diffence between -D_FORTIFY_SOURCE=1 and -D_FORTIFY_SOURCE=2\nis e.g. for\nstruct S { struct T { char buf[5]; int x; } t; char buf[20]; } var;\nWith -D_FORTIFY_SOURCE=1,\nstrcpy (\u0026var.t.buf[1], \"abcdefg\");\nis not considered an overflow (object is whole VAR), while\nwith -D_FORTIFY_SOURCE=2\nstrcpy (\u0026var.t.buf[1], \"abcdefg\");\nwill be considered a buffer overflow.\n\nAnother difference is that with -D_FORTIFY_SOURCE=2, %n\nin format strings of the most common *printf family functions\nis allowed only if it is stored in read-only memory (usually\nstring literals, gettext's _(\"%s string %n\") is fine too), but\nusually when an attacker attempts to exploit a format string\nvulnerability, %n will be somewhere where the attacker could\nwrite it into.\n\nNow about how is this implemented in GCC.\nThe patch introduces a\nsize_t __builtin_object_size (ptr, subobject_p)\nbuiltin which computes the number of remaining bytes from PTR\ntill the end of the object PTR is pointing to.\nIf there are multiple objects PTR can point to, this builtin\nreturns maximum number of remaining bytes for them if all\nthe objects are known at compile time.  If it is unknown\nwhat PTR points to, this builtin returns (size_t) -1.\nSUBOBJECT_P is a boolean, 0 if whole objects are considered\nto be the objects for the remaining bytes computations, if\nit is 1, it means the innermost structure field or array\nis considered to be the object.\n\nThe largest part of the patch is addition of many __*_chk builtins,\nchecking alternatives to normal string and memory operations.\nThese builtins are optimized into normal string/memory operations\nif compiler can prove there will be no buffer overflow or if\nthe number of remaining bytes destination pointer points to is\nunknown.  The builtins issue a warning (some people say these\nshould be errors) if at compile time the compiler can prove\nthere will be buffer overflow if the function is called.\nOtherwise the builtins expand to calls to the __*_chk functions,\nwith a constant object size argument.\n\nFor routines like mem{cpy,pcpy,move,set},strncpy etc. the runtime\noverhead of the checking functions is just a few ticks (comparison\nof two arguments, non-predicted branch to __chk_fail function),\nfor strcpy/stpcpy/strcat/strncat the runtime overhead is slightly\nbigger, but as long as they are coded in assembly like the normal\nroutines, it shouldn't be that big.  All functions in the glibc\nimplementation check for overflows before they happen, but it would\nbe possible to only detect they happened and make e.g. __strcpy_chk\nfaster.\n\nOk, actually the largest part of the patch is testsuite, there is\n160k of tests for the added builtins.\n\nArjan van de Ven built some packages from Fedora Core 3 test 2\ndistribution with GCC that included this patch, glibc with the patch\nmentioned above and -D_FORTIFY_SOURCE=1 and it detected several\nbuffer overflows at compile time, including e.g.\n\nchar *devstr, dest;\nstrncpy(\u0026dest, (optarg + 1), 3);\n\nstruct XXXX *rule;\nif (!(rule = malloc(sizeof(rule)))) return NULL;\nmemset(rule, 0, sizeof(*rule));\n\ntypedef struct {\nchar hash[16];\nHASH;\nconst char *XXXX(const HASH hash) {\nunsigned int i;\nmemcpy(\u0026i, \u0026hash, sizeof(hash));\n\nXXX *sheets[3];\nmemset (sheets, 0, sizeof (XXX) * 3);\n\n#define strmov(A,B) stpcpy((A),(B))\nstruct XXXX {\nchar id[8];\nchar nr[4];\nchar text[10];\n} YYYY;\nstrmov(YYYY.text,\"Testing...\");\n```","files":null}]}