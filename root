{"version":1,"ops":[{"type":1,"author":{"id":"aa8915ba52969f979af836ca4704fd27e613004f"},"timestamp":1258543457,"metadata":{"github-id":"MDU6SXNzdWUyODQ4NDkx","github-url":"https://github.com/parrot/parrot/issues/294","origin":"github"},"title":"Various failures on bogus string used as argname (1.7)","message":"I've got the following test setup (using Kakapo libs):\n\n```\nmethod test_initializer() {\n    my $obj := Kakapo::Test::Aclass.new(:a('albatross'), :b('byzantine'), :c('chrysanthemum'));\n\n    self.assert_that('test object.a', $obj.a, is(\"albatross\"));\n    self.assert_that('test object.b', $obj.b, is(\"byzantine\"));\n}\n\nmodule Kakapo::Test::Aclass;\nuse(        'P6object');\nextends(     'Kakapo::Object');\nhas(        'b a');\n```\n\nThe upshot of this is that accessor methods called Kakapo::Test::Aclass::a() and ...b() are mechanically generated and compiled (using plain old NQP+PIR in 1.7).\n\nThe Kakapo::Object base class contains, among other things, this code:\n\n```\nmethod new(*@pos, *%named) {\nsay(\"New!\");\nDumper::DUMP_(self, @pos, %named);\n    my $class := Opcode::getattribute(self.HOW, 'parrotclass');\n    my $new_object := Opcode::new($class);\n\n    # NB: I'm not flattening the params, because that forces\n    # everybody to do call_method or in-line pir to pass\n    # along flat args.\n    $new_object.init_(@pos, %named);\n    return $new_object;\n}\n```\n\nAs far as I can tell, the standard P6object functionality is working. The class is set up by Kakapo as a child of Kakapo::Object, and the Kakapo::Object::new() method is being called. Here is the output:\n\n```\nNew class: Aclass parent: Kakapo::Object\nDone\nNew!\n\"$VAR\" =\u003e ResizablePMCArray (size:3) [\n    undef,\n    ResizablePMCArray (size:0) [\n    ],\n    Hash {\n        \"(0x0011)\" =\u003e \"albatross\",\n        \"Global\" =\u003e \"byzantine\",\n        \"new\" =\u003e \"chrysanthemum\"\n    }\n]\nNo accessor defined for attribute 'Global'.\ncurrent instr.: 'parrot;Opcode;die' pc 28248 (library/kakapo_test.pir:11177)\ncalled from Sub 'parrot;Kakapo;Object;_block307' pc 8792 (library/kakapo_test.pir:3423)\ncalled from Sub 'parrot;Kakapo;Object;_block285' pc 8745 (library/kakapo_test.pir:3403)\ncalled from Sub 'parrot;Kakapo;Object;init_' pc 8620 (library/kakapo_test.pir:3347)\ncalled from Sub 'parrot;Kakapo;Object;new' pc 9090 (library/kakapo_test.pir:3531)\ncalled from Sub 'parrot;Kakapo;Test;Class;Attributes;test_initializer' pc 462 (t/Classes/Attributes.pir:128)\n```\n\nUntil today, the failure was not \"No accessor defined\" but rather an assert failure on an invalid string.\n\nThis is the generated PIR for the `new` call:\n\n```\n    .lex \"self\", self\n    get_hll_global $P50, [\"Kakapo\";\"Test\"], \"Aclass\"\n    $P51 = $P50.\"new\"(\"albatross\" :named(\"a\"), \"byzantine\" :named(\"b\"), \"chrysanthemum\" :named(\"c\"))\n    .lex \"$obj\", $P51\n```\n\nI don't have a good steps-to-reproduce, because the Kakapo library is somewhat large, and a bit of a nest of snakes as far as isolating behaviors.\n\nWhat's more, the aberrant behavior appears to be related somehow to calling with named parameters. Since 1.8 is the pcc refactor release, I think I can predict the response of the dev team. But I wanted to document this now, just in case.\n\nOriginally http://trac.parrot.org/parrot/ticket/1306","files":null}]}