{"version":1,"ops":[{"type":1,"author":{"id":"8c86ede03c8e80b0dad5131138f96e957a4ee66b"},"timestamp":1383419338,"metadata":{"github-id":"MDU6SXNzdWUyMjAwNzQ4Mw==","github-url":"https://github.com/parrot/parrot/issues/1019","origin":"github"},"title":"Interface get_pmc_keyed on ParrotInterpreter does not really use invocant","message":"Reported by: zefram@fysh.org\n\nThe get_pmc_keyed interface on ParrotInterpreter objects doesn't return information about the interpreter represented by its invocant, but about the currently running interpreter. Example:\n\n```\n$ cat t59.pir\n.sub foo\n        $P0 = get_global \"maininterp\"\n        $P1 = $P0[\"sub\"]\n        say $P1\n        .return ()\n.end\n.sub main :main\n        $P0 = getinterp\n        set_global \"maininterp\", $P0\n        .const \"Sub\" foo = \"foo\"\n        $P1 = new \"Task\", foo\n        schedule $P1\n        sleep 0.1\n.end\n```\n\n```\n$ ./parrot t59.pir\nfoo\n```\n\nWhat I said in previous bug report about the \"recursion_limit\" method applies here too: reading these data about the state of the currently running interpreter are perfectly reasonable operations to support, but they should be presented as opcodes or as standalone subroutines. It is highly misleading to present them as methods on some invocant object that is unrelated to the operation. On the other hand, if there is to be this querying interface on interpreter objects, it should operate on the interpreter represented by its invocant. (It's also fine to have both types of interface, as long as each is individually in a sensible form.)\n\n-zefram\n\n```\nSummary of my parrot 5.7.0 configuration:\n  configdate='Sat Oct  5 12:42:43 2013 GMT'\n  Platform:\n    osname=linux, archname=x86_64-linux-gnu-thread-multi\n    perl=/usr/bin/perl\n```","files":null}]}