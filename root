{"version":1,"ops":[{"type":1,"author":{"id":"8c86ede03c8e80b0dad5131138f96e957a4ee66b"},"timestamp":1383419489,"metadata":{"github-id":"MDU6SXNzdWUyMjAwNzUyNA==","github-url":"https://github.com/parrot/parrot/issues/1022","origin":"github"},"title":"Method \"recursion_limit\" does not really use invocant","message":"Reported by: zefram@fysh.org\n\nAn interpreter's recursion limit can be changed via the \"recursion_limit\" method on the ParrotInterpreter class. This is ostensibly a method that one calls against a particular interpreter object to read/write that interpreter's recursion limit, but actually the method always operates on the interpreter that is running the method call. It completely ignores its actual invocant. Example:\n\n```\n$ cat t57.pir\n.sub foo\n        $P0 = get_global \"maininterp\"\n        $P0.\"recursion_limit\"(2000)\n        say \"A\"\n        .return ()\n.end\n.sub main :main\n        $P0 = getinterp\n        set_global \"maininterp\", $P0\n        .const \"Sub\" foo = \"foo\"\n        $P1 = new \"Task\", foo\n        schedule $P1\n        sleep 0.1\n        say \"B\"\n        $I0 = $P0.\"recursion_limit\"()\n        say $I0\n.end\n```\n\n```\n$ ./parrot t57.pir\nA\nB\n1000\n```\n\nI use a sleep because there doesn't seem to be any synchronisation primitive built in at the level I'm working with. The \"A\"/\"B\" outputs confirm that the sleep has had the intended effect. The recursion limit is retrieved from the main interpreter after there has been a call against the same interpreter object to set the limit to 2000, but the retrieved value is the default 1000.\n\nReading and writing the recursion limit of the currently running interpreter are perfectly reasonable operations to support, but they should be presented as opcodes or as standalone subroutines. It is highly misleading to present them as methods on some invocant object that is unrelated to the operation. On the other hand, if there is to be this method on interpreter objects, it should operate on the interpreter represented by its invocant. (It's also fine to have both types of interface, as long as each is individually in a sensible form.)\n\nThe current interface for \"recursion_limit\" supports a get-and-set operation, whereby a new limit is set and the old limit returned. Maintaining atomicity of this usage raises problems if the method is changed to be able to operate on interpreters other than the current one.\n\nA certain freedom of approach to this bug arises from the fact that the method is presently undocumented.\n\n-zefram\n\n```\nSummary of my parrot 5.7.0 configuration:\n  configdate='Sat Oct  5 12:42:43 2013 GMT'\n  Platform:\n    osname=linux, archname=x86_64-linux-gnu-thread-multi\n    perl=/usr/bin/perl\n```","files":null}]}