{"version":1,"ops":[{"type":1,"author":{"id":"8c86ede03c8e80b0dad5131138f96e957a4ee66b"},"timestamp":1380648185,"metadata":{"github-id":"MDU6SXNzdWUyMDM0Njg1NQ==","github-url":"https://github.com/parrot/parrot/issues/983","origin":"github"},"title":"Error flags should be lexically scoped","message":"```\nSummary: error flags should be lexically scoped\nReported by: zefram@fysh.org\n\n---\nThe errorson/errorsoff ops control flag bits that determine whether\nargument count errors are signalled as exceptions.  These flags are\ncurrently dynamically scoped, but that's a very bad idea.  They should\nbe, effectively, lexically scoped.\n\nThis issue is already mentioned in documentation.  PDD 23 (exceptions)\nhas a note\n\n    {{ TODO: \"errorson\" as specified is dynamically rather than lexically\n    scoped; is this good? Probably not good. Let's revisit it when we get\n    the basic exceptions functionality implemented. }}\n\nAs this is an issue you're already aware of, this isn't quite a normal\nbug report.  This is me weighing in on the design debate.  Util asked\n(on IRC) for code demonstrating the problem, but aside from demonstrating\nthat the flags are indeed dynamically scoped I don't think there's much\nthat a test case can achieve here.  It's not a matter of some specific\ncode getting the \"wrong\" behaviour; the issue is about the structure\nwith which one must write code to get the right behaviour.\n\nThe situations where this behaviour for the error flags is a problem\nare mainly those where code from multiple HLLs is cooperating.  In this\ncontext, a sub written in one HLL can be freely called by subs written\nin other HLLs, and when it calls other subs those may in turn be written\nin other HLLs.  Parrot's calling convention is intended to make this\nsort of thing work smoothly.\n\nConsider specifically the param count errors flag.  Generally, whether it\nis a signallable error to call a sub with the wrong number of arguments\nis a matter for that sub to decide.  Or, given a calling signature,\nwhether adherence to it is mandatory is a question of HLL semantics.\nSo the calling dynamic context, the context of a sub that could well be\nwritten in a different HLL, is fundamentally the wrong place from which\nto get this flag.\n\nQuite likely, when an HLL generates bytecode for a sub it'll write\nthe code with the assumption that the error flag will be set in its\npreferred way.  If it gets called from a contrary context, the sub will\nhave the wrong behaviour.  It's especially likely that the assumption\nwill be in favour of parameter errors being signalled, as that's Parrot's\ndefault state.  The result of being surprised by the flag being set the\nother way is that the body of the sub may execute without having received\narguments that it thought it was guaranteed to get.\n\nAn HLL can make sure it gets the error checking that it expects,\nby putting an errorson/errorsoff op (or both kinds of op) at the very\nbeginning of every sub.  It would be unfortunate to incur even this tiny\nruntime overhead in every sub as the mandatory price of correctness.\nIt's sure that many HLLs won't bother, either from ignorance or misplaced\nconcern for performance.\n\nThere are other problems that arise from always setting the flags in\neach sub.  It works OK if *all* HLLs set the flags in every sub; each\nsub gets the flags it wants.  But this works by completely defeating\nthe dynamic scoping of the flags.  If any subs don't set the flags,\nand might be called from a foreign context, they're now more vulnerable\nthan before, because they're very likely to run into foreign flag states.\n\nIt would be appealing for an HLL to try to appear well behaved with\nrespect to these flags.  A well-behaved sub should have its effective\nbehaviour isolated from the dynamic flags: it should have the error\nsignalling behaviour that it wants for itself, but it should pass the\nflags from its caller through to its callees unmolested.  (It should be\ntransparent to the dynamic chain of flag states.)  But it's impossible\nto achieve this, for two reasons.\n\nFirstly, the flags are write-only: there are ops to set and clear the\nflags, but not to read them.  So, once one has set the flags for oneself,\none is irrevocably committed to those changes: there's no way to set\nthem back to the state the caller supplied.  Secondly, AFAICS one can't\nseparate the flag state that one passes to one's callee from the flag\nstate that will affect one's reception of results from that callee.\nSo one is forced to pass a flag state to callee's that reflects one's\ninternal implementation details.\n\nWhat should be done instead?  I think this actually varies among the\nflags, so I'll consider them separately.\n\nThe param count and result count flags are a matter of language semantics.\nAs I suggested above, a sub will tend to be written to use one error\nbehaviour or the other.  So the flags should be tied to stretches of\nbytecode or to whole subs, rather than to dynamic contexts.  But actually\nthat presupposes that an explicit flag is desired at all.  There are\nbetter solutions.  At the bytecode level, the flags could be incorporated\ninto the affected ops: accepting results with and without count checking\nare *different operations* deserving different opcodes.  Or, more simply,\nthe ops could always perform error checking, and code that wants to not\ncheck can just add :optional flags and :slurpy params.  (It would be\npossible, but not necessary, for a lexically-scoped declaration in PIR\nsource to cause implicit transformation of param/result ops in either\nof those two ways.)\n\nThe integer-overflow flag is a bit trickier.  Again, math operations\nthat promote and those that signal errors are basically different\noperations, so the choice of behaviours could be achieved by doubling up\nthe affected opcodes.  But several of the ops are invoked via vtables,\nso it'd require doubling the vtable entries, and there are quite a few\noperations involved.  I think it's better to treat this difference in\nbehaviour as a difference between PMC classes: there's a PromotingInteger\nclass and a SignallingInteger class.  Each HLL uses whichever class it\nprefers, and if they get passed across HLL boundaries then the foreign\nbehaviour looks just like the arbitrary behaviour of any foreign class\nthat claims to perform math operations.\n\n-zefram\n\n\n---\nosname= linux\nosvers= 3.2.0-4-amd64\narch=   x86_64-linux-gnu-thread-multi\ncc=     cc\n\n---\nFlags:\n    category=core\n    severity=medium\n    ack=no\n\n---\nSummary of my parrot 5.5.0 configuration:\n  configdate='Sun Sep 22 18:01:32 2013 GMT'\n  Platform:\n    osname=linux, archname=x86_64-linux-gnu-thread-multi\n    perl=/usr/bin/perl\n  Compiler:\n    cc='cc', ccflags='-D_REENTRANT -D_GNU_SOURCE -DDEBIAN -fstack-protector  -pipe -I/usr/local/include -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64 -DDISABLE_GC_DEBUG=1 -DNDEBUG -DHAS_GETTEXT',\n  Linker and Libraries:\n    link='cc', linkflags=' -fstack-protector -L/usr/local/lib -Wl,-E',\n    ld='cc', ldflags=' -fstack-protector -L/usr/local/lib',\n    cc_ldflags='',\n    libs='-ldl -lm -lpthread -lcrypt -lrt -lgmp -lreadline '\n  Dynamic Linking:\n    cc_shared='-fPIC',\n    link_dynamic='-Wl,-E',\n    ld_share_flags='-shared -L/usr/local/lib -fstack-protector -fPIC',\n    ld_load_flags='-shared -L/usr/local/lib -fstack-protector -fPIC'\n  Extensions:\n    o='.o', a='.a', exe='',\n    share_ext='.so', load_ext='.so'\n  Misc Programs:\n    ar='ar', ranlib=':',\n    make='make', make_set_make='#'\n  Types:\n    iv=long, intvalsize=8, intsize=4, opcode_t=long, opcode_t_size=8,\n    ptrsize=8,  byteorder=12345678, \n    nv=double, numvalsize=8, doublesize=8, longdoublesize=16\n\n---\nEnvironment:\n    HOME =/home/zefram\n    LANG  (unset)\n    LANGUAGE  (unset)\n    LD_LIBRARY_PATH  (unset)\n    LOGDIR  (unset)\n    PATH =/home/zefram/usr/perl/util:/home/zefram/pub/x86_64-unknown-linux-gnu/bin:/home/zefram/pub/common/bin:/usr/bin:/bin:/usr/local/bin:/usr/games\n    SHELL =/usr/bin/zsh\n```","files":null}]}