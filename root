{"version":1,"ops":[{"type":1,"author":{"id":"86141a663c2eb7543d1a51ec6253a1d54de912fd"},"timestamp":1412754936,"metadata":{"github-id":"MDU6SXNzdWU0NTIxNDU1MQ==","github-url":"https://github.com/parrot/parrot/issues/1095","origin":"github"},"title":"wrongly parsed double-quoted .lex names, .lex \"foo\\\\o\"","message":"Needed by perl6: https://rt.perl.org/Public/Bug/Display.html?id=116643\nReportedly this worked in perl6-p before, but it could be a nqp change also, which put the statements into blocks, and thus the variables into lexicals.\n\nThe perl6 problem is with:  `.lex \"\u0026prefix:\u003c\\\\o/\u003e\", $P103` \nand it works with `.lex \"\u0026prefix:\u003c\\o/\u003e\", $P103` and `.lex '\u0026prefix:\u003c\\o/\u003e', $P103`.\nMost pir strings are not properly unescaped, ' and \" are treated just as ',\nonly when they are put into a register or with some other special cases (mk_sub_address_fromc) \nthe \" is unescaped.\nSo the perl6 workaround is to put such lexicals in single-quotes until `rurban/lexqnames-gh1095` has landed.\n\nparrot:\nIn these roundtrips only the first 2 names survive:\n\n```\n.sub 'main' :main\n    .lex 'bar\\o', $P0\n    $P1 = box 'ok 1'\n    store_lex 'bar\\o', $P1\n    $P2 = find_lex 'bar\\o'\n    say $P2\n\n    .lex \"foo\\\\o\", $P3       # imcc parses that as \"foo\\\\\\\\o\"\n    $P1 = box 'ok 2'\n    store_lex \"foo\\\\o\", $P1\n    $P2 = find_lex \"foo\\\\o\"\n    say $P2\n\n    .lex \"foo\\o\", $P4        # imcc parses that as \"foo\\\\o\"\n    $P1 = box 'ok 3'\n    store_lex \"foo\\o\", $P1   # parrot str_unescape compresses that to \"fooo\"\n    $P2 = find_lex \"foo\\o\"\n    say $P2\n.end\n```\n\n=\u003e \n\n```\nok 1\nok 2\nLexical 'fooo' not found\n```\n\nFor globals it is simplier, but the problem of ignoring Illegal escape sequences remains:\n\n```\n    $S1 = \"foo\\\\o\"\n    $P1 = box 'ok 2'\n    set_global \"foo\\\\o\", $P1   # ok, parsed as \"foo\\\\o\"\n    $P2 = get_global \"foo\\\\o\"\n    say $P2\n\n    $S2 = \"foo\\o\"\n    $P1 = box 'ok 3'\n    $S3 = \"fooo\"\n    $P2 = box 'ok 4'\n    set_global \"foo\\o\", $P1    # wrong, compressed to \"fooo\" (Ignored Illegal escape sequence \\o)\n    $P3 = get_global \"foo\\o\"\n    say $P3\n\n    $P3 = get_global \"fooo\"   # accesses $P1, not $P2\n    say $P3\n```","files":null}]}