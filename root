{"version":1,"ops":[{"type":1,"author":{"id":"aa8915ba52969f979af836ca4704fd27e613004f"},"timestamp":1253193061,"metadata":{"github-id":"MDU6SXNzdWUyODQ4NzY2","github-url":"https://github.com/parrot/parrot/issues/558","origin":"github"},"title":"clone_p_p segfaults with self-referential Hash pmc.","message":"If a complex data structure, built with Hash and Array structures, is self-referencing, running clone_p_p on it will quickly segfault.\n\n```\nour %Global_hash;\n\nsub bsu() {\n    say(\"BSU: starting.\");\n    %Global_hash\u003ckey\u003e\u003ckey2\u003e := 1;\n    %Global_hash\u003ckey\u003e\u003cloop\u003e := %Global_hash;\n\n    my %local := %Global_hash;\n\n    my $result := Q:PIR {{\n        $P0 = find_lex '%local'\n        %r = clone $P0\n    }};\n\n    say(\"BSU: returning.\");\n    return $result;\n\n}\n\nbsu();\n```\n\nThe solution here is likely to be involved -- perhaps disabling the GC and using the mark bit to track what has been cloned. But segmentation fault is not a parrot exception, which is what a memory problem should become.\n\nDukeleto confirms this problem exists on Darwin, and his Linux box.\n\nFYI: I discovered this because PCT clones the symbol table of PAST::Block nodes.\n\nOriginally http://trac.parrot.org/parrot/ticket/1015","files":null}]}