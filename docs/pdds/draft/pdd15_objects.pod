# Copyright (C) 2001-2007, The Perl Foundation.
# $Id$

=head1 NAME

docs/pdds/pdd15_objects.pod - Object and Class semantics for Parrot

=head1 ABSTRACT

This PDD describes the semantics of Parrot's object and class systems.

=head1 VERSION

$Revision$

=head1 DEFINITIONS

=head2 Object

An object is a value that incorporates both data and behavior
related to that data.

=head2 Class

A class defines a pattern of characteristics and behaviors from which
objects are constructed.

=head2 Attribute

An attribute is a slot in an object that contains a value, generally a
PMC. Attributes are referenced by class name/attribute name pairs.

Attributes are set on a class-wide basis, and all the objects of a class
will have the same set of attributes.  Most OO languages don't allow
attribute changes to existing classes, but Parrot's base attribute
system does allow it. In order to safely support advanced dynamic
features in HLLs, attributes are not accessible via fixed attribute
offsets, but only via named lookup.

=head2 Method

A method is a piece of code that you invoke by name through an object.
Methods implement the behaviour of an object.

=head2 Parent class

Also called the super-class. The parent class is, in an inheritance situation,
the class being derived from. If A derives from B, B is the parent class of A.

=head2 Child class

Also called the sub-class. The child class is, in an inheritance situation, the
class doing the deriving. If A derives from B, A is the child class.

=head2 Role

A role adds attributes and methods into a class without inheritance. The
composed class retains a list of roles applied to it (so they can be
checked with C<does>), but otherwise maintains no distinction between
composed attributes and methods and those defined in the class.

=head2 Delegate

An object that is transparently (to the user) embedded in another object.
Delegate objects are used in those cases where we can't inherit from a class
because the class is from a different object universe.

=head2 Property

A property is a role that only adds attributes and accessors.

Properties are generally assigned at runtime, and a particular property may or
may not exist on a PMC at any particular time. Properties are not restricted to
objects as such--any PMC may have a property attached to it.

=head2 Interface

An interface is a role that only adds methods.

=head1 DESCRIPTION

=over 4

=item - The object and class system provides the flexibility to
implement a core set of dynamic languages (Perl 6, Ruby, Python, etc).
Other class systems may be implemented later to support other languages.

=item - Classes may have an associated namespace. (Anonymous classes are
not associated with a namespace.)

=item - Classes may have one or more immediate parent classes

=item - Classes may have a catalog of attribute names.

=item - Classes may have a list of roles they implement

=item - Classes can instantiate an object of their class

=item - Classes can add and remove parent classes

=item - Classes can add and remove attributes

=item - Classes can add (but not remove) roles

=item - Classes are instances of a meta-class and have their own sets of
class methods and class attributes

=item - Objects may have an array of attributes. Attribute values may be
PMCs or a low-level type.

=item - Objects have an associated class.

=item - Objects may have a custom vtable or use a class-wide vtable.

=item - Objects can call a method

=item - Objects can retrieve a method PMC for a method (for deferred
method calls)

=item - Objects can fetch their class

=item - Objects can be subclassed (note that objects may not necessarily
be able to have their classes changed arbitrarily, but making a subclass
and moving the object to it is allowable)

=item - Objects can get an attribute by name

=item - Objects can set an attribute by name

=back

=head1 IMPLEMENTATION

There are four pieces to the object implementation. There are the PMCs for the
classes and objects, the opcodes the engine uses to do objecty things, the
specific vtable methods used to perform those objecty things, and the
supporting code provided by the interpreter engine to do the heavy lifting.

Please note that Parrot, in general, does I<not> restrict operations on objects
and classes. If a language has restrictions on what can be done with them, the
language is responsible for making sure that disallowed things do not happen.
For example, Parrot permits multiple inheritance, and will not stop code that
adds a new parent to an existing class. If a language doesn't allow for
multiple inheritance it must not emit code which would add multiple parents to
a class. (Parrot may, at some point, allow imposition of runtime restrictions
on a class, but currently it doesn't)


=head2 Class PMC API

There are two PMC classes, C<Class> and C<Object>.  Class PMCs hold all
the class-specific information. Instantiating a new OO class creates a
new Class PMC, and enters the new OO class into Parrot's PMC class
table, at which point it is indistinguishable from any other PMC class.

It's important to note that 'standard' classes are Class PMC instances,
or instances of a subclass of the Class PMC, and 'standard' objects are
Object PMCs. It isn't necessary to create a brand new low-level PMC
class for each OO class, and they all share the Class or Object vtable,
respectively.

An instance of the Class PMC has ten internal attributes, which are:

=over 4

=item 0

The class name

=item 1

A link to the class's associated namespace

=item 2

A "have I been instantiated since I was last modified" flag

=item 2

An array PMC of the immediate parent classes

=item 3

A cached array of all parent PMCs, in search order (this is an optional
optimization, and can be calculated from the class's rules of
inheritance, the list of immediate parent classes, and the parent
classes' rules of inheritance)

=item 4

An array PMC of the composed roles

=item 5

A hash PMC of the methods defined in the class or composed into the
class

=item 6

A hash PMC of the overloaded PMC vtable entries for the class.

=item 7

The class attribute metadata hash. Keys are the attribute names and the
values are a hash of attribute characteristics, including name, type, the
class they're associated with and any flags (for example, private). Note
that this only stores metadata for the attributes defined in this class,
and not for attributes inherited from its parents.

=item 8

The full attribute lookup table. This associates attribute names with an
index into the object's attribute storage (an array). It includes all
attributes defined in the current class and every other class that it
inherits from either directly or indirectly. The table is keyed on the
name of the class where the attribute is defined, along with the
attribute name. The value is an index into the per-object attribute
store.

=item 9

The attribute cache. While the attribute lookup table defines every
attribute, whether it is visible or not with the current method
resolution order (MRO), the cache maps the names of the visible
attributes directly to an index in the per- object attribute store. That
saves a more costly lookup in the full attribute lookup table.

=back

The attribute catalog holds only the attributes defined in a particular
class. When instantiating an object, the object data store is created as
a ResizablePMCArray, so doesn't need any specific details of the class's
attribute structure. As attributes are set in the object (based on the
index in the lookup table), the Array expands to accommodate the
attribute indexes that are actually used. In the common case, a
relatively small set near the lower index range is all that will be
used.

When setting the attribute cache it is necessary to scan all parent
classes as well as the instantiated class for attributes defined there.
The inheritance rules (MRO) for a particular HLL will determine which
child class attributes override which parent class attributes.  The
cache is only set on individual accesses to a particular attribute.

(If a parent class changes its set of attributes, should that change
appear in later instantiations of objects from child classes? If so, all
of these classes would need to be re-constructed as a result of the
change; note that any already instantiated objects would refer to the
old class. NOTE: flag old classes with an "updated" status, to notify
objects of the old class that they should rebless themselves into the
new class next time they access the old class?)

Class PMCs also have the "I am a class" flag set on them.

=head3 Methods

=over 4

=item name

The accessor for the name attribute. With no argument, it simply returns
the current value for name. When passed an argument, it sets the name of
the class, and also sets the association with a namespace. With no
argument it only returns the current value of the name attribute.

=item new

    obj = class.'new'( 'myattrib' => "Foo" )

Create a new instance object from the class object. It takes an
optional, slurpy, named list of attributes and values to initialize the
object. Passing attribute names that weren't declared in the class is an
error.

=item attributes

An accessor for the attributes of the class. It returns the a Hash of
all attributes, with a key of the attribute name and a value of a Hash
containing the attribute's metadata. The accessor is read-only.

=item add_attribute

Adds a single attribute to the class. It takes a simple string name and,
optionally, a simple string value for type. {{ Conjectural: Actually, the
simple string value alone won't cut it. We need to take a key there too? }}

=item add_method

Adds a method to the class. It takes a simple string name and a method
PMC. If the method already exists (and isn't a Multi) it will replace
the method with the new method and throw a warning.

It also takes slurpy named parameters to flag whether the method is a
vtable method, and whether its anonymous (no named entry as a method,
only as a vtable). 

=item methods

An accessor for the methods of the class. It returns a Hash of all methods,
with a key of the method name and a value of an invokable PMC. Note that the
methods list includes any methods that were composed into the class from
roles.

=item parents

An accessor for the parents of the class. It returns an Array of all
parents. The accessor is read-only.

=item add_parent

Adds a single parent to the class. It takes an instance of the Class PMC.

=item roles

An accessor for the roles of the class. It returns an Array of all
roles. The accessor is read-only.

=item add_role

Adds a single role to the class. It takes an instance of the Role PMC as a
required positional parameter, and the optional named parameters C<without>
and C<alias>; see L<Role Conflict Resolution> for more details.

=back

=head3 Classes, Namespaces, and the Class Registry

[Stream-of-consciousness to be cleaned up later]
The class registry has a much diminished role in this implementation.
Its only responsibility is maintaining a mapping of unique IDs to class
objects throughout the system. (We may eventually be able to eliminate the
registry altogether.) It can't be used for looking up classes by name,
because it's possible to have multiple classes with the same name in the
same namespace. (When you extend an existing class, it actually creates
a new class, that replaces the old class in the Namespace, but the old
class can't be thrown away if it has objects instantiated in it. The old
objects still point to the old class and do their method resolution and
attribute lookup through that class. If a class hasn't been
instantiated, adding a method doesn't create a new class. If it has been
instantiated, it creates a new class the first time it's extended,
and then doesn't create a new class until it is instantiated again.) The
class registry needs to have names removed entirely (it doesn't care
about names anymore).  Low-level PMC types also need entries in the
namespace hierarchy.

The Namespace always points to the most current incarnation of the
class. All the class objects that nominally exist in a namespace point
to that namespace object.

A class can be garbage collected when it has no instantiatated objects
and no Namespace object referencing it. When a class is garbage
collected, it should remove itself from the registry.

A class object responds to C<isa>, C<can>, and C<does>.


=head2 Object PMC API

C<Object> PMCs are the actual objects, and hold all the per-object
instance data.

The Object PMC is an array of meta-information and attributes. The
elements of this array are:

=over 4

=item 0

The class PMC

=item 1

The object attribute store. This is simply an array of PMCs that
provide the values for the attributes. It may be a resizable PMC array
to provide lazy growth rather than allocating all needed memory for
all attributes. We find the indexes into this array from the attribute
cache or lookup table in the class.

=back

A list of the object's attributes is accessible from the class. The
attribute cache is the most straightforward way to retrieve a complete
list of attributes visible to the object, but the first time you
introspect for a complete list the class may have to calculate the list
by traversing the inheritance hierarchy.

Object PMCs have the "I am an object" flag set on them.

Object PMCs have no methods aside from those defined in their associated
class. They do have vtable methods providing access to certain low-level
information about the object, method call functionality, etc. See the
sections below on L<Objects> and L<Vtables>.

[stream-of-consciousness again]
In addition to a value type, objects can have a container type. The
container type can't be stored in the object itself, because a single
object may live within multiple containers. So, the container type (when
it exists) is stored in the LexPad or Namespace entry for a particular
variable.

In a static language like C#.Net:

  B isa A
  A o1 = new B();
  B o2 = new B();
  
  o1.x; # retrieves A's attribute
  o2.x; # retrieves B's attribute

  o1.foo(); # call's B's method
  o2.foo(); # call's B's method


=head2 Role PMC API

An instance of the Role PMC has five attributes, which are:

=over 4

=item 0

The role name

=item 1

A link to the role's associated namespace

=item 2

An array PMC of composed roles

=item 3

An array PMC of the methods defined in the role or composed into the
role

=item 4

The role attribute hash. Keys are the attribute names and the values
are a hash of attribute characteristics, including name, type, and the
role they're associated with.

=back

=head3 Methods

=over 4

=item name

The accessor for the name attribute. With no argument, it simply returns
the current value for name. When passed an argument, it sets the name of
the role, and also sets the association with a namespace.

When you associate a class with a namespace, it pulls in all of the
methods and vtable methods held within that namespace.  And when
replacing one class with another in the association, it removes any
methods and vtable methods from the previous class.

=item attributes

An accessor for the attributes of the role. It returns the Hash of all
attributes, with a key of the attribute name, and a value of the
attribute's metadata (a Hash).  The accessor is read-only.

=item add_attribute

Adds a single attribute to the role. It takes a simple string name, and
a simple string value for type.

=item roles

An accessor for the roles composed into the role. It returns an Array of
all roles as PMC objects. The accessor is read-only.

=item add_role

Adds a single role to the role. It takes a simple string name.

=item add_method

Adds a method to the role. It takes a simple string name and a method
PMC. If the method already exists (and isn't a Multi) it will replace
the method with the new method and throw a warning.

It also takes slurpy named parameters to flag whether the method is a
vtable method, and whether its anonymous (no named entry as a method,
only as a vtable). 

=item methods

An accessor for the methods of the role. It returns a Hash of all methods,
with a key of the method name and a value of an invokable PMC.

=back


=head2 Opcodes

The following ops are provided to deal with objects. Please note that method
calls are governed by Parrot's calling conventions, and as such objects, method
PMCs, return continuations, and parameters must be in the right places, though
some ops will put parameters where they need to go.

=over 4

=item classoffset Ix, Py, Sz [deprecated]

Returns the offset of the first attribute for class Sz in object Py.

=item getattribute Px, Py, Iz

Returns attribute Iz of object Py and puts it in Px. Note that the attribute
number is an absolute offset.

=item getattribute Px, Py, Sz

Get the attribute with the fully qualified name Sz from object Py and put it in
Px.

=item setattribute Px, Iy, Pz

Set the attribute Iy of object Px to Pz. Note that this op stores the B<actual>
PMC rather than a copy, and so if the PMC's value is subsequently changed, the
value of the attribute will also change.

=item setattribute Px, Sy, Pz

Set the attribute of object Px with the fully qualified name Sy to Pz

=item callmethod

=item callmethod Sz

Call a method. If the method name is provided, we find the PMC for the named
method and put it in the sub/method slot. If no name is provided we assume that
all the calling conventions have already been set up and the method PMC is
already in the proper place.

=item callmethodcc

=item callmethodcc Sx

Make a method call, automatically generating a return continuation. If a method
name is passed in we look up the method PMC for the object and put it in the
method slot. If a method name isn't provided then we assume that things are
already properly set up.

=item tailcallmethod (Unimplemented) [deprecated]

=item tailcallmethod Sx (Unimplemented) [deprecated]

Make a tailcall to method Sx. If no method name is given, we assume everything
is already set up properly.

=item newclass Px, Sy

Create a new base class named Sy, and put the PMC for it in Px

=item subclass Px, Py, Sz

Create a new class, named Sz, which has Py as its immediate parent.

=item addparent Px, Py

Add class Py to the end of the list of immediate parents of class Px. Adds any
attributes of Py (and its parent classes) that aren't already in Px.

=item removeparent Px, Py (Unimplemented)

Remove class Py from the parent list of Px. All parent classes of Py which
aren't parent classes of what remains of Px's parent list are removed, as are
their attributes.

=item addattribute Px, Sy

Add attribute Sy to class Px. This will add the attribute slot to all objects
of class Px and children of class Px, with a default value of C<Null>.

=item removeattribute Px, Sy (Unimplemented)

Remove the attribute Sy from class Px, all objects of class Px, and all objects
of a child of class Px.

=item addrole Px, Py

Add role Py to the end of the list of roles of class Px. Adds any
attributes of Py that aren't already in Px.

=item instantiate Px, Py, Sz (Unimplemented) [deprecated]

Instantiate a brand new class, based on the metadata in Py, named Sz.

=back

=head2 Vtables

To make this work all PMCs must have the following vtable entries. They may,
for non-objects, throw an exception.

The catalog metadata for objects is considered to be attributes on the class,
so to get the offset for a class for an object, you fetch the object's class
then look up the offset attribute from it. (The class attributes are detailed
later) This is safe in general, since the only code reasonably querying a
class' attribute list is the class code itself, and if a class doesn't know
whether it's a Class-style class or not you've got bigger problems.

=over 4

=item find_method(string *)

Returns the PMC for the named method. If no method of this name exists, nor can
be constructed, returns a Null PMC.

Note that for languages which support default fallback methods, such as Perl
5's AUTOLOAD, this would be the place to return it if a normal lookup fails.

Since the method list and vtable method list are stored in the class
PMC, method finding is a lookup on the class object and not a lookups in
the namespace. (This could be handled automatically whenever a class is
associated with a namespace.) Just adding a sub to a namespace will not
automatically make it a method of the class, you have to call add_method
too.

=item isa(class *)

Returns true or false if the class passed in as a parameter is in the
inheritance hierarchy of the object.

=item can(string *)

Returns true or false if the object can perform the requested method.
(Including with an AUTOLOAD)

=item does(class *)

Returns true or false to note whether the object in question implements the
interface passed in.

=item get_attr(INTVAL) [deprecated]

Returns the attribute at the passed-in offset for the object.

=item get_attr(STRING*)

Returns the attribute with the fully qualified name for the object.

=item set_attr(INTVAL, PMC *) [deprecated]

Sets the attribute for the passed-in offset to the passed-in PMC value

=item set_attr(STRING*, PMC *)

Set the attribute with the fully qualified name for the object.

=item get_class

Returns the class PMC for the object.

=back

Currently Parrot only supports mutating a class' metainformation for
Class classes. This is a restriction which will be lifted at some point
soon.


=head2 What The Bytecode Sees

The bytecode is isolated from most of the internal details of the
implementation. This allows both for flexibility in the implementation and
forward compatibility, generally good things. It also allows for multiple
concurrent interoperable object systems. The major thrust is for transparent
use of objects, though most class activity (including creation of subclasses
and modifications of existing classes) should be transparent as well.


=head2 Role Conflict Resolution

{{ Conjectural:

When a role is added to a class, we try to compose it right away, and flag up
any conflicts that are detected. A conflict occurs if two roles try to supply
a method of the same name (but see the note on multi-methods below). High
level languaes will provide varying facilities to deal with this, and Parrot
provides the primitives to implement them.

When adding a role to a class, you can optionally supply an array of method
names from the role to exclude from the composition process. This is done
using the named parameter C<without>. It is not an error to list a method name
in this array that the role does not have. This makes it possible to implement
languages that provide for explicit exclusions on a role-by-role basis as well
as Perl 6, which can supply an array of all method names in the class (since
writing a method in the class resolves any conflicts between methods of the
same name from roles, and automatically overrides it).

The second primitive is aliasing. When adding a role to a class, the optional
C<alias> named parameter can be supplied, with a value of a hash of strings to
strings. The key of this hash is a method name in the role, and the value is
the name we should give it when we compose it in to the class. This will allow
Parrot to support languages that allow resolution of conflicts in this form.

It is fine to use both C<without> and C<alias> with a single role. However,
placing a method name in the exclude list and also aliasing it has undefined
behaviour.

If a method in a role is a MultiSub PMC and there is either no method of that
name yet OR what is in the method slot with that name is also a MultiSub PMC,
there will be no error. Instead, the multi-methods from the role will be added
to the multi-methods of the MultiSub PMC already in the class. Any attempt to
combine a multi with a non-multi will result in an error.

}}


=head1 EXAMPLES

The following examples all assume we're working with basic Object objects
and Class classes.

=head2 Creating a new class

To create a new class C<Foo> which has no parent classes:

   newclass $P0, "Foo"

=head2 Creating a new class with multiple parents

To create a class C<Foo> with the parents C<A> and C<B>, the code would be:

   getclass $P0, "A"
   getclass $P1, "B"
   subclass $P2, $P0, "Foo"
   addparent $P2, $P1

=head2 Creating a new class with attributes

Adding the attributes C<a> and C<b> to the new class C<Foo>:

  newclass $P0, "Foo"
  addattribute $P0, "a"   # This is offset 0 + classoffset
  addattribute $P0, "b"   # This is offset 1 + classoffset

=head2 Instantiating an object

Assuming we want an object of class C<Foo>:

  .local pmc FooClass
  .local pmc MyObject
  find_class FooClass, "Foo"
  new MyObject, FooClass

=head2 Calling a method on an object

Calling the method C<Xyzzy> on an object, assuming the PDD03 calling
conventions are respected:

  callmethod "Xyzzy"

  set S0, "Xyzzy"
  callmethod

Or, if a return continuation needs constructing:

  callmethodcc "Xyzzy"

  set S0, "Xyzzy"
  callmethodcc

=head2 Accessing attributes from within a class

With named access:

  getattribute $P1, $P0, "Foo\x0b"

=head1 Explanations

To get a new class, you can do a C<newclass>, which creates a new class with no
parents besides Parrot's default super-ish parent class.

To get a new child class, you have two potential options:

=over 4

=item Subclass the parent

=item Create a new standalone class and add a parent

=back

Both ways work. It is, however, more efficient to use the first method, and
just subclass the immediate parent class of your new class.

When adding in extra parents in a multiple-inheritance scenario, subclass the
first class in the immediate parent list then use the C<addparent> op to add in
the rest of the immediate parents.

=head2 VTABLE OVERLOADING

Classes may override the vtable methods, allowing objects of a class to behave
like a primitive PMC. Each vtable slot has a corresponding named method that
Parrot looks for in your class hierarchy when an object is used in a primitive
context.

To use these properly at a low-level requires a good working knowledge of the
way Parrot works--generally for higher-level languages the language compiler or
runtime will provide easier-to-use wrappers. These methods are all prototyped,
and take a single fixed argument list, and return at most a single value.

While vtable methods I<may> take a continuation, those continuations may I<not>
escape the vtable method's execution. This is due to the way that vtable
methods are called by the interpreter--once a vtable method is exited any
continuation taken within it is no longer valid and may not be used.

Note that any class method that wishes to use Parrot's multi-method dispatch
system may do so. This is, in fact, encouraged, though it is not required. In
the absence of explicit multimethod dispatch, a left-side wins scheme is used.

The following list details the raw method names:

=over 4

=item init

Called when the object is first created.

=item init_pmc

Alternative entry point called when object is first created.  Accepts a PMC
parameter used to initialize the given object.  Interpretation of the PMC is
PMC-specific.

NOTE: It is strongly suggested that init_pmc(PMCNULL) be equivalent to
init(), though there will of necessity be exceptions.

=item morph

=item mark

Called when the DOD is tracing live PMCs. If this method is called then the
code must mark all strings and PMCs that it contains as live, otherwise they
may be collected.

This method is only called if the PMC is flagged as having a special mark
routine, and is not necessary for normal objects.

=item destroy

Called when the object is destroyed. This method is only called if the PMC is
marked as having an active finalizer.

=item getprop

=item setprop

=item delprop

=item getprops

=item type

=item type_keyed

=item type_keyed_int

=item type_keyed_str

=item subtype

=item name

=item clone

=item find_method

=item get_integer

Return the integer value of the object

=item get_integer_keyed

=item get_integer_keyed_int

=item get_integer_keyed_str

=item get_number

Return the floating-point value of the object

=item get_number_keyed

=item get_number_keyed_int

=item get_number_keyed_str

=item get_bignum

Return the extended precision numeric value of the PMC

=item get_string

Return the string value of the PMC

=item get_string_keyed

=item get_string_keyed_int

=item get_string_keyed_str

=item get_bool

Return the true/false value of the PMC

=item get_bool_keyed

=item get_bool_keyed_int

=item get_bool_keyed_str

=item get_pmc

Return the PMC for this PMC.

=item get_pmc_keyed

=item get_pmc_keyed_int

=item get_pmc_keyed_str

=item get_pointer

=item get_pointer_keyed

=item get_pointer_keyed_int

=item get_pointer_keyed_str

=item set_integer_native

Set the integer value of this PMC

=item set_integer_same

=item set_integer_keyed

=item set_integer_keyed_int

=item set_integer_keyed_str

=item set_number_native

Set the floating-point value of this PMC

=item set_number_same

=item set_number_keyed

=item set_number_keyed_int

=item set_number_keyed_str

=item set_bignum_int

Set the extended-precision value of this PMC

=item set_string_native

Set the string value of this PMC

=item set_string_same

=item set_string_keyed

=item set_string_keyed_int

=item set_string_keyed_str

=item set_bool

Set the true/false value of this PMC

=item assign_pmc

Set the value to the value of the passed in

=item set_pmc

Make the PMC refer to the PMC passed in

=item set_pmc_keyed

=item set_pmc_keyed_int

=item set_pmc_keyed_str

=item set_pointer

=item set_pointer_keyed

=item set_pointer_keyed_int

=item set_pointer_keyed_str

=item elements

Return the number of elements in the PMC, if the PMC is treated as an
aggregate.

=item pop_integer

=item pop_float

=item pop_string

=item pop_pmc

=item push_integer

=item push_float

=item push_string

=item push_pmc

=item shift_integer

=item shift_float

=item shift_string

=item shift_pmc

=item unshift_integer

=item unshift_float

=item unshift_string

=item unshift_pmc

=item splice

=item add

=item add_int

=item add_float

=item subtract

=item subtract_int

=item subtract_float

=item multiply

=item multiply_int

=item multiply_float

=item divide

=item divide_int

=item divide_float

=item modulus

=item modulus_int

=item modulus_float

=item cmodulus

=item cmodulus_int

=item cmodulus_float

=item neg

=item bitwise_or

=item bitwise_or_int

=item bitwise_and

=item bitwise_and_int

=item bitwise_xor

=item bitwise_xor_int

=item bitwise_ors

=item bitwise_ors_str

=item bitwise_ands

=item bitwise_ands_str

=item bitwise_xors

=item bitwise_xors_str

=item bitwise_not

=item bitwise_shl

=item bitwise_shl_int

=item bitwise_shr

=item bitwise_shr_int

=item concatenate

=item concatenate_native

=item is_equal

=item is_same

=item cmp

=item cmp_num

=item cmp_string

=item logical_or

=item logical_and

=item logical_xor

=item logical_not

=item repeat

=item repeat_int

=item increment

=item decrement

=item exists_keyed

=item exists_keyed_int

=item exists_keyed_str

=item defined

=item defined_keyed

=item defined_keyed_int

=item defined_keyed_str

=item delete_keyed

=item delete_keyed_int

=item delete_keyed_str

=item nextkey_keyed

=item nextkey_keyed_int

=item nextkey_keyed_str

=item substr

=item substr_str

=item invoke

=item can

=item does

=item isa

=item freeze

=item thaw

=item thawfinish

=item visit

=item share

=back

=head1 LANGUAGE NOTES

This PDD is due an overhaul. This requirements section is for language
implementers to list the OO-related needs of their language in so as to aid
that.

=head2 PMCS

Ruby: Just like small talk, everything is an object.  I'm hoping to be able to 
implement core Ruby classes(String, Array, Hash, Module, etc)  something like this.

ParrotClass
    |
 RubyClass   String
    |         |
     \      /
    RubyString

=head2 Objectspace

Ruby: Objectspace in Ruby allows the programmer to iterate through every live object
in the system.  There is some debate about how to make this play nice with different
garbage collection schemes.

=head2 Classes

A class is a collection of methods and attributes. It would be desirable, for
those classes whose definition is fully known at compile time, to have a
convenient way to have the class along with its attributes and methods stored
into a PBC file rather than created at runtime. However, creation of new
classes at runtime will be needed too.

=head2 Meta-classes

Ruby: Ruby has meta classes.  It would be nice if classes were objects in Parrots OO model.

=head2 Attributes

Attributes are instance data associated with a class (or role, however those
are supported). They may not always be of a type specified by a PMC, though
boxing/unboxing is of course an option.

Perl 6: All attributes are opaque (not externally visible, even to any
subclasses).

.Net: Attributes may be private (not externally visible), public (always
externally visible), protected (only visible to subclasses) and internal
(only visible inside the current assembly - the closest correspondence in
Parrot is perhaps only visible inside the same PBC file). Additionally, it
is allowable for a subclass to introduce an attribute of the same name as
the a parent class has, and they both exist depending on what type an
instance of the class is currently viewed as being (read: there is a
difference between the type of the reference and the type of the value).

Ruby: Attributes can be dynamically added and removed at runtime.

=head2 Methods

Perl 6: Methods may be public (anyone can invoke them) or private (only
invokable by the class they are defined in). Additionally, submethods are
methods that do not get inherited.

.Net: Like attributes, methods may be public, private, protected or internal.

Ruby: has a method_missing that gets called when method resolution fails to find a method.
Methods can be dynamically added and removed at runtime.

=head2 Constructors

A constructor is run when an object is instantiated.

.Net: There may be many constructors for an object (provided they all have
different signatures), and the correct one is called based upon the passed
parameters.

=head2 Inheritance

Perl 6: Multiple inheritance.

.Net: Single inheritance.

Ruby: Single inheritance but support for mixins of Ruby modules.

=head2 Interfaces

An interface specifies a set of methods that must be implemented by a class
that inherits (or implements) the interface, but does not provide any form of
implementation for them.

.Net: Interfaces are pretty much what was just describe above. XXX Need to
check behavior of you implement two interfaces with methods of the same name.

=head2 Roles

A role consists of a set of methods and attributes. It cannot be instantiated
on its own, but must be composed into a class. When this happens its methods
and attributes become of that classes methods and attributes. This may happen
at compile time or runtime, however when a role is composed into a class at
runtime then what really happens is that a new anonymous class is created with
the role composed into it and then the namespace entry for the existing class is
updated to refer to the new one. Note that this means classes must be garbage
collectable, with all those referred to by a namespace or with objects of that
class existing being marked live.

Perl 6: Roles pretty much are a Perl 6 thing, so the definition above contains
all that is needed. An open question is whether Parrot worry about collision
detection? For compile time composition that's easy to punt to the compiler;
for runtime composition, that's not so easy though.

=head2 Introspection (aka Reflection)

Perl 6: Reflection provides access to a list of methods that a class has, its
parent classes and the roles it does, as well as the name of the class and its
memory address. For methods, their name, signature, return type and whether
the method is declared multi are available.

.Net: Reflection provides access to a list of attributes and methods as well as
the name of the class and its parent. The types of attributes and signatures of
methods are also available.

=head2 Inner Classes

An inner class is essentially a class defined within a class. Therefore it has
access to things private to its outer class.

Perl 6: Inner classes are allowed, and may also be private.

.Net: Inner classes are allowed and may be private, public, protected or
internal.

=head2 Delegation

Delegation is where a method call is "forwarded" to another class. Parrot may
provide support for simple cases of it directly, or could just provide a "no
method matched" fallback method that the compiler fills out to implement the
delegation.

Perl 6: Delegation support is highly flexible, even allowing a regex to match
method names that should be delegated to a particular object. 

=head2 Prototype-based OO

Prototype-based OO has no classes. All objects are cloned from existing
objects and modified. Requires lightweight singleton creation, without a
needing separate class for every instance object. (Self, JavaScript, and
Io are examples of prototype-based 00.)

=head1 QUESTIONS

Should we have a super or next opcode?

=head1 NOTES

=head2 Interaction with PMCs

The interaction between objects and PMCs is currently underspecified.



=head2 Translation

The following list a set of languages, then within each language what the
Parrot term translates to.

=over 4

=item Python

=over 4

=item Attribute

A Python attribute maps to a Parrot property

=back

=item .NET

=over 4

=item Attribute

What .NET calls an attribute Parrot calls a property

=item Property

What .NET calls a property we call an attribute

=back

=item Generic Terminology

=over 4

=item Instance Variable

Instance Variables map to what we call attributes

=back

=back

=head1 ATTACHMENTS

None.

=head1 FOOTNOTES

None.

=head1 REFERENCES

None.

=cut

__END__
Local Variables:
  fill-column:78
End:
