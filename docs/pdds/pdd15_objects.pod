=head1 TITLE

Object and Class semantics for Parrot

=head1 VERSION

=head2 CURRENT

    Maintainer: Dan Sugalski
    Class: Internals
    PDD Number: 15
    Version: 1.2
    Status: Developing
    Last Modified: February 09, 2004
    PDD Format: 1
    Language: English

=head2 HISTORY

=over 4

=item Version 1.2

February 9, 2004

=item Version 1.1

March 11, 2002

=item version 1

None. First version

=back

=head1 CHANGES

=over 4

=item Version 1.2

A complete overhaul from the original spec.

=item Version 1.1

Removed attributes from the object interface and put them in the
class interface section, where they belong.

=item Version 1.0

None. First version

=back

=head1 ABSTRACT

This PDD describes the semantics of Parrot's object and class
systems. The PDD is divided into two parts, the semantics expressed
to user programs through PMCs, and the default back-end class scheme.

Note that the class system is I<not> the single mandated class
scheme, merely the one designed to express the semantics needed for
perl 6, ruby, and python. Alternate class systems are certainly
possible, and direct compatibility with the system as described here
isn't strictly necessary.

=head1 DESCRIPTION

This is a reasonably straightforward object system. It assumes that
objects have:

=over 4

=item *

An array of attributes. Note that attribute values are I<always> PMCs.

=item *

A parent class

=item *

A custom (though possibly class-wide) vtable

=back

and that you can:

=over 4

=item *

Call a method on an object

=item *

Get a method PMC for a method for an object (for deferred method calls)

=item *

Fetch the class for an object

=item *

Subclass an existing object (note that objects may not necessarily be
able to have their classes changed arbitrarily, but making a subclass
and moving the object to it is allowable)

=item *

Get an attribute by name or offset

=item *

Set an attribute by name or offset

=back

Additionally we assume that I<all> objects can have properties on
them, as all PMCs can have properties. The property get/set method may
be overridden on a per-class basis as any other vtable method may be.

For classes, we assume that:

=over 4

=item *

Classes have an associated namespace. (Which may be anonymous)

=item *

Classes have one or more immediate parent classes

=item *

Classes have a catalog of attribute names and offsets for all
attributes.

=item *

Classes have a list of interfaces they implement

=back

And we further assume that classes can:

=over 4

=item *

Instantiate an object of their class

=item *

Add parent classes

=item *

Remove parent classes

=item *

Add attributes

=item *

Remove attributes

=item *

Add interfaces

=item *

Remove interfaces

=back

This list is likely not definitive, but it's enough to start
with. It also doesn't address the semantics of method calls, which
need to be dealt with, possibly separately. With that in mind, the
object system supports these features with a combination of PMC
classes (not to be confused with object classes) and opcodes.

=head1 IMPLEMENTATION

There are four pieces to the object implementation. There are the PMCs
for the classes and objects, the opcodes the engine uses to do objecty
things, the specific vtable methods used to perform those objecty
things, and the supporting code provided by the interpreter engine to
do the heavy lifting.

Please note that Parrot, in general, does I<not> restrict operations
on objects and classes. If a language has restrictions on what can be
done with them, the language is responsible for making sure that
disallowed things do not happen. For example, Parrot permits multiple
inheritance, and will not stop code that adds a new parent to an
existing class. If a language doesn't allow for multiple inheritance
it must not emit code which would add multiple parents to a
class. (Parrot may, at some point, allow imposition of runtime
restrictions on a class, but currently it doesn't)

=head2 PMCs

There are two PMC classes, C<ParrotClass> and
C<ParrotObject>. ParrotObject PMCs are the actual objects, and
hold all the per-object instance data. ParrotClass PMCs hold all the
class-specific information. Instantiating a new OO class creates a new
ParrotClass PMC, and enters the new OO class into Parrot's PMC class
table, at which point it is indistinguishable from any other PMC
class. (This doesn't mean that non-ParrotClass things can be
subclassed or treated as an OO class. Neither is that forbidden. Just
unimplemented)

It's important to note that I<all> 'standard' classes are 
ParrotClass PMC instances, and I<all> 'standard' objects are 
ParrotObject PMCs. We do I<not> create a brand new PMC class for each
OO class, and they all share the ParrotClass or ParrotObject vtable,
respectively. This distinction is mostly an artifact of the
implementation, and may change in the future.

While the internals of the class and object PMCs should be considered
black boxes, here's some documentation as to what they are for
implementation purposes.

The ParrotClass PMC holds a 5 element array, which is:

=over 4

=item 0

An array PMC of the immediate parent classes

=item 1

The class name PMC

=item 2

An array of all parent PMCs, in search order

=item 3

The class attribute section hash. Keys are the class name in
language-defined format (so perl would be foo::bar, while java would
be some.damn.long.thing.with.dots), values are the integer offset from
the start of the attribute array where that class' attributes start.

=item 4

The class attribute name hash. Keys are the fully qualified attribute
names (in whatever format the language governing the class wants) and
the values are the offset from the beginning of the attribute array of
the particular attribute.

=back

Note that the attribute catalog holds I<all> the attributes for an
object. This includes the attributes in the object's class as well as
I<all> the attributes defined in all the parent classes. (Multiple
inheritance makes this necessary -- the offsets of a class' attributes
will change from child class to child class)

ParrotClass PMCs also have the "I am a class" flag set on them.

The ParrotObject PMC is an array of meta-information and
attributes. The elements of this array are:

=over 4

=item 0

The class PMC

=item 1

The class name PMC

=item 2+

The attributes for the object

=back

Note that ParrotObject PMCs also have the "I am an object" flag set on
them.

=head2 Opcodes

The following ops are provided to deal with objects. Please note that
method calls are governed by parrot's calling conventions, and as such
objects, method PMCs, return continuations, and parameters must be in
the right places, though some ops will put parameters where they need
to go.

=over 4

=item classoffset Ix, Py, Sz

Returns the offset of the first attribute for class Sz in object Py.

=item getattr Px, Py, Iz

Returns attribute Iz of object Py and puts it in Px. Note that the
attribute number is an absolute offset.

=item getattr Px, Py, Sz

Get the attribute with the fully qualified name Sz from object Py and
put it in Px.

=item setattr Px, Iy, Pz

Set the attribute Iy of object Px to Pz

=item setattr Px, Sy, Pz

Set the attribute of object Px with the fully qualified name Sy to Pz

=item fetchmethod Px, Py, Sz

Find the PMC for method Sz of object Py, and put it in Px. Note that how
the method PMC returned behaves if it goes out of scope or if the
class hierarchy changes or the method definitions change is entirely
up to the class that provides the PMC.

=item callmeth

=item callmeth Sz

call a method. If the method name is provided, we find the PMC for the named
method and put it in the sub/method slot. If no name is provided we
assume that all the calling conventions have already been set up and
the method PMC is already in the proper place.

=item callmethcc

=item callmethcc Sx

Make a method call, automatically generating a return continuation. If
a method name is passed in we look up the method PMC for the object
and put it in the method slot. If a method name isn't provided then we
assume that things are already properly set up.

=item tailcalmeth

=item tailcallmeth Sx

Make a tailcall to method Sx. If no method name is given, we assume
everything is already set up properly.

=item newclass Px, Sy

Create a new base class named Sy, and put the PMC for it in Px

=item subclass Px, Py, Sz

Create a new class, named Sz, which has Py as its immediate parent. 

=item addparent Px, Py

Add class Py to the end of the list of immediate parents of class
Px. Adds any attributes of Py (and its parent classes) that aren't
already in Px.

=item removeparent Px, Py

Remove class Py from the parent list of Px. All parent classes of Py
which aren't parent classes of what remains of Px's parent list are
removed, as are their attributes.

=item addattr Px, Sy, Sz

Add attribute Sy, with a fully-qualified name Sz, to class Px. This
will add the attribute slot to all objects of class Px and children of
class Px, with a default value of C<Null>.

=item removeattr Px, Sy, Sz

Remove the attribute Sy (fully qualified name Sz) from class Px, all
objects of class Px, and all objects of a child of class Px.

=item instantiate Px, Py, Sz

Instantiate a brand new class, based on the metadata in Py, named Sz. 

=back

=head2 Vtables

To make this work all PMCs must have the following vtable
entries. They may, for non-objects, throw an exception.

The catalog metadata for objects is considered to be attributes on the
class, so to get the offset for a class for an object, you fetch the
object's class then look up the offset attribute from it. (The class
attributes are detailed later) This is safe in general, since the only
code reasonably querying a class' attribute list is the class code
itself, and if a class doesn't know whether it's a ParrotClass-style
class or not you've got bigger problems.

=over 4

=item find_method(string *)

Returns the PMC for the named method. If no method of this name
exists, nor can be constructed, returns a Null PMC.

Note that for languages which support default fallback methods, such
as Perl 5's AUTOLOAD, this would be the place to return it if a normal
lookup fails.

=item isa(class *)

Returns true or false if the class passed in as a parameter is in the
inheritance hierarchy of the object.

=item can(string *)

Returns true or false if the object can perform the requested
method. (Including with an AUTOLOAD)

=item does(class *)

Returns true or false to note whether the object in question
implements the interface passed in.

=item getattr(int)

Returns the attribute at the passed-in offset for the object.

=item setattr(int, PMC *)

Sets the attribute for the passed-in offset to the passed-in PMC value

=item getclass

Returns the class PMC for the object.

=back

Currently Parrot only supports mutating a class' metainformation for
ParrotClass classes. This is a restriction which will be lifted at
some point soon.

=head2 Supporting code

Most of the supporting code is in the src/objects.c file.

=head1 What The Bytecode Sees

The bytecode is isolated from most of the internal details of the
implementation. This allows both for flexibility in the implementation
and forward compatibility, generally good things.

=head1 TRANSLATION AND GLOSSARY

Since every object system on the planet shares a common set of terms
but uses them completely differently, this section defines

=head2 Glossary

=over 4

=item Property

A name and value pair attached to a PMC. Properties may be attached to
the PMC in its role as a container or the PMC in its role as a value.

Properties are global to the PMC. That is there can only be one
property named "FOO" attached to a PMC, and it is globally visible to
all inspectors of the PMCs properties. They are I<not> restricted by
class.

Properties are generally assigned at runtime, and a particular
property may or may not exist on a PMC at any particular
time. Properties are not restricted to objects as such, and any PMC
may have a property attached to it.

=item Attribute

An attribute is a slot in an object that contains a value, generally a
PMC. (Containing non-PMCs leads to interesting garbage collection
issues at the moment) Attributes are referenced either
by slot number or by class name/attribute name pairs. (At least
conceptually)

Attributes are set on a class-wide basis, and all the objects of a
class will have the same set of attributes. Generally attributes
aren't added or removed from classes at runtime, as this would require
resizing and moving the elements of the attribute arrays of existing
objects, and potentially recompiling code with fixed attribute offsets
embedded in it. Most OO languages don't allow attribute changes to
existing classes, though parrot's base attribute system does allow
this.

=item Method

In its strictest sense, a method is a chunk of code that you call with
an object in the object slot of the calling conventions.

More generally, a method is some piece of code that you invoke by name
through an object. You call the object's "Invoke a method" vtable
entry, passing in the method name (Assuming we don't just get it from
the sub name register, per calling conventions). The object is then
responsible for doing something with the method being
requested. Presumably it calls the method, though this isn't strictly
required.

=item Delegate

An object that is transparently (to the user) embedded in another
object. Delegate objects are used in those cases where we can't
inherit from a class because the class is from a different object
universe.

As an example, assume you have a class A, which inherits from class
B. The classes are incompatible, so Parrot can't automatically meld B
into A, as it might if they were. When instantiating an object of
class A, Parrot will automatically instantiate an object of class B
and embed it in the object of class A. The object of class B is class
A's delegate--when a method call comes in that A can't handle, that
method call is delegated to B.

=item Parent class

Also called the super-class. The parent class is, in an inheritance
situation, the class being derived from. If A derives from B, B is the
parent class of A.

=item Child class

Also called the sub-class. The child class is, in an inheritance
situation, the class doing the deriving. If A derives from B, A is the
child class.

=back

=head2 Translation

The following list a set of languages, then within each language what
the parrot term translates to.

=over 4

=item Python

=over 4

=item Attribute

A Python attribute maps to a parrot property

=back

=item .NET

=over 4

=item Attribute

What .NET calls an attribute parrot calls a property

=item Property

What .NET calls a property we call an attribute

=back

=item Generic Terminology

=over 4

=item Instance Variable

Instance Variables map to what we call attributes

=back

=back

=head1 ATTACHMENTS

None

=head1 FOOTNOTES

=head1 REFERENCES
