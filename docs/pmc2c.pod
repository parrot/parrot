# Copyright (C) 2001-2012, Parrot Foundation.

=pod

=head1 NAME

docs/pmc2c.pod - The PMC definition to C compiler.

=head1 SYNOPSIS

To see the internal data structures please run:

    % perl tools/build/pmc2c.pl --c --debug --debug sarray.pmc | less

=head1 DESCRIPTION

This document covers the PMC definition to C compiler, I<i.e.>,
F<tools/build/pmc2c.pl>.

=head2 Compiling PMCs

First, the program determines the names of the .c and .h files from
the basename of the .pmc file (e.g. F<perlint.pmc> -> F<perlint.c> and
F<perlint.h>).

Next, the file is searched for C</pmclass \w*/> which attempts to find the
class being declared.

Once the class is found, all of its superclasses are scanned and their
methods added to the methods of the current PMC. PMCs default to
inheriting from 'default'. Only single inheritance is supported.

Once the superclass is determined, it is processed and its method names
are extracted and saved.

Next, each method body is processed with various directives (see below)
getting replaced by their appropriate values.

Finally, the .c and .h files are generated. The appropriate base class
header files are included.

If the C<no_init> flag was used, then no init function is generated.
Otherwise, one is generated which sets up the vtable and enters it into
the C<vtables> array.

The .c file is generated by appending the functions after the various
directives have been replaced.

=head2 PMC File Syntax

The basic syntax of a PMC file is

=over 4

=item 1.

A preamble, consisting of code to be copied directly to the .c file

=item 2.

The C<pmclass> declaration:

    pmclass PMCNAME [flags] {

where C<flags> are:

=over 4

=item C<extends PMCPARENT>

All methods not defined in PMCNAME are inherited from the PMCPARENT class.
If no parent class is defined, methods from F<default.pmc> are used.

=item C<abstract>

This class cannot be instantiated. Abstract classes are shown with lower
case class names in the class tree.

=item C<no_init>

Used with C<abstract>: No C<class_init> code is generated.

=item C<const_too>

Classes with this flag get 2 vtables and 2 enums, one pair with
read/write set methods, and one with read-only set methods.

=item C<does interface>

The class 'does' the given interfaces (the collection of methods
which the class implements).

The default is "scalar". Other currently used interfaces are:

    array    : container PMC with numerically-keyed elements
    event    : PMC that can be used with event queue
    hash     : container PMC with string-keyed elements
    library  : PMC that corresponds to a dynamic library
    ref      : PMC that references another PMC
    string   : PMC that behaves similarly to the base string type
    boolean  : PMC that does true/false only.
    integer  : PMC that behaves similarly to the base int type
    float    : PMC that behaves similarly to the base number type
    scalar   : (only used by the sample src/dynpmc/foo.pmc)

This is not a canonical list, but merely a snapshot of what's in use.

=item C<dynpmc>

The class is a dynamic class. These have a special C<class_init>
routine suitable for dynamic loading at runtime. See the F<src/dynpmc>
directory for an example.

=item C<group GROUP>

The class is part of a group of interrelated PMCs that should be
compiled together into a single shared library of the given name. Only
valid for dynamic PMCs.

=item C<lib LIB>

The class needs an external library.

=item C<hll HLL>

The High level language this PMC corresponds to.

=item C<maps Type>

The basic parrot PMC type that this PMC correspond to for C<.HLL>
usage. For example:

 pmclass TclInt hll Tcl maps Integer

allows this PMC to automatically be used when autoboxing C<I> registers to PMCs.

Requires the C<hll> flag. Note that multiple mappings can be specified:

 pmclass myOrderedHash hll frob maps Hash maps Array

=back

=item 3.

A list of attribute declarations:

  ATTR INTVAL id;

The ATTR declaration keyword is followed by the type of the attribute and the
name of the attribute. Any valid C type is a valid attribute type, but only
INTVAL, FLOATVAL, STRING *, and PMC * can be handled directly from PIR. Other
types are generally only used by low-level internal PMCs.

=item 4.

A list of vtable function implementations

=item 5.

The final close C<}>

=back

=head2 Method Body Substitutions

The vtable function bodies can use the following substitutions:

=over 4

=item C<SELF>

Converted to the current PMC object of type C<PMC *>.

=item C<INTERP>

Converted to the interpreter object.

=item C<OtherClass.SELF.method(a,b,c)>

Calls the static vtable or method 'method' in C<OtherClass>.

=item C<SELF.method(a,b,c)>

Calls the vtable or method 'method' using the dynamic type of C<SELF>.

=item C<SELF(a,b,c)>

Same as above, but calls the current method.

=item C<STATICSELF.method(a,b,c)>

Calls the vtable or method 'method' using the static type of C<SELF> (in
other words, calls another method defined in the same file).

=item C<OtherClass.SUPER(a,b,c)>

Calls the overridden implementation of the current method in
C<OtherClass>.

=item C<SUPER(a,b,c)>

Calls the overridden implementation of the current method in the nearest
superclass, using the type of C<SELF>.

=back

=head1 AUTHOR

Leopold Toetsch.

Cleaned up by Matt Diephouse.

Many thanks to the author of F<pmc2c.pl>, many useful code pieces got
reused.

=cut
