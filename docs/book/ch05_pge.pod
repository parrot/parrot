=pod

=head1 Grammar Engine

X<Parrot Grammar Engine> 
X<PGE (Parrot Grammar Engine)> 
The Parrot Grammar Engine (PGE) is a parser generator, one of the key
components of the Parrot Compiler Toolkit. It reads grammar files
written in the PGE rules format, and generates parser modules for the
syntax specified by those rules. PGE rules provide the full power of
recursive descent parsing and operator precedence parsing, but are
comfortably useful even if you don't know anything about parsing theory.
In the usual case, all you'll ever need to know is that rules are
patterns for matching text.

=head2 Grammars

A grammar is a collection of rules, in much the same way that a class is a
collection of methods.N<In fact, a grammar is just a special kind of class
and a rule is just a special kind of method.> Each rule defines a pattern for
matching one piece of text. The basic matching syntax for rules is likely to
be somewhat familiar to anyone who has worked with regular expressions.

  rule id { \d+ }

Larger rules are composed from smaller rules:

  rule record { <id> <name> <phone> }

And a grammar holds a group of rules that work together:

  grammar Contacts;

  rule name { 'John' | 'Bob ' | 'Fred' }

  rule id   { \d+ }

  rule record { <id> <name> }

  ...

=head3 Rules and Tokens

There are two different kinds of rules, each declared with a different keyword:
C<rule> or C<token>. A C<rule> does smart whitespace matching between the
various pieces of the pattern. So, the C<record> rule above would match
"6355 John" or "6355      John" but not "6355John".

A C<token> only matches whitespace if you specifically request it. To get the
same effect with a token, you'd have to add a C<\s> pattern to the rule:

  token record { <id> \s+ <name> }

=head3 The Start Rule

A recursive descent parser is a top-down parser. This means it starts at the
highest-level rule and works its way down through individual rules to match
an entire string or file. In PGE, this top-level rule is called C<TOP> by
convention.N<In "real" Perl 6, the top-level rule can be called anything.
However, some of the PCT compiler tools expect it to be called C<TOP>.
Compilers written with PCT should just use the name C<TOP> for all top-level
tokens.>

  rule TOP { <record> }

This rule matches a single record in a string or file. Once the parser has
matched the entire string or file passed to the start rule, the parse is
considered successful and a raw parse tree is returned.

=head3 Testing a Grammar

You might want to try out the examples in this chapter as you read along.
To compile the following simple example, save it to a file called
F<Contacts.pg>:

  grammar Contacts is PGE::Grammar;
  rule  TOP    { <record> }
  rule  record { <id> <name> }
  token name   { 'John' | 'Bob ' | 'Fred' }
  token id     { \d+ }

Then compile the grammar with the following command:

  $ parrot Perl6Grammar.pbc --output=Contacts.pir Contacts.pg

The path to F<parrot> and to the F<Perl6Grammar.pbc> file will vary on
different systems. If you compiled Parrot from source, it will be:

  $ ./parrot runtime/parrot/library/PGE/Perl6Grammar.pbc \
        --output=Contacts.pir Contacts.pg

Next, create a small PIR script to run your grammar. You can save it as
F<grammar_test.pir>.

  .sub main :main
      load_bytecode 'PGE.pbc'        # load some required modules
      load_bytecode 'dumper.pbc'
      load_bytecode 'PGE/Dumper.pbc'

      load_bytecode 'Contacts.pir'   # load your grammar

      .local string source
      .local pmc top, grammar, match

      source = "3 John"
      top = get_hll_global ['Contacts'], 'TOP'
      grammar = get_class 'Contacts'
      match = top(source, 'grammar' => grammar)
      _dumper(match, "match")
  .end

Now, you can run the test script with this command:

  $ parrot grammar_test.pir

It will print out a text representation of the raw parse tree stored in the
C<match> variable:

  "match" => PMC 'Contacts' => "3 John" @ 0 {
      <record> => PMC 'Contacts' => "3 John" @ 0 {
          <id> => PMC 'Contacts' => "3" @ 0
          <name> => PMC 'Contacts' => "John" @ 2
      }
  }

Each rule in the grammar corresponds to a node in the tree. This output shows
that the top-level match variable contains one child named "record", that
"record" contains two children named "id" and "name", and that "id" contains
the number 3, and "name" contains the string "John". Exactly what we would
expect from our simple grammar.

=head2 Rule Syntax

Every language has a set of basic components (words or parts of words)
and syntax conventions for combining them. The "words" in rules are
literal characters or symbols, some X<metacharacters> metacharacters
(or metasymbols),  and X<rules;escape sequences>X<escape sequences,
rules> escape sequences, while the combining syntax includes other
metacharacters, X<quantifiers, rules> X<rules;quantifiers> quantifiers,
bracketing characters, and assertions.

=head3 Metacharacters

The C<.> matches any single character, even a newline character. The C<^> and
C<$> metacharacters are zero-width matches on the beginning and end of a
string. They each have doubled alternates C<^^> and C<$$> that match at the
beginning and end of every line within a string.

The C<|>, C<&>, C<\>, C<#>, and C<:=> metacharacters are all syntax
structure elements. The C<|> is an alternation between two options. The
C<&> matches two patterns simultaneously (the patterns must be the same
length). The C<\> turns literal characters into metacharacters (the
escape sequences). The C<#> marks a comment to the end of the line. You can
start a comment at any point on any line in a rule. The C<:=> binds a
hypothetical variable to the result of a subrule or grouped pattern.
Hypotheticals are covered in L<Hypothetical Variables> later in this chapter.

The metacharacters C<()>, C<[]>, C<{}> and C<E<lt>E<gt>> are bracketing
pairs. The pairs always have to be balanced within the rule, unless they
are literal characters (escaped with a C<\>). The C<()> and C<[]> pairs
group patterns to match as a single atom. They're often used to
capture a result, mark the boundaries of an alternation, or mark a group
of patterns with a quantifier. Parentheses C<()> are
capturing and square brackets C<[]> are non-capturing. The C<{}>
brackets define a section of code (a closure) within a rule. These
closures are always a successful zero-width match. The C<E<lt>...E<gt>> brackets
mark assertions, which handle a variety of constructs including
character classes and user-defined quantifiers. Assertions are covered
in L<Assertions> later in this chapter.

Table 7-2 summarizes the basic set of metacharacters.

=begin table picture Metacharacters

Z<CHP-7-TABLE-2>

=headrow

=row

=cell Symbol

=cell Meaning

=bodyrows

=row

=cell C<.>

=cell Match any single character, including a newline.
X<. (dot);. match single character (rules)>

=row

=cell C<^>

=cell Match the beginning of a string.
X<^ (caret);^ beginning of string (rules)>

=row

=cell C<$>

=cell Match the end of a string.
X<$ (dollar sign);$ end of string (rules)>

=row

=cell C<^^>

=cell Match the beginning of a line.
X<^ (caret);^^ beginning of line (rules)>

=row

=cell C<$$>

=cell Match the end of a line.
X<$ (dollar sign);$$ end of line (rules)>

=row

=cell C<|>

=cell Match alternate patterns (OR).

=row

=cell C<&>

=cell Match multiple patterns (AND).

=row

=cell C<\>

=cell Escape a metacharacter to get a literal character, or escape a
literal character to get a metacharacter.
X<\ (backslash);\ escape sequences (rules)>
X<\ (backslash);\ to escape metacharacters (rules)>

=row

=cell C<#>

=cell Mark a comment (to the end of the line).

=row

=cell C<:=>

=cell Bind the result of a match to a hypothetical variable.
X<: (colon);:= (binding);in rules>

=row

=cell C<(...)>

=cell Group patterns and capture the result.

=row

=cell C<[...]>

=cell Group patterns without capturing.

=row

=cell C<{...}>

=cell Execute a closure (Perl 6 code) within a rule.

=row

=cell C<E<lt>...E<gt>>

=cell Match an assertion.

=end table


=head3 Escape Sequences

Z<CHP-7-SECT-2.2>

X<escape sequences, rules>
X<rules;escape sequences>
X<\ (backslash);\ escape sequences (rules)>
The escape sequences are literal characters acting as metacharacters,
marked with the C<\> escape. Some escape sequences represent single
characters that are difficult to represent literally, like C<\t> for
tab, or C<\x[...]> for a character specified by a hexadecimal number.
Some represent limited character classes, like C<\d> for digits or C<\w>
for word characters. Some represent zero-width positions in a match,
like C<\b> for a word boundary. With all the escape sequences that use
brackets, C<()>, C<{}>, and C<E<lt>E<gt>> work in place of C<[]>.

X<variable interpolation in rules>
X<rules;variable interpolation>
Note that since an ordinary variable now interpolates as a literal
string by default, the C<\Q> escape sequence is rarely needed.

A<CHP-7-TABLE-3>Table 7-3 shows the escape sequences for rules.

=begin table picture Escape sequences

Z<CHP-7-TABLE-3>

=headrow

=row

=cell Escape

=cell Meaning

=bodyrows

=row

=cell C<\0[...]>

=cell Match a character given in octal (brackets optional).

=row

=cell C<\b>

=cell Match a word boundary.

=row

=cell C<\B>

=cell Match when not on a word boundary.

=row

=cell C<\c[...]>

=cell Match a named character or control character.

=row

=cell C<\C[...]>

=cell Match any character except the bracketed named or control character.

=row

=cell C<\d>

=cell Match a digit.

=row

=cell C<\D>

=cell Match a non-digit.

=row

=cell C<\e>

=cell Match an escape character.

=row

=cell C<\E>

=cell Match anything but an escape character.

=row

=cell C<\f>

=cell Match the form feed character.

=row

=cell C<\F>

=cell Match anything but a form feed.

=row

=cell C<\n>

=cell Match a (logical) newline.

=row

=cell C<\N>

=cell Match anything but a (logical) newline.

=row

=cell C<\h>

=cell Match horizontal whitespace.

=row

=cell C<\H>

=cell Match anything but horizontal whitespace.

=row

=cell C<\L[...]>

=cell Everything within the brackets is lowercase.

=row

=cell C<\Q[...]>

=cell All metacharacters within the brackets match as literal characters.

=row

=cell C<\r>

=cell Match a return.

=row

=cell C<\R>

=cell Match anything but a return.

=row

=cell C<\s>

=cell Match any whitespace character.

=row

=cell C<\S>

=cell Match anything but whitespace.

=row

=cell C<\t>

=cell Match a tab.

=row

=cell C<\T>

=cell Match anything but a tab.

=row

=cell C<\U[...]>

=cell Everything within the brackets is uppercase.

=row

=cell C<\v>

=cell Match vertical whitespace.

=row

=cell C<\V>

=cell Match anything but vertical whitespace.

=row

=cell C<\w>

=cell Match a word character (Unicode alphanumeric plus "_").

=row

=cell C<\W>

=cell Match anything but a word character.

=row

=cell C<\x[...]>

=cell Match a character given in hexadecimal (brackets optional).

=row

=cell C<\X[...]>

=cell Match anything but the character given in hexadecimal (brackets
optional).

=end table

=head3 Quantifiers

Z<CHP-7-SECT-2.3>

Quantifiers specify the number of times an atom (a single character,
metacharacter, escape sequence, grouped pattern, assertion, etc) will
match.

X<. (dot);.. (range);quantifier (rules)>
X<. (dot);... (infinite range);quantifier (rules)>
The numeric quantifiers use assertion syntax. A single number
(C<E<lt>3E<gt>>) requires exactly that many matches. A numeric range
quantifier (C<E<lt>3C<..>5E<gt>>) succeeds if the number of matches is
between the minimum and maximum numbers. A range with three trailing
dots (C<E<lt>2...E<gt>>) is shorthand for C<E<lt>R<n>..InfE<gt>> and
matches as many times as possible.

Each quantifier has a minimal alternate form, marked with a trailing
C<?>, that matches the shortest possible sequence first.


A<CHP-7-TABLE-4>Table 7-4 shows the built-in
X<quantifiers, rules> X<rules;quantifiers> quantifiers.

=begin table picture Quantifiers

Z<CHP-7-TABLE-4>

=headrow

=row

=cell Maximal

=cell Minimal

=cell Meaning

=bodyrows

=row

=cell C<*>

=cell C<*?>

=cell Match 0 or more times.

=row

=cell C<+>

=cell C<+?>

=cell Match 1 or more times.

=row

=cell C<?>

=cell C<??>

=cell Match 0 or 1 times.

=row

=cell C<E<lt>>R<n>C<E<gt>>

=cell C<E<lt>>R<n>C<E<gt>?>

=cell Match exactly R<n> times.

=row

=cell C<E<lt>>R<n>C<..>R<m>C<E<gt>>

=cell C<E<lt>>R<n>C<..>R<m>C<E<gt>?>

=cell Match at least R<n> and no more than R<m> times.

=row

=cell C<E<lt>>R<n>C<...E<gt>>

=cell C<E<lt>>R<n>C<...E<gt>?>

=cell Match at least R<n> times.

=end table


=head3 Assertions

Z<CHP-7-SECT-2.4>

X<assertions, rules>
X<rules;assertions>
In general, an assertion simply states that some condition or state is
true and the match fails when that assertion is false. Many different
constructs with many different purposes use assertion syntax.

X<variable interpolation in rules>
X<rules;variable interpolation>
Assertions match named and anonymous rules, arrays or hashes containing
anonymous rules, and subroutines or closures that return anonymous
rules. You have to enclose a variable in assertion delimiters to get it
to interpolate as an anonymous rule or rules. A bare scalar in a pattern
interpolates as a literal string, while a scalar variable in assertion
brackets interpolates as an anonymous rule. A bare array in a pattern
matches as a series of alternate literal strings, while an array in
assertion brackets interpolates as a series of alternate anonymous
rules. In the simplest case, a bare hash in a pattern matches a word
(C<\w+>) and tries to find that word as one of its keys.N<The effect is
much as if it matched the keys as a series of alternates, but you're
guaranteed to match the longest possible key, instead of just the first
one it hits in random order.>, while a hash in assertion brackets does
the same, but then also matches the associated value as an anonymous
rule.

X<fail keyword>
A bare closure in a pattern always matches (unless it calls C<fail>),
but a closure in assertion brackets C<E<lt>{...}E<gt>> must return an
anonymous rule, which is immediately matched.

An assertion with parentheses C<E<lt>(...)E<gt>> is similar to a bare
closure in a pattern in that it allows you to include straight Perl code
within a rule. The difference is that C<E<lt>(...)E<gt>> evaluates the
return value of the closure in boolean context. The match succeeds if
the return value is true and fails if the return value is false.

Assertions match character classes, both named and enumerated. A named
rule character class is often more accurate than an enumerated character
class. For example, C<E<lt>[a-zA-Z]E<gt>> is commonly used to match
alphabetic characters, but generally what's really needed is the
built-in rule C<E<lt>alphaE<gt>> which matches the full set of Unicode
alphabetic characters.

A<CHP-7-TABLE-5>Table 7-5 shows the syntax for assertions.

=begin table picture Assertions

Z<CHP-7-TABLE-5>

=headrow

=row

=cell Syntax

=cell Meaning

=bodyrows

=row

=cell C<E<lt>...E<gt>>

=cell Generic assertion delimiter.

=row

=cell C<E<lt>!...E<gt>>

=cell Negate any assertion.

=row

=cell C<E<lt>>R<name>C<E<gt>>

=cell Match a named rule or character class.

=row

=cell C<E<lt>[...]E<gt>>

=cell Match an enumerated character class.

=row

=cell C<E<lt>-...E<gt>>

=cell Complement a character class (named or enumerated).

=row

=cell C<E<lt>"..."E<gt>>

=cell Match a literal string (interpolated at match time).

=row

=cell C<E<lt>'...'E<gt>>

=cell Match a literal string (not interpolated).

=row

=cell C<E<lt>(...)E<gt>>

=cell Boolean assertion. Execute a closure and match if it returns a true
result.

=row

=cell C<E<lt>$scalarE<gt>>

=cell Match an anonymous rule.

=row

=cell C<E<lt>@arrayE<gt>>

=cell Match a series of anonymous rules as alternates.

=row

=cell C<E<lt>%hashE<gt>>

=cell Match a key from the hash, then its value (which is an anonymous
rule).

=row

=cell C<E<lt>E<amp>sub()E<gt>>

=cell Match an anonymous rule returned by a sub.

=row

=cell C<E<lt>{>R<code>C<}E<gt>>

=cell Match an anonymous rule returned by a closure.

=row

=cell C<E<lt>.E<gt>>

=cell Match any logical grapheme, including combining character sequences.

=end table


=head3 Modifiers

Z<CHP-7-SECT-2.5>

X<modifiers>
X<: (colon);: modifier delimiter in rules>
Modifiers alter the meaning of the pattern syntax. The standard
position for modifiers is at the beginning of the rule, right after
the C<m>, C<s>, or C<rx>, or after the name in a named rule. Modifiers
cannot attach to the outside of a bare C</.../>. For example:

  m:i/marvin/ # case insensitive
  rule names :i { marvin | ford | arthur }

The single-character modifiers can be grouped, but the others must be
separated by a colon:

  m:wig/ zaphod /                        # OK
  m:words:ignorecase:globally / zaphod / # OK
  m:wordsignorecaseglobally / zaphod /   # Not OK

Most of the modifiers can also go inside the rule, attached to the
rule delimiters or to grouping delimiters. Internal modifiers are
lexically scoped to their enclosing delimiters, so you get a temporary
alteration of the pattern:

  m/:w I saw [:i zaphod] / # only 'zaphod' is case insensitive

The repetition modifiers (C<:R<N>x>, C<:R<N>th>, C<:once>,
C<:globally>, and C<:exhaustive>) and the continue modifier (C<:cont>)
can't be lexically scoped, because they alter the return value of the
entire rule.

The C<:R<N>x> modifier matches the rule a counted number of times. If
the modifier expects more matches than the string has, the match fails.
It has an alternate form C<:x(R<N>)> that can take a variable in place
of the number.

The C<:once> modifier on a rule only allows it to match once. The rule
will not match again until the you call the C<.reset> method on the rule
object.

The C<:globally> modifier matches as many times as possible. The
C<:exhaustive> modifier also matches as many times as possible, but in
as many different ways as possible.

The C<:R<N>th> modifier preserves one result from a particular counted
match. If the rule matches fewer times than the modifier expects, the
match fails. It has several alternate forms. One form--C<:th(R<N>)>--can
take a variable in place of the number. The other forms--C<:R<N>st>,
C<:R<N>nd>, and C<:R<N>rd>--are for cases where it's more natural to
write C<:1st>, C<:2nd>, C<:3rd> than it is to write C<:1th>, C<:2th>,
C<:3th>. Either way is valid, so pick the one that's most comfortable
for you.

By default, rules ignore literal whitespace within the pattern.  The
C<:w> modifier makes rules sensitive to literal whitespace, but in an
intelligent way. Any cluster of literal whitespace acts like an explicit
C<\s+> when it separates two identifiers and C<\s*> everywhere else.

There are no modifiers to alter whether the matched string is treated as
a single line or multiple lines. That's why the "beginning of string"
and "end of string" metasymbols have "beginning of line" and "end of
line" counterparts.

A<CHP-7-TABLE-6>Table 7-6 shows the current list of modifiers.

=begin table picture Modifiers

Z<CHP-7-TABLE-6>

=headrow

=row

=cell Short

=cell Long

=cell Meaning

=bodyrows

=row

=cell C<:i>

=cell C<:ignorecase>

=cell Case-insensitive match.

=row

=cell C<:I>

=cell

=cell Case-sensitive match (on by default).

=row

=cell C<:c>

=cell C<:cont>

=cell Continue where the previous match on the string left off.

=row

=cell C<:w>

=cell C<:words>

=cell Literal whitespace in the pattern matches as C<\s+>
or C<\s*>.

=row

=cell C<:W>

=cell

=cell Turn off intelligent whitespace matching (return to default).

=row

=cell

=cell :R<N>C<x>/C<:x(>R<N>C<)>

=cell Match the pattern R<N> times.

=row

=cell

=cell C<:>R<N>C<th>/C<:nth(>R<N>C<)>

=cell Match the R<N>th occurrence of a pattern.

=row

=cell

=cell C<:once>

=cell Only match the pattern once.

=row

=cell C<:g>

=cell C<:globally>

=cell Match the pattern as many times as possible, but only possibilities
that don't overlap.

=row

=cell C<:e>

=cell C<:exhaustive>

=cell Match every possible occurrence of a pattern, even overlapping
possibilities.

=row

=cell

=cell C<:u0>

=cell . is a byte.

=row

=cell

=cell C<:u1>

=cell . is a Unicode codepoint.

=row

=cell

=cell C<:u2>

=cell . is a Unicode grapheme.

=row

=cell

=cell C<:u3>

=cell . is language dependent.

=row

=cell

=cell C<:p5>

=cell The pattern uses Perl 5 regex syntax.

=end table


=head3 Built-in Rules

Z<CHP-7-SECT-3>

X<rules;built-in>
A number of named rules are provided by default, including a complete
set of X<POSIX-style classes> POSIX-style classes, and X<Unicode
property classes> Unicode property classes. The list isn't fully
defined yet, but A<CHP-7-TABLE-7>Table 7-7 shows a few you're
likely to see.

The C<E<lt>nullE<gt>> rule matches a zero-width string (so it's always
true) and C<E<lt>priorE<gt>> matches whatever the most recent successful
rule matched. These replace the two behaviors of 
X</ (slash);// invalid null pattern>
X<invalid null pattern //> the Perl 5 null pattern C<//>,
which is no longer valid syntax for rules. 

=begin table picture Built-in rules

Z<CHP-7-TABLE-7>

=headrow 

=row 

=cell Rule

=cell Meaning

=bodyrows 

=row 

=cell C<E<lt>alphaE<gt>>

=cell Match a Unicode alphabetic character.

=row 

=cell C<E<lt>digitE<gt>>

=cell Match a Unicode digit.

=row 

=cell C<E<lt>spE<gt>>

=cell Match a single space character (the same as C<\s>).

=row 

=cell C<E<lt>wsE<gt>>

=cell Match any whitespace (the same as C<\s+>).

=row 

=cell C<E<lt>nullE<gt>>

=cell Match the null string.

=row 

=cell C<E<lt>priorE<gt>>

=cell Match the same thing as the previous match.

=row 

=cell C<E<lt>before ...E<gt>>

=cell Zero-width lookahead. Assert that you're I<before> a pattern.

=row 

=cell C<E<lt>after ...E<gt>>

=cell Zero-width lookbehind. Assert that you're I<after> a pattern.

=row 

=cell C<E<lt>prop ...E<gt>>

=cell Match any character with the named property.

=row 

=cell C<E<lt>replace(...)E<gt>>

=cell Replace everything matched so far in the rule or subrule with the
given string (under consideration).

=end table


=head3 Backtracking Control

Z<CHP-7-SECT-4>

X<backtracking controls>
X<fail keyword> 
Backtracking is triggered whenever part of the pattern fails to match.
You can also explicitly trigger backtracking by calling the C<fail>
function within a closure. A<CHP-7-TABLE-8>Table 7-8 shows some
metacharacters and built-in rules relevant to backtracking.

=begin table picture Backtracking controls

Z<CHP-7-TABLE-8>

=headrow 

=row 

=cell Operator

=cell Meaning

=bodyrows 

=row 

=cell C<:>

=cell Don't retry the previous atom, fail to the next
earlier atom.
X<: (colon);: fail to atom before last (rules)>
X<backtracking controls;: fail to atom before last>

=row 

=cell C<::>

=cell Don't backtrack over this point, fail out of the closest
enclosing group (C<(...)>, C<[...]>, or the rule delimiters).
X<: (colon);:: fail out of group (rules)>
X<backtracking controls;: fail out of group>

=row 

=cell C<:::>

=cell Don't backtrack over this point, fail out of the
current rule or subrule.
X<: (colon);::: fail out of rule (rules)>
X<backtracking controls;: fail out of rule>

=row 

=cell C<E<lt>commitE<gt>>

=cell Don't backtrack over this point, fail out of the
entire match (even from within a subrule).

=row 

=cell C<E<lt>cutE<gt>>

=cell Like C<E<lt>commitE<gt>>, but also cuts the string matched. The
current matching position at this point becomes the new beginning of
the string.

=end table


=head3 Calling Actions

Once the parser has matched the entire input N<a
source code file, or a line of input at the terminal in interactive
mode> the parse is considered successful and the generated AST is
delivered to the code generator for conversion into PIR.


We haven't covered actions yet, but it's still important now to talk
about how we will call them when we are ready. We call an action
by inserting the C<{*}> token into the rule. When the C<{*}> rule is
encountered, PGE calls the associated action method with the current
match object as an argument. Let's take our C<persons_name> rule
from above, and sprinkle liberally with action calls:

 rule persons_name {
    {*} <first_name> {*} <last_name> {*}
 }

The first call to the action method contains an empty match object
because the parser hasn't had a chance to match anything yet. The
second call contains only the first name of the match. The third and
final call contains both the matched first and last name. Notice that
if the match fails halfway through, we still call the actions where
we succeeded, but do not call the actions after the failure. So, if
we try to match the string "Leia", the action is called before the
name and after the first name. When the rule tries to match the last
name, it fails because no last name is provided, and the third action
method call is never made.

=head3 Alternations and Keys

In addition to sub-rules, groups, and quantifiers, we also are able to
take alternations between options that are either-or. The vertical bar
token "|" can be used to distinguish between options where only one
may match, Here's an example:

 rule hero {
    ['Luke' | 'Leia'] 'Skywalker'
 }

This rule will match either "Luke Skywalker" or "Leia Skywalker" but
won't match "Luke Leia Skywalker" N<or anything else, for that matter>.
With things like alternations, if we want to call an action method it's
helpful to distinguish which combination we matched:

 rule hero {
    [
      'Luke' {*}    #= Luke
    | 'Leia' {*}    #= Leia
    ]
    'Skywalker'
 }

This is the same rule, except now it passes two arguments to its
action method: the match object and the name of the person who
got matched.

=head3 Warning: Left Recursion

Getting into all the nitty-gritty theory behind parsers is well beyond
the scope of this book. However, there is one potential pitfall that
developers should be made aware of that is not immediately obvious.
Like functions in ordinary procedural or functional languages, the
methods in the PGE parser grammar can call themselves recursively.
Consider the following rules derived in part from the grammar for the
C programming language:

 rule if_statement {
    'if' <condition> '{' <statement>* '}' <else_block>?
 }

 rule statement {
    <if_statement> | <expression>
 }

 rule else_block {
    'else' '{' <statements>* '}'
 }

Notice that an C<if_statement> can contain a list of C<statement>s, and
that each statement may itself be an C<if_statement>? This is called
I<recursion> X<Recursion>, and is part of where the "Recursive Descent"
algorithm gets its name from.

Now, let's look at a more direct example of a comma-separated list of
integer digits to form an array. We can define this recursively as
follows:

 rule list {
     <list> ',' <digit> | <digit>
 }

The intention is that if there is only one digit, we match the second
option in the alternation, and if there are more digits we can match
them recursively in the first alternation. However, take a close look
at the insidious result. The recursive descent parser enters the C<list>
rule. It's first option is to enter the list rule again, so it does.
Recursive descent is a depth-first algorithm, and it will continue to
descent down a particular path until it finds a successful match or a
match failure. In this case, it matches C<list> and then it matches
C<list> again, then it matches C<list> again, and so on and so forth.
What we have created is an infinite loop pattern called I<left recursion>.

Left recursion is caused when the left-most item of the left-most
alternation is a recursion. The rule above can be easily resolved
by writing:

 rule list {
    <digit> | <list> ',' <digit>
 }

Or even

 rule list {
    <digit> ',' <list> | <digit>
 }

Both of these two options make sure the left-most item in our rule is not
a recursion, therefore preventing left recursion.

Here is a more tricky example where the left recursion is hidden from
view:

 rule term {
    <expression> '*' <term> | <digit>
 }

 rule expression {
    <term> '+' <expression> | <term>
 }

This is a very limited subset of mathematical equations that we might like
to write, and even in this small subset we have this same problem: To
match a C<term>, the parser first tries to match an C<expression>, which
in turn matches a C<term> and then an C<expression> ...

Left recursion is not the only problem you can run into with a recursive
descent grammar, but it's one that's likely going to come up relatively
often for new language designers, and one that is not always likely to
generate useful error messages.

=head3 Operator Precedence Parser

Places where there are lots of little tokens in a statement, and where
there are lots of possible options that a top-down parser will have to
attempt can become relatively inefficient using PCT's recursive descent
parser. Specifically, mathematical expressions are very open-ended and
have forms that are difficult to anticipate. Consider the expression:

 a + b * c + d

The recursive descent parser is going to have to recognize through
significant trial and error how this statement should be parsed. For tasks
like this, recursive descent parsers are not ideal, although a type of
bottom-up parser called an I<operator precedence>
X<Parser, Operator precedence> parser is. Operator precedence parsers
work similarly to more versatile bottom-up parsers such as Lex or Yacc, but
are optimized for use with expressions and equations. The "things" in an
equation are split into two subtypes: I<terms> and I<operators>. Operators
themselves are split into a number of types including prefix (C<-a>),
postfix (C<i++>), infix (C<x + y>), circumfix (C<[z]>), postcircumfix
(C<a[b]>), and list (C<1, 2, 3>). Each operator gets its own precedence
number that specifies how closely it binds to the terms. In the example above,
the expression is parsed

 a + (b * c) + d

This is because the C<*> operator has a higher precedence and therefore binds
more tightly then the C<+> operator.

To switch from the top-down recursive descent parser to the bottom-up
operator precedence parser, a rule must be defined that is an C<optable>
X<Parser, optable>:

 rule expression is optable { ... }

The C<...> ellipses aren't an editorial shortcut, it's the Perl 6 operator
that is used to define a function signature. The C<...> indicates that
this is just a signature and that the actual guts of it will be filled in
somewhere else. In this case, that "somewhere else" is in the definition of
the optable role.

=head3 Protofunction Definitions

Protofunctions are used to define operators in the optable in the same way that
rules and tokens are used throughout the rest of the grammar. A proto is a way
of saying that the rule is overridable dynamically, and that it might be defined
somewhere else. In this case, PCT takes information from the proto declaration
and fills in the details for us. On another note, this also means that the HLL
itself can modify its own grammar at run time, by overriding the proto
definitions for its operator table. Some languages call this process "operator
overloading".

A proto is defined like this, taking some of our grammar rules above:

 'proto' <proto_name> [ 'is' <property> ] '{' '...' '}'

The name of the operator, listed as C<< <proto_name> >> above, contains both a
location part and an identifier part. The location is one of the places where
the operator can be located, such as infix, postfix, prefix, circumfix, and
postcircumfix. The name of the operator is the symbol used for the operator in
any of the quotes that Perl 6 understands:

 proto infix:<+>                  # a + b
 proto postfix:'--'               # i--
 proto circumfix:«<>»             # <x>

The C<is> X<Parser, is> keyword defines a property of the rule. Some examples of
this are:

 is precedence(1)     # Specifies an exact precedence
 is equiv('+')        # Has the same precedence as the "+" operator
 is assoc('right')    # Right associative. May also be "left" or "list"
 is pirop('add')      # Operands are passed to the PIR operator "and"
 is subname('mySub')  # Operands are passed to the function "mySub"
 is pasttype('if')    # Operands are passed as children to an "if" PAST node in
                      # the parse tree
 is parsed(&myRule)   # The token is parsed and identified using the rule
                      # "myRule" from the top-down parser

Protofunction definitions are function signatures which can be overridden via
multimethod dispatch. This means functions can be written I<with the same name>
as the rule to implement the behavior of the operator:

 rule infix:"+" { ... }

And in a PIR file for built-in functions:

 .sub 'infix:+'
    .param pmc a
    .param pmc b
    .local pmc c
    c = a + b
    .return(c)
 .end

The question to ask then is "Why have an C<is subname()> property, if all
operators can be defined as subroutines?" The answer is that using the
C<is subname()> property allows PCT to call a subroutine of a different
name then the operator. This is a good idea if there is already a built-in
function in the language that duplicates the functionality of the operator.
There is no sense duplicating functionality, is there?

The great thing about protos being overloadable is that you can specify
different functions to call with different signatures:

 .sub 'infix:+' :multi('Integer', 'Integer')
    ...
 .end

 .sub 'infix:+' :multi('CLispRatio', 'Number')
    ...
 .end

 .sub 'infix:+' :multi('Perl6Double', 'PythonInteger')
    ...
 .end

This list can be a bit intimidating, and it's hard to imagine that it would
be necessary to write up a new function to handle addition between
every conceivable pair of operands. Fortunately for us all, this isn't the
case because all these data types have those VTABLE interfaces that we can
use. For most data types Parrot already has basic arithmetic operations
built in, and it's only necessary to override for those data types with
special needs. This example was only a demonstration of the flexibility
of the method.


=head3 Hypothetical Variables

Z<CHP-7-SECT-5>

X<variables;hypothetical>
X<hypothetical variables>
X<rules;captures>
Hypothetical variables are a powerful way of building up data structures
from within a match. Ordinary captures with C<()> store the result of
the captures in C<$1>, C<$2>, etc. The values stored in these variables
will be kept if the match is successful, but thrown away if the match
fails (hence the term "hypothetical"). The numbered capture variables
are accessible outside the match, but only within the immediate
surrounding lexical scope:

  "Zaphod Beeblebrox" ~~ m:w/ (\w+) (\w+) /;
  
  print $1; # prints Zaphod

You can also capture into any user-defined variable with the binding
operator C<:=>. These variables must already be defined in the lexical
scope surrounding the rule:

  my $person;
  "Zaphod's just this guy." ~~ / ^ $person := (\w+) /;
  print $person; # prints Zaphod

Repeated matches can be captured into an array:

  my @words;
  "feefifofum" ~~ / @words := (f<-[f]>+)* /;
  # @words contains ("fee", "fi", "fo", "fum")

Pairs of repeated matches can be captured into a hash:

  my %customers;
  $records ~~ m:w/ %customers := [ E<lt>idE<gt> = E<lt>nameE<gt> \n]* /;

If you don't need the captured value outside the rule, use a C<$?>
variable instead. These are only directly accessible within the rule:

  "Zaphod saw Zaphod" ~~ m:w/ $?name := (\w+) \w+ $?name/;

A match of a named rule stores the result in a C<$?> variable with the
same name as the rule. These variables are also accessible only within
the rule:

  "Zaphod saw Zaphod" ~~ m:w/ E<lt>nameE<gt> \w+ $?name /;


When a rule matches a sequence of input tokens, an associated method
in NQP is called to convert that match into an AST node. This node
is then inserted into the I<parse tree>.

=head3 Basic Rules

Let's start off with a simple rule:

 rule persons_name {
    <first_name> <last_name>
 }

We also define the two name tokens as:

 token first_name { <alpha>+ }
 token last_name { <alpha>+ }

The special token C<< <alpha> >> is a built-in construct that only
accepts upper case and lower case letters. The "+" after the
C<< <alpha> >> tag is a short way of saying "one or more". Our rule
C<persons_name> would match something like C<Darth Vader> N<Actually,
it matches a lot of things that aren't people's names>but wouldn't
match something like C<C 3P0>. Notice that the rule above would match
C<Jar Jar Binks>, but not the way you would expect: It would match the
first "Jar" as C<< <first_name> >> and the second "Jar" as
C<< <last_name> >> and wouldn't match "Binks" at all.

this example shows another new construct, the square brackets. Square
brackets are ways to group things together. The star at the end means
that we take all the things inside the brackets zero or more times.
This is similar to the plus, except the plus matches one or more times.
Notice, however, that the above rule always matches a comma at the end,
so we would need to have something like:

 Darth Vader, Luke Skywalker,

Instead of something more natural like:

 Darth Vader, Luke Skywalker

We can modify the rule a little bit so that it always ends with a name
instead of a comma:

 rule TOP {
    [ <persons_name> ',' ]* <persons_name>
 }

Now we don't need a trailing comma, but at the same time we can't match
an empty file because it always expects to have at least one name at the
end. If we still want to match empty files successfully, we need to make
the whole rule optional:

 rule TOP {
    [ [ <persons_name> ',' ]* <persons_name> ]?
 }

We've grouped the whole rule together in another set of brackets, and
put a "?" question mark at the end. The question mark means zero or
one of the prior item.

The symbols "*" (zero or more), "+" (one or more) and "?" are called
I<quantifiers>, and allow an item in the rule to match a variable
number of times. These aren't the only quantifiers, but they are the
most common. We will talk about other quantifiers later on.

=cut

# Local variables:
#   c-file-style: "parrot"
# End:
# vim: expandtab shiftwidth=4:
