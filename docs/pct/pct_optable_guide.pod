# Copyright (C) 2008, The Perl Foundation.
# $Id$

=head1 NAME

pct_optable_guide.pod - A Guide to Using an Operator Parsing Table in PGE-based grammars.

=head1 DESCRIPTION

This document describes how to use an operator parsing table in grammars
written for the Parrot Grammar Engine.

=head1 WHY AN OPTABLE?

Even in simple languages such as C<abc>, parse trees can become very
big for even very simple expressions.

Consider the following example grammar:

 token addop { '+' | '-' }
 token mulop { '*' | '/' }

 rule expression {
    <mulexpr> [<addop> <mulexpr>]*
 }

 rule mulexpr {
    <primary> [<mulop> <primary>]*
 }

 rule primary {
    | <integer>
    ...
 }


An expresson such as C<1 + 2> will result in a parse tree like this:

 expression
   mulexpr
      primary
         integer
            1
   addop
      +
   mulexpr
      primary
         integer
            2

This may not seem very big, but remember it's only for C<1 + 2>!
Also note that you have to add at least one rule per precendence level,
so the rules for parsing simple statements can increase the size of
your grammar dramatically.

In order to prevent very big parse trees (which is rather inefficient),
it's much better to do bottom-up parsing for expressions such as these.


=head1 HOW TO USE AN OPTABLE?

Perl 6 rules are run as ordinary subroutines (well, in fact, they are
C<methods> of the class representing the grammar you're writing), and
parsing will be done by invoking a rule's subrules. A subrule can also
contain subrules. Therefore, the generated parser is a top-down parser,
starting at the C<TOP> rule, and invoking rules that represent I<lower>
parts of the grammar.

=head2 Switching Top-down and Bottom-up parsing

An optable parses operators bottom-up, which is the other well-known
parsing approach, implemented popular parser generators such as Yacc.
At some point, when using an optable, your parser must switch from
top-down parsing to bottom-up, and after parsing the operators (and
related operands), the parser switches back from bottom-up to top-down
again.

Buttom up parsing is very well suited for expressions that consist of
terms, unary and binary operators with no two terms in a row.

In order to define the entry point of the bottom-up, operator parsing
table, you should define a rule. Below is an example that states that
an C<expression> is parsed by the operator parser:

 rule expression is optable { ... }

The C<...> indicates that this rule is a C<prototype>.

{{ explain what a proto is }}


In order to define what an operand is, a special rule is define, named
C<term:>.

{{ is this always called "term:" or can it be named anything? not sure }}

 proto 'term:' is precedence('=') is parsed(&simple_expression) { ... }

This rule states that whenever an operand is expected, it is parsed by
the rule named C<simple_expression>. In other words, this is the point
where the parser switches back from bottom-up to top-down.

=head2 Defining operators

In between these two rules defining the entry point and the I<exit> point
of the operator parser, operators are declared, along with their
precedence. This typically look as follows:

 proto 'infix:+' is looser('term:') { ... }

This defines the symbol C<+> as an C<infix> operator.


=head3 Operator precedence

Operator precedence can be expressed using the following traits:

=over 4

=item * looser( OP )

States that the precedence of the current operator being defined is looser
than C<op>.

=item * equal( OP )

States that the precedence of the current operator being defined is equal
to the precedence of operator C<OP>.

=item * tighter( OP )

States that the precedence of the current operator being defined is
tighter than the precedence of the operator C<OP>.

=back

=head3 Where's the operator?

When operators such as C<infix:+> are defined, the bottom-up parser will
generate a C<call> instruction to a subroutine with the same name, that is,
C<infix:+>. Therefore, you need to write a subroutine for each operator
you define. The subroutine for the C<infix:+> operator could look like this:

 .sub 'infix:+'
    .param pmc a      # left operand
    .param pmc b      # right operand
    n_add $P0, a, b   # create a new PMC object with the value a+b
    .return ($P0)
 .end

Whenever an expression such as C<42 + 1> is parsed, this will result in a
call to C<infix:+> with the operands C<42> and C<1>. The C<infix:+> sub
will create a new object, and assign the result of C<42 + 1> to it, after
which this new object is returned. Note that the C<n_> prefix of the C<add>
instruction implies that a new object is created.

You might think that it's somewhat overkill to write and call a subroutine
for such a simple operation, and that this could be done simpler. Well,
you're right. If the implementation of the C<+> operator is as simple as
in this case, there's a simpler way to implement the exact same behavior.
This can be accomplished using a the C<pirop> trait, discussed below.

=head3 Infix, prefix, postfix

Besides C<infix> operators, operators can be C<prefix> or C<postfix>
Operators can even be declared to be both C<prefix> and C<infix>. A common
example is the C<-> operator. This is fine, because each operator has
a certain precedence, which is kept track of by the bottom-up parser.

In order to define a prefix C<++> operator, you could write this:

 proto 'prefix:++' ... # specify precedence

Besides these well-known mathematical operators, some languages have
built-in operators with C<normal> names. For instance, Ruby defines
an operator called C<defined?>, which queries its operand whether it
is defined. Defining such special operators are not special in any way,
just declared them as any other operator:

 proto 'prefix:defined?' ...

Note that C<defined?> is a prefix operator.

=head3 Ternary operators

Most languages only have one ternary operator: C<? :>. An example is shown
below:

 $income > 100000 ? print("I'm rich!") : print("I'll keep my job for now")

To declare a ternary operator, you write:

 proto ternary:<? :> is looser('infix:+') { ... }


=head3 The C<assoc> trait

Operators have a certain associacity. For instance, the C<+> operator
is usually said to be C<left> associated, while the exponential operator
(often written as C<^>) is usually C<right> associated. Consider this
example:

 10 - 5 - 2

Should this be parsed as:

 ((10 - 5) - 2)  # 5-2=3

or as:

 (10 - (5 - 2))  # 10-3=7

In other words, does the C<-> I<associate> with the left or right operand?
According to standard rules, the C<-> operator is C<left> associated,
which means the first option is correct.

This associecity is expressed using the C<assoc> trait, like so:

 proto 'infix:-' is assoc('left') ...

If you don't specify the association, it defaults to C<'left'>. C<right>
association works the other way around. In mathematics, the power operator
is right associated.

There is a third associacity in Perl 6. Generally a list (using the comma
operator) is not nested at all:

 1, 2, 3, 4

should neither be parsed as

 (((1, 2), 3), 4

nor as

 1, (2, (3, 4))

You can achieve that with the C<is assoc('none')> trait.

=head3 The C<pirop> trait

Some operators can be perfectly mapped to a specific Parrot instruction,
for instance the C<n_add> op that we introduced earlier. By default, an
operator is implemented as a subroutine call, which is obviously not as
efficient as a single Parrot instruction. Therefore, you can specify the
Parrot instruction using the C<pirop> trait. You can do this as follows:

 proto 'infix:+' ... is pirop('n_add') { ... }

This will not work for all Parrot ops, though. Certain instructions
leave their result in an C<I> register (one of the four types of Parrot
registers). PCT currently only supports PMC registers (C<P> registers).
Operators such as C<==> and C<!=> must therefore be implemented as
subroutine calls.

=head3 The C<pasttype> trait

Some operators have behavior that can be implemented by certain PAST
nodes. For instance, many languages define the semantics of the C<and>
operator to be the following:

 A and B

 1 evaluate A
 2 if result(1) is false return false
 3 evaluate B
 4 return result(3)

As soon as the result of A is found to be false, there is no need to
evaluate B, as the final result can never be true (as this is the C<and>
operator). So, C<B> is evaluated only if C<A> is true.

This is very similar to the PAST::Op node with the C<if> C<:pasttype>:

 if (A) {
   B
 }

Therefore, an operator such as C<and> can be implemented as an C<if>
statement. In order to specify that the C<and> operator must be handled
as a PAST::Op( :pasttype('if') ) node, you can use the C<pasttype> trait,
like so:

 proto 'infix:and' ... is pasttype('if') { ... }

The C<or> operator is similar to the semantics of a
PAST::Op( :pasttype('unless') node:

 A or B

 1 evaluate A
 2 if result(1) is true return true
 3 evaluate B
 4 return result(3)

So, C<unless> A is true, evaluate B. Hence, the C<or> operator could
be implemented like so:

 proto 'infix:or' ... is pasttype('unless') { ... }

=head3 Special characters

Some operators, such as the shift operators contain the "<" or ">" character.
As operators can be specified as, for instance, infix:<+>, defining an operator
such as "<<" will make the rule parser (the parser generator) confused.

Therefore, use so-called French quotes to do this. This looks as follows:

 proto infix:«>>»  is equiv(infix:«<<») { ... }


=head1 FAQ

=over 4

=item * Why are some operators quoted and some not?

{{ answer this }}

=item * I get an error message saying: XXX

{{ answer this }}

=item * How many operator tables can I use in my language?

{{ I think one only? }}

=item * How does an optable parser work?

If you really want to know, check out compiler literature.
It's something with a stack.

=back

=head1 SEE ALSO

=over 4

=item * L<docs\pct\gettingstarted.pod>

=item * L<docs\pct\past_building_blocks.pod>

=back

=cut
