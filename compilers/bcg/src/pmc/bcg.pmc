/*
 $Id$
 Copyright (C) 2008, The Perl Foundation.

=head1 NAME

bcg_info.pmc Byte Code Generator PMC

=head1 DESCRIPTION

Byte Code Generator PMC and methods associated with it.

=head2 Methods

List of methods/operations defined over the PMC.

=over 4

=cut

*/

#include <string.h>
#include "parrot/extend.h"
#include "bcg.h"

static INTVAL dynpmc_BCG;
static char get_data_type_from_cstring(Interp *interp, char *data_type);

pmclass BCG dynpmc need_ext group bcg_group lib bcg {

    void class_init()
    {
        if (pass)
            dynpmc_BCG = Parrot_PMC_typenum(INTERP, "BCG");
    }

/*

=item C<void init ()>

This method creates a BCG_info PMC instance

=cut

*/
    void init()
    {
        PMC_struct_val(SELF) = BCG_create();
    }

/*

=item C<void destroy ()>

This method destroys BCG_info PMC instance.

=cut

*/
    void destroy()
    {
        if (PMC_struct_val(SELF)) {
            BCG_destroy((BCG_info *)PMC_struct_val(SELF));
            PMC_struct_val(SELF) = NULL;
        }
    }

/*

=item C<void startCodeGen()>

This method starts the code generation phase.

=cut

*/
    METHOD startCodeGen()
    {
        BCG_info *bcg_info = (BCG_info *)PMC_struct_val(SELF);

        BCG_TRY(bcg_info) {
            BCG_start_code_gen(bcg_info);
        }
        BCG_CATCH(BCG_EXCEPTION) {
            Parrot_ex_throw_from_c_args(INTERP, NULL, EXCEPTION_INVALID_OPERATION,
                bcg_info->error_msg);
        }
        BCG_END_TRY;
    }
/*

=item C<void endCodeGen()>

This method concludes the code generation phase.

=cut

*/
    METHOD endCodeGen()
    {
        BCG_info *bcg_info = (BCG_info *)PMC_struct_val(SELF);

        BCG_TRY(bcg_info) {
            BCG_end_code_gen(bcg_info);
        }
        BCG_CATCH(BCG_EXCEPTION) {
            Parrot_ex_throw_from_c_args(INTERP, NULL, EXCEPTION_INVALID_OPERATION,
                bcg_info->error_msg);
        }
        BCG_END_TRY;

    }

/*

=item C<void startSub(STRING *subName, STRING *pragma)>

This method is called to generate byte code for start subroutine.

=cut

*/
    METHOD startSub(STRING *subName, STRING *pragma)
    {
        BCG_info *bcg_info = (BCG_info *)PMC_struct_val(SELF);

        BCG_TRY(bcg_info) {
            char *name_str   = string_to_cstring(INTERP, subName);
            char *pragma_str = string_to_cstring(INTERP, pragma);
            BCG_start_sub(bcg_info, name_str, pragma_str);
            string_cstring_free(name_str);
            string_cstring_free(pragma_str);
        }
        BCG_CATCH(BCG_EXCEPTION) {
            Parrot_ex_throw_from_c_args(INTERP, NULL, EXCEPTION_INVALID_OPERATION,
                bcg_info->error_msg);
        }
        BCG_END_TRY;
    }

/*

=item C<void endSub()>

This method is called to generate bytecode for end subroutine

=cut

*/
    METHOD endSub()
    {
        BCG_info *bcg_info = (BCG_info *)PMC_struct_val(SELF);

        BCG_TRY(bcg_info) {
            BCG_end_sub(bcg_info);
        }
        BCG_CATCH(BCG_EXCEPTION) {
            Parrot_ex_throw_from_c_args(INTERP, NULL, EXCEPTION_INVALID_OPERATION,
                bcg_info->error_msg);
        }
        BCG_END_TRY;
    }
/*

=item C<void startCall(STRING *subName)>

This method generates code for a subroutine call.

=cut

*/
    METHOD startCall(STRING *subName)
    {
        BCG_info *bcg_info = (BCG_info *)PMC_struct_val(SELF);

        BCG_TRY(bcg_info) {
            char *name_str = string_to_cstring(INTERP, subName);
            BCG_start_call(bcg_info, name_str);
            string_cstring_free(name_str);
        }
        BCG_CATCH(BCG_EXCEPTION) {
            Parrot_ex_throw_from_c_args(INTERP, NULL, EXCEPTION_INVALID_OPERATION,
                bcg_info->error_msg);
        }
        BCG_END_TRY;
    }

/*

=item C<void endCall()>

This method generated code for ending a subroutine call.

=cut

*/
    METHOD endCall()
    {
        BCG_info *bcg_info = (BCG_info *)PMC_struct_val(SELF);

        BCG_TRY(bcg_info) {
            BCG_end_call(bcg_info);
        }
        BCG_CATCH(BCG_EXCEPTION) {
            Parrot_ex_throw_from_c_args(INTERP, NULL, EXCEPTION_INVALID_OPERATION,
                bcg_info->error_msg);
        }
        BCG_END_TRY;
    }

/*

=item C<void startOp(STRING *op)>

This method generates code for a normal op.

=cut

*/
    METHOD startOp(STRING *op)
    {
        BCG_info *bcg_info = (BCG_info*) PMC_struct_val(SELF);

        BCG_TRY(bcg_info) {
            char *op_name = string_to_cstring(INTERP, op);
            BCG_start_op(bcg_info, op_name);
            string_cstring_free(op_name);
        }
        BCG_CATCH(BCG_EXCEPTION) {
            Parrot_ex_throw_from_c_args(INTERP, NULL, EXCEPTION_INVALID_OPERATION,
                bcg_info->error_msg);
        }
        BCG_END_TRY;
    }

/*

=item C<void endOp()>

This method marks the end of an op.

=cut

*/
    METHOD endOp()
    {
        BCG_info *bcg_info = (BCG_info *)PMC_struct_val(SELF);

        BCG_TRY(bcg_info) {
            BCG_end_op(bcg_info);
        }
        BCG_CATCH(BCG_EXCEPTION) {
            Parrot_ex_throw_from_c_args(INTERP, NULL, EXCEPTION_INVALID_OPERATION,
                bcg_info->error_msg);
        }
        BCG_END_TRY;
    }

/*

=item C<void val(STRING *name, STRING *type)>

This method generates bytecode for a variable.

=cut

*/
    METHOD val(STRING *value, STRING *type)
    {
        BCG_info *bcg_info  = (BCG_info *)PMC_struct_val(SELF);
        char     *type_str  = string_to_cstring(INTERP, type);
        char     *val_str   = string_to_cstring(INTERP, value);
        char      data_type = get_data_type_from_cstring(INTERP, type_str);

        string_cstring_free(type_str);

        BCG_TRY(bcg_info) {
            BCG_val(bcg_info, val_str, data_type);
        }
        BCG_CATCH(BCG_EXCEPTION) {
            string_cstring_free(val_str);
            Parrot_ex_throw_from_c_args(INTERP, NULL, EXCEPTION_INVALID_OPERATION,
                bcg_info->error_msg);
        }
        BCG_END_TRY;

        if (val_str)
            string_cstring_free(val_str);
    }

/*

=item C<void var(STRING *value, STRING *type)>

This method generates bytecode for a constant.

=cut

*/
    METHOD var(STRING *varName, STRING *type)
    {
        BCG_info *bcg_info  = (BCG_info*) PMC_struct_val(SELF);
        char     *type_str  = string_to_cstring(INTERP, type);
        char     *name_str  = string_to_cstring(INTERP, varName);
        char      data_type = get_data_type_from_cstring(INTERP, type_str);

        string_cstring_free(type_str);

        BCG_TRY(bcg_info) {
            BCG_var(bcg_info, name_str, data_type);
        }
        BCG_CATCH(BCG_EXCEPTION) {
            string_cstring_free(name_str);
            Parrot_ex_throw_from_c_args(INTERP, NULL, EXCEPTION_INVALID_OPERATION,
                bcg_info->error_msg);
        }
        BCG_END_TRY;

        if (name_str)
            string_cstring_free(name_str);
    }

/*

=item C<void label(STRING *label)>

This method generates bytecode for label.

=cut

*/
    METHOD label(STRING *label)
    {
        BCG_info *bcg_info  = (BCG_info *)PMC_struct_val(SELF);
        char     *label_str = string_to_cstring(INTERP, label);

        BCG_TRY(bcg_info) {
            BCG_label(bcg_info, label_str);
        }
        BCG_CATCH(BCG_EXCEPTION) {
            string_cstring_free(label_str);
            Parrot_ex_throw_from_c_args(INTERP, NULL, EXCEPTION_INVALID_OPERATION,
                bcg_info->error_msg);
        }
        BCG_END_TRY;

        if (label_str)
            string_cstring_free(label_str);
    }


/*

=item C<void printPASM()>

This method decompiles the bytecode to PASM.
See emit_pasm(BCG_info * bcg_info).

=cut

*/
    METHOD printPASM()
    {
        BCG_info *bcg_info = (BCG_info *)PMC_struct_val(SELF);
        BCG_print_pasm(bcg_info);
    }
}

static char
get_data_type_from_cstring(Interp *interp, char *data_type)
{
    if (!strcmp(data_type, "pmc")) {
        return 'P';
    }
    else if (!strcmp(data_type, "int")) {
        return 'I';
    }
    else if (!strcmp(data_type, "number")) {
        return 'N';
    }
    else if (!strcmp(data_type, "string")) {
        return 'S';
    }

    Parrot_ex_throw_from_c_args(interp, NULL, EXCEPTION_INVALID_OPERATION,
        "Invalid data type.");
}

/*

=back

=head1 LICENSE

Copyright (C) 2006-2008, The Perl Foundation.

This is free software; you may redistribute it and/or modify
it under the same terms as Parrot.

=head1 AUTHOR

Vishal Soni <vishalrsoni@gmail.com>

=cut

*/

/*
 * Local variables:
 *   c-file-style: "parrot"
 * End:
 * vim: expandtab shiftwidth=4:
 */
