/*
Copyright: 2003 The Perl Foundation.  All Rights Reserved.
$Id$

=head1 NAME

classes/integer.pmc - Integer PMC class

=head1 DESCRIPTION

C<Integer> provides an integer for languages
that want a value-restricted integer type without going to an I
register.

=head2 Functions

=over 4

=cut

*/

#include "parrot/parrot.h"
#include <assert.h>

/* XXX create MMD headers to in Pmc2c.pm */
extern INTVAL Parrot_BigInt_is_equal_BigInt(Interp*, PMC*, PMC*);
extern PMC* Parrot_BigInt_multiply_int(Interp* interpreter,
        PMC* pmc, INTVAL value, PMC* dest) ;

static PMC*
overflow(Interp *interpreter, PMC *self, INTVAL b, PMC *dest, int mmd)
{
    PMC *temp;
    INTVAL a = VTABLE_get_integer(interpreter, self);

    if (PARROT_ERRORS_test(interpreter,PARROT_ERRORS_OVERFLOW_FLAG)) {
        real_exception(interpreter, NULL, ERR_OVERFLOW,
                "Integer overflow");
    }
    if (self == dest) {
        /* TODO preserve type system */
        VTABLE_morph(interpreter, self, enum_class_BigInt);
        VTABLE_set_integer_native(interpreter, self, a);
        return mmd_dispatch_p_pip(interpreter, self, b, dest, mmd);
    }
    else {
        temp = VTABLE_get_bignum(interpreter, self);
        return mmd_dispatch_p_pip(interpreter, temp, b, dest, mmd);
    }
}

static PMC*
overflow_p(Interp *interpreter, PMC *self, PMC *val, PMC *dest, int mmd)
{
    PMC *temp;
    INTVAL a = VTABLE_get_integer(interpreter, self);

    if (PARROT_ERRORS_test(interpreter,PARROT_ERRORS_OVERFLOW_FLAG)) {
        real_exception(interpreter, NULL, ERR_OVERFLOW,
                "Integer overflow");
    }
    if (self == dest) {
        VTABLE_morph(interpreter, self, enum_class_BigInt);
        VTABLE_set_integer_native(interpreter, self, a);
        return mmd_dispatch_p_ppp(interpreter, self, val, dest, mmd);
    }
    else {
        temp = VTABLE_get_bignum(interpreter, self);
        return mmd_dispatch_p_ppp(interpreter, temp, val, dest, mmd);
    }
}

pmclass Integer extends scalar does integer does scalar {

/*

=item C<void init()>

Initializes the integer with a default value of C<0>.

=cut

*/
    void init () {
        PMC_int_val(SELF) = 0;
    }

/*

=item C<PMC new_from_string(STRING *rep)>

Class method to construct an Integer from the string representation C<rep>.

=item C<PMC* instantiate()>

Class method to construct an Integer according to passed arguments.

=cut

*/
    PMC* new_from_string(STRING *rep, INTVAL flags) {
        INTVAL type;
        PMC *res;

        type = SELF->vtable->base_type;
        if (flags & PObj_constant_FLAG)
            res = constant_pmc_new(INTERP, type);
        else
            res = pmc_new(INTERP, type);
        /* TODO bigint overflow */
        PMC_int_val(res) = string_to_int(INTERP, rep);
        return res;
    }

    PMC* instantiate() {
        PMC *class = REG_PMC(2);
        int argcP = REG_INT(3);
        int argcS = REG_INT(2);
        int base;
        PMC *res, *arg;
        STRING *num;
        INTVAL type;
        STRING *isa;

        type = class->vtable->base_type;
        if (!argcP) {
            res = pmc_new(INTERP, type);
            if (!argcS)
                return res;
            return DYNSELF.new_from_string(REG_STR(5), 0);
        }
        base = 10;
        if (argcP == 2)
            base = VTABLE_get_integer(INTERP, REG_PMC(6));
        arg = REG_PMC(5);
        isa = CONST_STRING(INTERP, "Integer");
        if (VTABLE_isa(INTERP, arg, isa) && base == 10) {
            res = pmc_new(INTERP, type);
            PMC_int_val(res) = PMC_int_val(arg);
            return res;
        }

        isa = CONST_STRING(INTERP, "Float");
        if (VTABLE_isa(INTERP, arg, isa)) {
            FLOATVAL d = VTABLE_get_number(INTERP, arg);
            const char *sign = "-";
            INTVAL i = VTABLE_get_integer(INTERP, arg);
            d = floor(d);
            if (d == i) {
                res = pmc_new(INTERP, type);
                PMC_int_val(res) = i;
                return res;
            }
            if (!signbit(d))
                sign = "";
            d = fabs(d);
            num = Parrot_sprintf_c(INTERP, "%s%.12g", sign, d);
        }
        else
            num = VTABLE_get_string(INTERP, arg);
        /* TODO preserved type */
        res = pmc_new(INTERP, enum_class_BigInt);
        VTABLE_set_string_keyed_int(INTERP, res, base, num);
        if (num->strlen < 9) {  /* XXX */
            /* TODO not if it would overflow */
            INTVAL intnum = VTABLE_get_integer(INTERP, res);
            res = pmc_new(INTERP, type); /*TODO morph */
            PMC_int_val(res) = intnum;
        }
        return res;
    }


/*

=item C<void share()>



=cut

*/
    void share () {
        /*
         * assume that the access to a long is atomic.
         * integers are most often (1) equal to C longs,
         * not C ints, and this makes a difference in 64-bit
         * platforms where longs are 64-bit but ints are 32-bit.
         * (1) Not equal when integers have been configured
         *     to be software-emulated long longs.
         */
        if (sizeof(INTVAL) != sizeof(long))
            SUPER();
    }

/*

=item C<INTVAL get_integer()>

Returns the integer value of the Integer.

=cut

*/
    INTVAL get_integer () {
        return PMC_int_val(SELF);
    }

/*

=item C<INTVAL get_bool()>

Returns the boolean value of the Integer.

=cut

*/
    INTVAL get_bool () {
        return PMC_int_val(SELF) ? 1 : 0;
    }

/*

=item C<FLOATVAL get_number()>

Returns the floating-point value of the integer.

=cut

*/
    FLOATVAL get_number () {
        return (FLOATVAL)PMC_int_val(SELF);
    }

/*

=item C<PMC *get_bignum()>

Return a new BigInt PMC with the value of C<SELF>.

=cut

*/
    PMC* get_bignum () {
        INTVAL val = DYNSELF.get_integer();
        PMC *ret = pmc_new(INTERP, enum_class_BigInt);
        VTABLE_set_integer_native(INTERP, ret, val);
        return ret;
    }

/*

=item C<STRING *get_string()>

Returns the string value of the integer.

=cut

*/
    STRING* get_string () {
        return string_from_int(INTERP, PMC_int_val(SELF));
    }

/*

=item C<void set_integer_same(PMC *value)>

=item C<void set_integer_native(INTVAL value)>

Sets the value of the integer to the value of the C<Integer> C<*value>.

=cut

*/
    void set_integer_same (PMC * value) {
        PMC_int_val(SELF) = PMC_int_val(value);
    }

    void set_integer_native (INTVAL value) {
        PMC_int_val(SELF) = value;
    }



/*

=item C<void set_number_native(FLOATVAL value)>

Morphs the integer to a C<Float> and sets the value from C<value>.

=item C<void set_bool(INTVAL value)>

Morphs the integer to a C<Boolean> and sets the value from C<value>.

=item C<void set_bigint_int(INTVAL value)>

Morphs the integer to a C<BigInt> and sets the value from C<value>.

=item C<void set_string_native(STRING *value)>

Morphs the integer to a C<String> and sets the value from C<value>.

=cut

*/
    void set_number_native (FLOATVAL value) {
        DYNSELF.morph(enum_class_Float);
        DYNSELF.set_number_native(value);
    }

    void set_bool (INTVAL value) {
        DYNSELF.morph(enum_class_Boolean);
        DYNSELF.set_bool(value);
    }

    void set_bignum_int (INTVAL value) {
        DYNSELF.morph(enum_class_BigInt);
        DYNSELF.set_integer_native(value);
    }

    void set_string_native (STRING* value) {
        DYNSELF.morph(enum_class_String);
        DYNSELF.set_string_native(value);
    }

/*

=item C<PMC* add(PMC *value, PMC *dest)>

=item C<PMC* add_int(INTVAL value, PMC *dest)>

Adds C<value> to the integer and returns the result in C<*dest>.

Please note: the label syntax I<MMD_type:> denote the behavior, if
the right hand value is of that type. The part inside the braces is
converted to a distinct function and gets I<mmd_register>ed for these
two types.

=cut

*/
    PMC* add (PMC* value, PMC* dest) {
MMD_Integer: {
            /*
             * SELF and value can both be PMCs that inherit
             * from Integer:
             *   cl = subclass "Integer", "MyInt"
             * so we can't used PMC_int_val(SELF) in any of these
             * Integer methods
             *
             * TODO
             *   check for exact Integer type
             *   e.g. MMD_Integer_EXACT
             */

            INTVAL a = DYNSELF.get_integer();
            INTVAL b = VTABLE_get_integer(INTERP, value);
            INTVAL c = a + b;
            if ((c^a) >= 0 || (c^b) >= 0) {
                if (!dest)
                    dest = pmc_new(INTERP, SELF->vtable->base_type);
                /* need this for e.g. PerlUndef */
                VTABLE_set_integer_native(INTERP, dest, c);
                return dest;
            }
            else
                return overflow(INTERP, SELF, b, dest, MMD_ADD);
        }
MMD_Complex: {
            INTVAL a = DYNSELF.get_integer();
            if (dest)
                VTABLE_morph(INTERP, dest, value->vtable->base_type);
            else
                dest = pmc_new(INTERP, value->vtable->base_type);
            VTABLE_set_number_native(INTERP, dest,
                    a + VTABLE_get_number_keyed_int(INTERP, value, 0));
            VTABLE_set_number_keyed_int(INTERP, dest, 1,
                    VTABLE_get_number_keyed_int(INTERP, value, 1));
            return dest;
        }
MMD_BigInt: {
            return overflow_p(INTERP, SELF, value, dest, MMD_ADD);
        }
MMD_DEFAULT: {
            if (!dest)
                dest = pmc_new(INTERP, value->vtable->base_type);
            VTABLE_set_number_native(INTERP, dest,
                DYNSELF.get_integer() + VTABLE_get_number(INTERP, value));
            return dest;
        }
    }

    PMC* add_int (INTVAL b, PMC* dest) {
        /* INTVAL a = PMC_int_val(SELF); */
        INTVAL a = VTABLE_get_integer(INTERP, SELF);
        INTVAL c = a + b;
        if ((c^a) >= 0 || (c^b) >= 0) {
            if (!dest)
                dest = pmc_new(INTERP, SELF->vtable->base_type);
            VTABLE_set_integer_native(INTERP, dest, c);
            return dest;
        }
        else
            return overflow(INTERP, SELF, b, dest, MMD_ADD);
    }

/*

=item C<void i_add(PMC *value)>

=item C<void i_add(INTVAL value)>

=item C<void i_add(FLOATVAL value)>

Adds C<value> to C<SELF> inplace.

=cut

*/

    void i_add (PMC* value) {
MMD_Integer: {
            SELF.i_add_int(VTABLE_get_integer(INTERP, value));
        }
MMD_Complex: {
            INTVAL a = DYNSELF.get_integer();
            VTABLE_morph(INTERP, SELF, value->vtable->base_type);
            VTABLE_set_number_native(INTERP, SELF,
                    (FLOATVAL)a +
                    VTABLE_get_number_keyed_int(INTERP, value, 0));
            VTABLE_set_number_keyed_int(INTERP, SELF, 1,
                    VTABLE_get_number_keyed_int(INTERP, value, 1));
        }
MMD_DEFAULT: {
        VTABLE_set_number_native(INTERP, SELF,
            PMC_int_val(SELF) + VTABLE_get_number(INTERP, value));
        }
    }

    void i_add_int (INTVAL b) {
        INTVAL a = DYNSELF.get_integer();
        INTVAL c = a + b;
        if ((c^a) >= 0 || (c^b) >= 0) {
            VTABLE_set_integer_native(INTERP, SELF, c);
        }
        else
            overflow(INTERP, SELF, b, SELF, MMD_SUBTRACT);
    }

    void i_add_float (FLOATVAL value) {
        INTVAL a = DYNSELF.get_integer();
        VTABLE_set_number_native(INTERP, SELF, a + value);
    }
/*

=item C<PMC* subtract(PMC *value, PMC *dest)>

Subtracts C<*value> from the integer and returns the result in C<*dest>.
If C<dest> is NULL, a new int PMC is created.

Please note: as C<SELF> or C<value> maybe be subclassed, we have to
call C<get_integer> and C<set_integer_native> always.

=cut

*/
    PMC* subtract (PMC* value, PMC* dest) {
MMD_Integer: {
            INTVAL a = DYNSELF.get_integer();
            INTVAL b = VTABLE_get_integer(INTERP, value);
            INTVAL c = a - b;
            if ((c^a) >= 0 || (c^~b) >= 0) {
                if (!dest)
                    dest = pmc_new(INTERP, SELF->vtable->base_type);
                VTABLE_set_integer_native(INTERP, dest, c);
                return dest;
            }
            else
                return overflow(INTERP, SELF, b, dest, MMD_SUBTRACT);
        }
MMD_Complex: {
            INTVAL a = DYNSELF.get_integer();
            if (dest)
                VTABLE_morph(INTERP, dest, value->vtable->base_type);
            else
                dest = pmc_new(INTERP, value->vtable->base_type);
            VTABLE_set_number_native(INTERP, dest,
                    a - VTABLE_get_number_keyed_int(INTERP, value, 0));
            VTABLE_set_number_keyed_int(INTERP, dest, 1,
                    -VTABLE_get_number_keyed_int(INTERP, value, 1));
            return dest;
        }
MMD_BigInt: {
            return overflow_p(INTERP, SELF, value, dest, MMD_SUBTRACT);
        }
MMD_DEFAULT: {
            if (!dest)
                dest = pmc_new(INTERP, value->vtable->base_type);
            VTABLE_set_number_native(INTERP, dest,
                DYNSELF.get_integer() - VTABLE_get_number(INTERP, value));
            return dest;
        }
    }

/*

=item C<PMC* subtract_int(INTVAL value, PMC *dest)>

Subtracts C<value> from the integer and returns the result in C<*dest>.

=cut

*/
    PMC* subtract_int (INTVAL b, PMC* dest) {
        INTVAL a = DYNSELF.get_integer();
        INTVAL c = a - b;
        if ((c^a) >= 0 || (c^~b) >= 0) {
            if (!dest)
                dest = pmc_new(INTERP, SELF->vtable->base_type);
            VTABLE_set_integer_native(INTERP, dest, c);
            return dest;
        }
        else
            return overflow(INTERP, SELF, b, dest, MMD_SUBTRACT);
    }

/*

=item C<void i_subtract(PMC *value)>

=item C<void i_subtract_int(INTVAL value)>

=item C<void i_subtract_float(FLOATVAL value)>

Subtracts C<value> from C<SELF> inplace.

=cut

*/

    void i_subtract (PMC* value) {
MMD_Integer: {
            INTVAL a = DYNSELF.get_integer();
            INTVAL b = VTABLE_get_integer(INTERP, value);
            INTVAL c = a - b;
            if ((c^a) >= 0 || (c^~b) >= 0) {
                VTABLE_set_integer_native(INTERP, SELF, c);
            }
            else
                overflow(INTERP, SELF, b, SELF, MMD_SUBTRACT);
        }
MMD_Complex: {
            INTVAL a = DYNSELF.get_integer();
            VTABLE_morph(INTERP, SELF, value->vtable->base_type);
            VTABLE_set_number_native(INTERP, SELF,
                    (FLOATVAL)a -
                    VTABLE_get_number_keyed_int(INTERP, value, 0));
            VTABLE_set_number_keyed_int(INTERP, SELF, 1,
                    -VTABLE_get_number_keyed_int(INTERP, value, 1));
        }
MMD_DEFAULT: {
        VTABLE_set_number_native(INTERP, SELF,
            DYNSELF.get_integer() - VTABLE_get_number(INTERP, value));
        }
    }

    void i_subtract_int (INTVAL b) {
        INTVAL a = DYNSELF.get_integer();
        INTVAL c = a - b;
        if ((c^a) >= 0 || (c^~b) >= 0) {
            VTABLE_set_integer_native(INTERP, SELF, c);
        }
        else
            overflow(INTERP, SELF, b, SELF, MMD_SUBTRACT);
    }

    void i_subtract_float (FLOATVAL value) {
        INTVAL a = DYNSELF.get_integer();
        VTABLE_set_number_native(INTERP, SELF, a - value);
    }

/*

=item C<PMC* multiply(PMC *value, PMC *dest)>

=item C<PMC* multiply_int(INTVAL value, PMC *dest)>

Multiplies the integer by C<*value> and returns the result in C<*dest>.

=cut

*/
    PMC* multiply (PMC* value, PMC* dest) {
MMD_Integer: {
            INTVAL a = VTABLE_get_integer(INTERP, SELF);
            INTVAL b = VTABLE_get_integer(INTERP, value);
            double cf = (double)a * (double)b;
            INTVAL c = a * b;
            if ((double) c == cf) {
                if (!dest)
                    dest = pmc_new(INTERP, SELF->vtable->base_type);
                VTABLE_set_integer_native(INTERP, dest, c);
                return dest;
            }
            else
                return overflow(INTERP, SELF, b, dest, MMD_MULTIPLY);
        }
MMD_Complex: {
                internal_exception(1, "TODO mul<Integer, Complex>");
                return dest;
            }
MMD_BigInt:     {
            return Parrot_BigInt_multiply_int(INTERP, value,
                    DYNSELF.get_integer(), dest);
        }
MMD_String: {
            return Parrot_Integer_multiply_Integer(INTERP, SELF, value, dest);
        }
MMD_DEFAULT: {
            FLOATVAL valf = VTABLE_get_number(INTERP, value);
            if (!dest)
                dest = pmc_new(INTERP, SELF->vtable->base_type);
            VTABLE_set_number_native(INTERP, dest, valf * PMC_int_val(SELF));
            return dest;
        }
    }

    PMC* multiply_int (INTVAL b, PMC* dest) {
        INTVAL a = DYNSELF.get_integer();
        double cf = (double)a * (double)b;
        INTVAL c = a * b;
        if ((double) c == cf) {
            if (!dest)
                dest = pmc_new(INTERP, SELF->vtable->base_type);
            VTABLE_set_integer_native(INTERP, dest, c);
            return dest;
        }
        else
            return overflow(INTERP, SELF, b, dest, MMD_MULTIPLY);
    }

/*

=item C<void i_multiply(PMC *value)>

=item C<void i_multiply_int(INTVAL value)>

=item C<void i_multiply_float(FLOATVAL value)>

Multiply C<value> with C<SELF> inplace.

=cut

*/

    void i_multiply (PMC* value) {
MMD_Integer: {
            SELF.i_multiply_int(VTABLE_get_integer(INTERP, value));
        }
MMD_BigInt: {
            Parrot_BigInt_multiply_int(INTERP, value,
                    DYNSELF.get_integer(), SELF);
        }
MMD_Complex: {
                internal_exception(1, "TODO i_mul<Integer, Complex>");
        }
MMD_DEFAULT: {
        VTABLE_set_number_native(INTERP, SELF,
            PMC_int_val(SELF) * VTABLE_get_number(INTERP, value));
        }
    }

    void i_multiply_int (INTVAL b) {
        INTVAL a = DYNSELF.get_integer();
        double cf = (double)a * (double)b;
        INTVAL c = a * b;
        if ((double) c == cf) {
            DYNSELF.set_integer_native(c);
        }
        else
            overflow(INTERP, SELF, b, SELF, MMD_MULTIPLY);
    }

    void i_multiply_float (FLOATVAL value) {
        INTVAL a = DYNSELF.get_integer();
        VTABLE_set_number_native(INTERP, SELF, a * value);
    }

/*

=item C<PMC* divide(PMC *value, PMC *dest)>

=item C<PMC* divide_int(INTVAL value, PMC *dest)>

=item C<PMC* divide_float(FLOATVAL value, PMC *dest)>

Divides the number by C<value> and returns the result in C<*dest>.

=item C<void i_divide(PMC *value)>

=item C<void i_divide_int(INTVAL value)>

=item C<void i_divide_float(FLOATVAL value)>

Divides C<SELF> by C<value> inplace.

=cut

*/

    PMC* divide (PMC* value, PMC* dest) {
MMD_BigInt:     {
            return overflow_p(INTERP, SELF, value, dest, MMD_DIVIDE);
        }
MMD_DEFAULT: {
            FLOATVAL d = VTABLE_get_number(INTERP, value);

            if (d == 0.0)
                real_exception(INTERP, NULL, E_ZeroDivisionError,
                        "float division by zero");
            if (!dest)
                dest = pmc_new(INTERP, SELF->vtable->base_type);
            VTABLE_set_number_native(INTERP, dest, DYNSELF.get_number() / d);
            return dest;
        }
    }

    void i_divide (PMC* value) {
MMD_BigInt:     {
             overflow_p(INTERP, SELF, value, SELF, MMD_DIVIDE);
        }
MMD_DEFAULT: {
            FLOATVAL d = VTABLE_get_number(INTERP, value);

            if (d == 0.0)
                real_exception(INTERP, NULL, E_ZeroDivisionError,
                        "float division by zero");
            VTABLE_set_number_native(INTERP, SELF, DYNSELF.get_number() / d);
        }
    }

/*

=item C<PMC* floor_divide(PMC *value, PMC *dest)>

=item C<PMC* floor_divide_int(INTVAL value, PMC *dest)>

=item C<PMC* floor_divide_float(FLOATVAL value, PMC *dest)>

Divides the number by C<value> and returns the result in C<*dest>.

=item C<void i_floor_divide(PMC *value)>

=item C<void i_floor_divide_int(INTVAL value)>

=item C<void i_floor_divide_float(FLOATVAL value)>

Divides C<SELF> by C<value> inplace.

=cut

*/

    PMC* floor_divide (PMC* value, PMC* dest) {
MMD_BigInt:     {
            return overflow_p(INTERP, SELF, value, dest, MMD_FLOOR_DIVIDE);
        }
MMD_DEFAULT: {
            FLOATVAL d = VTABLE_get_number(INTERP, value);

            if (d == 0.0)
                real_exception(INTERP, NULL, E_ZeroDivisionError,
                        "float division by zero");
            if (!dest)
                dest = pmc_new(INTERP, SELF->vtable->base_type);
            VTABLE_set_integer_native(INTERP, dest,
                    (INTVAL)floor(DYNSELF.get_number() / d));
            return dest;
        }
    }

    PMC* floor_divide_int (INTVAL value, PMC* dest) {
        if (value == 0)
            real_exception(INTERP, NULL, E_ZeroDivisionError,
                    "float division by zero");
        if (!dest)
            dest = pmc_new(INTERP, SELF->vtable->base_type);
        VTABLE_set_integer_native(INTERP, dest,
                (INTVAL)floor(DYNSELF.get_number() / value));
        return dest;
    }

    PMC* floor_divide_float (FLOATVAL value, PMC* dest) {
        if (value == 0.0)
            real_exception(INTERP, NULL, E_ZeroDivisionError,
                    "float division by zero");
        if (!dest)
            dest = pmc_new(INTERP, SELF->vtable->base_type);
        VTABLE_set_integer_native(INTERP, dest,
                (INTVAL)floor(DYNSELF.get_number() / value));
        return dest;
    }

    void i_floor_divide (PMC* value) {
MMD_BigInt:     {
            overflow_p(INTERP, SELF, value, SELF, MMD_FLOOR_DIVIDE);
        }
MMD_DEFAULT: {
            FLOATVAL d = VTABLE_get_number(INTERP, value);

            if (d == 0.0)
                real_exception(INTERP, NULL, E_ZeroDivisionError,
                        "float division by zero");
            VTABLE_set_integer_native(INTERP, SELF,
                    (INTVAL)floor(DYNSELF.get_number() / d));
        }
    }

    void i_floor_divide_int (INTVAL value) {
        if (value == 0)
            real_exception(INTERP, NULL, E_ZeroDivisionError,
                    "float division by zero");
        VTABLE_set_integer_native(INTERP, SELF,
                (INTVAL)floor(DYNSELF.get_number() / value));
    }

    void i_floor_divide_float (FLOATVAL value) {
        if (value == 0.0)
            real_exception(INTERP, NULL, E_ZeroDivisionError,
                    "float division by zero");
        VTABLE_set_integer_native(INTERP, SELF,
                (INTVAL)floor(DYNSELF.get_number() / value));
    }

/*

=item C<PMC* cmodulus(PMC *value, PMC *dest)>

=item C<PMC* cmodulus(INTVAL value, PMC *dest)>

=item C<PMC* cmodulus(FLOATVAL value, PMC *dest)>

Calculates the value of the number C-style C<mod> C<value> and returns
the result in C<dest>.

=item C<void i_cmodulus(PMC *value)>

=item C<void i_cmodulus(INTVAL value)>

=item C<void i_cmodulus(FLOATVAL value)>

Calculates the value of the number C-style C<mod> C<value> and returns
the result in C<dest>.

=cut

*/

    PMC* cmodulus (PMC* value, PMC* dest) {
MMD_BigInt: {
            return overflow_p(INTERP, SELF, value, dest, MMD_CMOD);
        }
MMD_DEFAULT: {
            INTVAL d = VTABLE_get_integer(INTERP, value);

            if (d == 0.0)
                real_exception(INTERP, NULL, E_ZeroDivisionError,
                        "int cmodulus by zero");
            if (!dest)
                dest = pmc_new(INTERP, SELF->vtable->base_type);
            VTABLE_set_integer_native(INTERP, dest,
                    DYNSELF.get_integer() % d);
            return dest;
        }
    }

    PMC* cmodulus_float (FLOATVAL value, PMC* dest) {
        if (value == 0.0)
            real_exception(INTERP, NULL, E_ZeroDivisionError,
                    "int cmodulus by zero");
        if (!dest)
            dest = pmc_new(INTERP, SELF->vtable->base_type);
        VTABLE_set_integer_native(INTERP, dest,
                (INTVAL)fmod(DYNSELF.get_integer(), value));
        return dest;
    }

    PMC* cmodulus_int (INTVAL value, PMC* dest) {
        if (value == 0)
            real_exception(INTERP, NULL, E_ZeroDivisionError,
                    "int cmodulus by zero");
        if (!dest)
            dest = pmc_new(INTERP, SELF->vtable->base_type);
        VTABLE_set_integer_native(INTERP, dest,
                DYNSELF.get_integer() % value);
        return dest;
    }

    void i_cmodulus (PMC* value) {
MMD_BigInt: {
             overflow_p(INTERP, SELF, value, SELF, MMD_CMOD);
        }
MMD_DEFAULT: {
            INTVAL d = VTABLE_get_integer(INTERP, value);

            if (d == 0.0)
                real_exception(INTERP, NULL, E_ZeroDivisionError,
                        "int cmodulus by zero");
            VTABLE_set_integer_native(INTERP, SELF,
                    DYNSELF.get_integer() % d);
        }
    }

    void i_cmodulus_int (INTVAL value) {
        if (value == 0)
            real_exception(INTERP, NULL, E_ZeroDivisionError,
                    "int cmodulus by zero");
        VTABLE_set_integer_native(INTERP, SELF,
                DYNSELF.get_integer() % value);
    }

    void i_cmodulus_float (FLOATVAL value) {
        if (value == 0.0)
            real_exception(INTERP, NULL, E_ZeroDivisionError,
                    "int cmodulus by zero");
        VTABLE_set_integer_native(INTERP, SELF,
                (INTVAL)fmod(DYNSELF.get_integer(), value));
    }

/*

=item C<PMC* modulus(PMC *value, PMC *dest)>

=item C<PMC* modulus(INTVAL value, PMC *dest)>

=item C<PMC* modulus(FLOATVAL value, PMC *dest)>

Calculates the value of corrected C<mod> C<value> and returns
the result in C<dest>. See also ops/math.ops.

=item C<void i_modulus(PMC *value)>

=item C<void i_modulus(INTVAL value)>

=item C<void i_modulus(FLOATVAL value)>

Calculates modulus inplace

=cut

*/

    PMC* modulus (PMC* value, PMC* dest) {
MMD_BigInt: {
            return overflow_p(INTERP, SELF, value, dest, MMD_MOD);
        }
MMD_DEFAULT: {
            INTVAL d = VTABLE_get_integer(INTERP, value);

            if (d == 0)
                real_exception(INTERP, NULL, E_ZeroDivisionError,
                        "int modulus by zero");
            if (!dest)
                dest = pmc_new(INTERP, SELF->vtable->base_type);
            VTABLE_set_integer_native(INTERP, dest,
                    intval_mod(DYNSELF.get_integer(), d));
            return dest;
        }
    }

    PMC* modulus_int (INTVAL value, PMC* dest) {
        if (value == 0)
            real_exception(INTERP, NULL, E_ZeroDivisionError,
                    "int modulus by zero");
        if (!dest)
            dest = pmc_new(INTERP, SELF->vtable->base_type);
        VTABLE_set_integer_native(INTERP, dest,
                intval_mod(DYNSELF.get_integer(), value));
        return dest;
    }

    PMC* modulus_float (FLOATVAL value, PMC* dest) {
        if (value == 0.0)
            real_exception(INTERP, NULL, E_ZeroDivisionError,
                    "int modulus by zero");
        if (!dest)
            dest = pmc_new(INTERP, SELF->vtable->base_type);
        VTABLE_set_integer_native(INTERP, dest,
                intval_mod(DYNSELF.get_integer(), (INTVAL)value));
        return dest;
    }
    void i_modulus (PMC* value) {
MMD_BigInt: {
             overflow_p(INTERP, SELF, value, SELF, MMD_MOD);
        }
MMD_DEFAULT: {
            INTVAL d = VTABLE_get_integer(INTERP, value);

            if (d == 0.0)
                real_exception(INTERP, NULL, E_ZeroDivisionError,
                        "int modulus by zero");
            VTABLE_set_integer_native(INTERP, SELF,
                    intval_mod(DYNSELF.get_integer() , d));
        }
    }

    void i_modulus_int (INTVAL value) {
        if (value == 0)
            real_exception(INTERP, NULL, E_ZeroDivisionError,
                    "int modulus by zero");
        VTABLE_set_integer_native(INTERP, SELF,
                intval_mod(DYNSELF.get_integer() , value));
    }

    void i_modulus_float (FLOATVAL value) {
        if (value == 0.0)
            real_exception(INTERP, NULL, E_ZeroDivisionError,
                    "int modulus by zero");
        VTABLE_set_integer_native(INTERP, SELF,
                intval_mod(DYNSELF.get_integer() , (INTVAL)value));
    }

/*

=item C<PMC* pow(PMC* value, PMC *dest)>

=item C<PMC* pow_int(INTVAL value, PMC *dest)>

Return SELF to the C<value>th power and return result in C<dest>.

=item C<void i_pow(PMC* value)>

=item C<void i_pow_int(INTVAL value)>

Rise SELF to the C<value>th power.

TODO Complex and BigInt rhs.

=cut

*/
    PMC* pow (PMC* value, PMC* dest) {
        INTVAL v = VTABLE_get_integer(INTERP, value);
        return SELF.pow_int(v, dest);
    }

    PMC* pow_int (INTVAL b, PMC* dest) {
        INTVAL a = DYNSELF.get_integer();
        INTVAL prev, temp, r;

        if (b < 0)
            return SUPER(b, dest);
        r = 1;
        if (a) {
            temp = a;
            while (b > 0) {
                prev = r;
                if (b & 1) {
                    r *= temp;
                    if (r / temp != prev) {
                        return overflow(INTERP, SELF, b, dest, MMD_POW);
                    }
                }
                b >>= 1;
                if (!b)
                    break;
                prev = temp;
                temp *= temp;
	 	if (prev != 0 && temp / prev != prev) {
                    return overflow(INTERP, SELF, b, dest, MMD_POW);
                }
            }
        }
        if (!dest)
            dest = pmc_new(INTERP, SELF->vtable->base_type);
        VTABLE_set_integer_native(INTERP, dest, r);
        return dest;

    }

    void i_pow(PMC* value) {
        SELF.pow(value, SELF);
    }

    void i_pow_int(INTVAL value) {
        SELF.pow_int(value, SELF);
    }


/*

=item C<INTVAL is_equal (PMC* value)>

The C<==> operation.

=cut

*/
    INTVAL is_equal (PMC* value) {
MMD_BigInt: {
        PMC* temp = pmc_new(INTERP, enum_class_BigInt);
        VTABLE_set_integer_native(INTERP, temp, PMC_int_val(SELF));
        return Parrot_BigInt_is_equal_BigInt(INTERP, temp, value);
    }
MMD_DEFAULT: {
        return (INTVAL)(PMC_int_val(SELF) ==
            VTABLE_get_integer(INTERP, value));
        }
    }

/*

=item C<INTVAL cmp(PMC *value)>

Returns the result of comparing the integer with C<*value>.

=cut

*/
    INTVAL cmp(PMC* value) {
MMD_String: {
            FLOATVAL fdiff = PMC_int_val(SELF)
                - VTABLE_get_number(INTERP, value);
            if (fdiff == 0) {
                INTVAL idiff = PMC_int_val(SELF)
                    - VTABLE_get_integer(INTERP, value);
                return idiff > 0 ? 1 : idiff < 0 ? -1 : 0;
            } else {
                return fdiff > 0 ? 1 : -1;
            }
        }
MMD_Float: {
            FLOATVAL diff;
            diff = (FLOATVAL)PMC_int_val(SELF)
                - VTABLE_get_number(INTERP, value);
            return diff > 0 ? 1 : diff < 0 ? -1 : 0;
        }
MMD_DEFAULT: {
            /* int or undef */
            INTVAL diff = PMC_int_val(SELF)
                - VTABLE_get_integer(INTERP, value);
            return diff > 0 ? 1 : diff < 0 ? -1 : 0;
        }
    }

/*

=item C<INTVAL cmp_num(PMC *value)>

Returns the result of numerically comparing the integer with C<*value>.

=cut

*/
    INTVAL cmp_num(PMC* value) {
MMD_String: {
            FLOATVAL fdiff = PMC_int_val(SELF)
                - VTABLE_get_number(INTERP, value);
            if (fdiff == 0) {
                INTVAL idiff = PMC_int_val(SELF)
                    - VTABLE_get_integer(INTERP, value);
                return idiff > 0 ? 1 : idiff < 0 ? -1 : 0;
            } else {
                return fdiff > 0 ? 1 : -1;
            }
        }
MMD_Float: {
            FLOATVAL diff;
            diff = (FLOATVAL)PMC_int_val(SELF)
                - VTABLE_get_number(INTERP, value);
            return diff > 0 ? 1 : diff < 0 ? -1 : 0;
        }
MMD_DEFAULT: {
            /* int or undef */
            INTVAL diff = PMC_int_val(SELF)
                - VTABLE_get_integer(INTERP, value);
            return diff > 0 ? 1 : diff < 0 ? -1 : 0;
        }
    }

/*

=item C<void increment()>

Increments the integer.

=cut

*/
    void increment () {
        /* XXX overflow */
        PMC_int_val(SELF) ++;
    }

/*

=item C<void decrement()>

Decrements the integer.

=cut

*/
    void decrement () {
        /* XXX overflow */
        PMC_int_val(SELF) --;
    }
/*

=item C<PMC* absolute(PMC* dest)>

=item C<void absolute()>

Sets C<dest> to the absolute value of SELF.

=cut

*/

    PMC* absolute(PMC *dest) {
        INTVAL a = abs(DYNSELF.get_integer());
        /* XXX overlflow for -maxint */
        if (!dest)
            dest = pmc_new(INTERP, SELF->vtable->base_type);
        VTABLE_set_integer_native(INTERP, dest, a);
        return dest;

    }

    void i_absolute() {
        INTVAL a = abs(DYNSELF.get_integer());
        VTABLE_set_integer_native(INTERP, SELF, a);
    }

/*

=item C<void freeze(visit_info *info)>

Used to archive the integer.

=cut

*/
    void freeze(visit_info *info) {
        IMAGE_IO *io = info->image_io;
        SUPER(info);
        io->vtable->push_integer(INTERP, io, PMC_int_val(SELF));
    }

/*

=item C<void thaw(visit_info *info)>

Used to unarchive the integer.

=cut

*/
    void thaw(visit_info *info) {
        IMAGE_IO *io = info->image_io;
        SUPER(info);
        if (info->extra_flags == EXTRA_IS_NULL)
            PMC_int_val(SELF) = io->vtable->shift_integer(INTERP, io);
    }
}

/*

=back

=cut

*/

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
 * vim: expandtab shiftwidth=4:
*/
