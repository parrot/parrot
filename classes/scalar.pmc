/*
Copyright: 2001-2003 The Perl Foundation.  All Rights Reserved.
$Id$

=head1 NAME

classes/scalar.pmc - Scalar Abstract Superclass

=head1 DESCRIPTION

These are the vtable functions for the scalar base PMC class

=head2 Methods

=over 4

=cut

*/

#include "parrot/parrot.h"

pmclass scalar abstract noinit {

/*

=item C<PMC *clone()>

Creates and returns a clone of the scalar.

=cut

*/

    PMC* clone () {
        PMC* dest = pmc_new(INTERP, SELF->vtable->base_type);
        memcpy(&PMC_union(dest), &PMC_union(SELF), sizeof(UnionVal));
        return dest;
    }


/*

=back

=head1 Mathematical Methods

=over 4


/*

=item C<PMC* subtract(PMC *value, PMC *dest)>

=cut

*/

/*

=item C<void add(PMC *value, PMC *dest)>

=item C<void add_int(INTVAL value, PMC *dest)>

=item C<void add_float(FLOATVAL value, PMC *dest)>

Adds C<value> to the number and returns the result in C<*dest>.
If C<dest> is NULL it's created.

=item C<void i_add(PMC *value)>

=item C<void i_add(INTVAL value)>

=item C<void i_add(FLOATVAL value)>

Adds C<value> to C<SELF> inplace.

=cut

*/

    PMC* add (PMC* value, PMC* dest) {
MMD_Complex: {
            FLOATVAL a = DYNSELF.get_number();
            if (dest)
                VTABLE_morph(INTERP, dest, value->vtable->base_type);
            else
                dest = pmc_new(INTERP, value->vtable->base_type);
            VTABLE_set_number_native(INTERP, dest,
                    a + VTABLE_get_number_keyed_int(INTERP, value, 0));
            VTABLE_set_number_keyed_int(INTERP, dest, 1,
                    VTABLE_get_number_keyed_int(INTERP, value, 1));
            return dest;
        }
MMD_DEFAULT: {
            if (!dest)
                dest = pmc_new(INTERP, SELF->vtable->base_type);
            VTABLE_set_number_native(INTERP, dest,
                    DYNSELF.get_number() + VTABLE_get_number(INTERP, value));
            return dest;
        }
    }

    PMC* add_int (INTVAL value, PMC* dest) {
        if (!dest)
            dest = pmc_new(INTERP, SELF->vtable->base_type);
        VTABLE_set_number_native(INTERP, dest,
                DYNSELF.get_number() + (FLOATVAL)value);
        return dest;
    }

    PMC* add_float (FLOATVAL value, PMC* dest) {
        if (!dest)
            dest = pmc_new(INTERP, SELF->vtable->base_type);
        VTABLE_set_number_native(INTERP, dest,
                DYNSELF.get_number() + value);
        return dest;
    }

    void i_add (PMC* value) {
MMD_Complex: {
            FLOATVAL a = DYNSELF.get_number();
            VTABLE_morph(INTERP, SELF, value->vtable->base_type);
            VTABLE_set_number_native(INTERP, SELF,
                    a + VTABLE_get_number_keyed_int(INTERP, value, 0));
            VTABLE_set_number_keyed_int(INTERP, SELF, 1,
                    VTABLE_get_number_keyed_int(INTERP, value, 1));
        }
MMD_DEFAULT: {
            VTABLE_set_number_native(INTERP, SELF,
                DYNSELF.get_number() + VTABLE_get_number(INTERP, value));
        }
    }

    void i_add_int (INTVAL value) {
        VTABLE_set_number_native(INTERP, SELF,
            DYNSELF.get_number() + (FLOATVAL)value);
    }

    void i_add_float (FLOATVAL value) {
        VTABLE_set_number_native(INTERP, SELF,
            DYNSELF.get_number() + value);
    }

/*

=item C<PMC* subtract(PMC *value, PMC *dest)>

=item C<PMC* subtract_int(INTVAL value, PMC *dest)>

=item C<PMC* subtract_float(FLOATVAL value, PMC *dest)>

Subtracts C<value> from the number and returns the result in C<*dest>.
If C<dest> doesn't exist a new C<Float> is created.

=item C<void i_subtract(PMC *value)>

=item C<void i_subtract_int(INTVAL value)>

=item C<void i_subtract_float(FLOATVAL value)>

Subtracts C<value> from C<SELF> inplace.

=cut

*/

    PMC* subtract (PMC* value, PMC* dest) {
MMD_Complex: {
            FLOATVAL a = DYNSELF.get_number();
            if (dest)
                VTABLE_morph(INTERP, dest, value->vtable->base_type);
            else
                dest = pmc_new(INTERP, value->vtable->base_type);
            VTABLE_set_number_native(INTERP, dest,
                    a - VTABLE_get_number_keyed_int(INTERP, value, 0));
            VTABLE_set_number_keyed_int(INTERP, dest, 1,
                    -VTABLE_get_number_keyed_int(INTERP, value, 1));
            return dest;
        }
MMD_DEFAULT: {
            if (!dest)
                dest = pmc_new(INTERP, SELF->vtable->base_type);
            VTABLE_set_number_native(INTERP, dest,
                    DYNSELF.get_number() - VTABLE_get_number(INTERP, value));
            return dest;
        }
    }

    PMC* subtract_int (INTVAL value, PMC* dest) {
        if (!dest)
            dest = pmc_new(INTERP, SELF->vtable->base_type);
        VTABLE_set_number_native(INTERP, dest,
                DYNSELF.get_number() - (FLOATVAL)value);
        return dest;
    }

    PMC* subtract_float (FLOATVAL value, PMC* dest) {
        if (!dest)
            dest = pmc_new(INTERP, SELF->vtable->base_type);
        VTABLE_set_number_native(INTERP, dest,
                DYNSELF.get_number() - value);
        return dest;
    }

    void i_subtract (PMC* value) {
MMD_Complex: {
            FLOATVAL a = DYNSELF.get_number();
            VTABLE_morph(INTERP, SELF, value->vtable->base_type);
            VTABLE_set_number_native(INTERP, SELF,
                    a - VTABLE_get_number_keyed_int(INTERP, value, 0));
            VTABLE_set_number_keyed_int(INTERP, SELF, 1,
                    -VTABLE_get_number_keyed_int(INTERP, value, 1));
        }
MMD_DEFAULT: {
            VTABLE_set_number_native(INTERP, SELF,
                DYNSELF.get_number() - VTABLE_get_number(INTERP, value));
        }
    }

    void i_subtract_int (INTVAL value) {
        VTABLE_set_number_native(INTERP, SELF,
            DYNSELF.get_number() - (FLOATVAL)value);
    }

    void i_subtract_float (FLOATVAL value) {
        VTABLE_set_number_native(INTERP, SELF,
            DYNSELF.get_number() - value);
    }


/*

=item C<PMC* multiply(PMC *value, PMC *dest)>

=item C<PMC* multiply_int(INTVAL value, PMC *dest)>

=item C<PMC* multiply_float(FLOATVAL value, PMC *dest)>

Multiplies the number by C<value> and returns the result in C<*dest>.

=cut

*/

    PMC* multiply (PMC* value, PMC* dest) {
MMD_Complex: {
            internal_exception(1, "TODO mul<Float, Complex>");
            return dest;
        }
MMD_DEFAULT: {
            if (!dest)
                dest = pmc_new(INTERP, SELF->vtable->base_type);
            VTABLE_set_number_native(INTERP, dest,
                DYNSELF.get_number() * VTABLE_get_number(INTERP, value));
            return dest;
        }
    }

    PMC* multiply_int (INTVAL value, PMC* dest) {
        if (!dest)
            dest = pmc_new(INTERP, SELF->vtable->base_type);
        VTABLE_set_number_native(INTERP, dest,
            DYNSELF.get_number() * value);
        return dest;
    }

    PMC* multiply_float (FLOATVAL value, PMC* dest) {
        if (!dest)
            dest = pmc_new(INTERP, SELF->vtable->base_type);
        VTABLE_set_number_native(INTERP, dest,
            DYNSELF.get_number() * value);
        return dest;
    }

    void i_multiply (PMC* value) {
MMD_Complex: {
            internal_exception(1, "TODO i_mul<Float, Complex>");
        }
MMD_DEFAULT: {
            VTABLE_set_number_native(INTERP, SELF,
                DYNSELF.get_number() * VTABLE_get_number(INTERP, value));
        }
    }

    void i_multiply_int (INTVAL value) {
        VTABLE_set_number_native(INTERP, SELF,
            DYNSELF.get_number() * (FLOATVAL)value);
    }

    void i_multiply_float (FLOATVAL value) {
        VTABLE_set_number_native(INTERP, SELF,
            DYNSELF.get_number() * value);
    }

/*

=item C<PMC* divide(PMC *value, PMC *dest)>

=item C<PMC* divide_int(INTVAL value, PMC *dest)>

=item C<PMC* divide_float(FLOATVAL value, PMC *dest)>

Divides the number by C<value> and returns the result in C<*dest>.

=item C<void i_divide(PMC *value)>

=item C<void i_divide_int(INTVAL value)>

=item C<void i_divide_float(FLOATVAL value)>

Divides C<SELF> by C<value> inplace.

=cut

*/

    PMC* divide (PMC* value, PMC* dest) {
        FLOATVAL d = VTABLE_get_number(INTERP, value);

        if (d == 0.0)
            real_exception(INTERP, NULL, E_ZeroDivisionError,
                    "float division by zero");
        if (!dest)
            dest = pmc_new(INTERP, SELF->vtable->base_type);
        VTABLE_set_number_native(INTERP, dest, DYNSELF.get_number() / d);
        return dest;
    }

    PMC* divide_int (INTVAL value, PMC* dest) {
        if (value == 0)
            real_exception(INTERP, NULL, E_ZeroDivisionError,
                    "float division by zero");
        if (!dest)
            dest = pmc_new(INTERP, SELF->vtable->base_type);
        VTABLE_set_number_native(INTERP, dest, DYNSELF.get_number() / value);
        return dest;
    }

    PMC* divide_float (FLOATVAL value, PMC* dest) {
        if (value == 0.0)
            real_exception(INTERP, NULL, E_ZeroDivisionError,
                    "float division by zero");
        if (!dest)
            dest = pmc_new(INTERP, SELF->vtable->base_type);
        VTABLE_set_number_native(INTERP, dest, DYNSELF.get_number() / value);
        return dest;
    }

    void i_divide (PMC* value) {
        FLOATVAL d = VTABLE_get_number(INTERP, value);

        if (d == 0.0)
            real_exception(INTERP, NULL, E_ZeroDivisionError,
                    "float division by zero");
        VTABLE_set_number_native(INTERP, SELF, DYNSELF.get_number() / d);
    }

    void i_divide_int (INTVAL value) {
        if (value == 0)
            real_exception(INTERP, NULL, E_ZeroDivisionError,
                    "float division by zero");
        VTABLE_set_number_native(INTERP, SELF, DYNSELF.get_number() / value);
    }

    void i_divide_float (FLOATVAL value) {
        if (value == 0.0)
            real_exception(INTERP, NULL, E_ZeroDivisionError,
                    "float division by zero");
        VTABLE_set_number_native(INTERP, SELF, DYNSELF.get_number() / value);
    }

/*

=item C<PMC* floor_divide(PMC *value, PMC *dest)>

=item C<PMC* floor_divide_int(INTVAL value, PMC *dest)>

=item C<PMC* floor_divide_float(FLOATVAL value, PMC *dest)>

Divides the number by C<value> and returns the result in C<*dest>.

=item C<void i_floor_divide(PMC *value)>

=item C<void i_floor_divide_int(INTVAL value)>

=item C<void i_floor_divide_float(FLOATVAL value)>

Divides C<SELF> by C<value> inplace.

=cut

*/

    PMC* floor_divide (PMC* value, PMC* dest) {
        FLOATVAL d = VTABLE_get_number(INTERP, value);

        if (d == 0.0)
            real_exception(INTERP, NULL, E_ZeroDivisionError,
                    "float division by zero");
        if (!dest)
            dest = pmc_new(INTERP, SELF->vtable->base_type);
        VTABLE_set_number_native(INTERP, dest,
                floor(DYNSELF.get_number() / d));
        return dest;
    }

    PMC* floor_divide_int (INTVAL value, PMC* dest) {
        if (value == 0)
            real_exception(INTERP, NULL, E_ZeroDivisionError,
                    "float division by zero");
        if (!dest)
            dest = pmc_new(INTERP, SELF->vtable->base_type);
        VTABLE_set_number_native(INTERP, dest,
                floor(DYNSELF.get_number() / value));
        return dest;
    }

    PMC* floor_divide_float (FLOATVAL value, PMC* dest) {
        if (value == 0.0)
            real_exception(INTERP, NULL, E_ZeroDivisionError,
                    "float division by zero");
        if (!dest)
            dest = pmc_new(INTERP, SELF->vtable->base_type);
        VTABLE_set_number_native(INTERP, dest,
                floor(DYNSELF.get_number() / value));
        return dest;
    }

    void i_floor_divide (PMC* value) {
        FLOATVAL d = VTABLE_get_number(INTERP, value);

        if (d == 0.0)
            real_exception(INTERP, NULL, E_ZeroDivisionError,
                    "float division by zero");
        VTABLE_set_number_native(INTERP, SELF,
                floor(DYNSELF.get_number() / d));
    }

    void i_floor_divide_int (INTVAL value) {
        if (value == 0)
            real_exception(INTERP, NULL, E_ZeroDivisionError,
                    "float division by zero");
        VTABLE_set_number_native(INTERP, SELF,
                floor(DYNSELF.get_number() / value));
    }

    void i_floor_divide_float (FLOATVAL value) {
        if (value == 0.0)
            real_exception(INTERP, NULL, E_ZeroDivisionError,
                    "float division by zero");
        VTABLE_set_number_native(INTERP, SELF,
                floor(DYNSELF.get_number() / value));
    }


/*

=item C<PMC* cmodulus(PMC *value, PMC *dest)>

=item C<PMC* cmodulus(INTVAL value, PMC *dest)>

=item C<PMC* cmodulus(FLOATVAL value, PMC *dest)>

Calculates the value of the number C-style C<mod> C<value> and returns
the result in C<dest>.

=item C<void i_cmodulus(PMC *value)>

=item C<void i_cmodulus(INTVAL value)>

=item C<void i_cmodulus(FLOATVAL value)>

Calculates the value of the number C-style C<mod> C<value> and returns
the result in C<dest>.

=cut

*/

    PMC* cmodulus (PMC* value, PMC* dest) {
        FLOATVAL d = VTABLE_get_number(INTERP, value);

        if (d == 0.0)
            real_exception(INTERP, NULL, E_ZeroDivisionError,
                    "float cmodulus by zero");
        if (!dest)
            dest = pmc_new(INTERP, SELF->vtable->base_type);
        VTABLE_set_number_native(INTERP, dest,
                fmod(DYNSELF.get_number(), d));
        return dest;
    }

    PMC* cmodulus_float (FLOATVAL value, PMC* dest) {
        if (value == 0.0)
            real_exception(INTERP, NULL, E_ZeroDivisionError,
                    "float cmodulus by zero");
        if (!dest)
            dest = pmc_new(INTERP, SELF->vtable->base_type);
        VTABLE_set_number_native(INTERP, dest,
                fmod(DYNSELF.get_number(), value));
        return dest;
    }

    PMC* cmodulus_float (FLOATVAL value, PMC* dest) {
        if (value == 0)
            real_exception(INTERP, NULL, E_ZeroDivisionError,
                    "float cmodulus by zero");
        if (!dest)
            dest = pmc_new(INTERP, SELF->vtable->base_type);
        VTABLE_set_number_native(INTERP, dest,
                fmod(DYNSELF.get_number(), value));
        return dest;
    }
    void i_cmodulus (PMC* value) {
        FLOATVAL d = VTABLE_get_number(INTERP, value);

        if (d == 0.0)
            real_exception(INTERP, NULL, E_ZeroDivisionError,
                    "float cmodulus by zero");
        VTABLE_set_number_native(INTERP, SELF,
                fmod(DYNSELF.get_number() , d));
    }

    void i_cmodulus_int (INTVAL value) {
        if (value == 0)
            real_exception(INTERP, NULL, E_ZeroDivisionError,
                    "float cmodulus by zero");
        VTABLE_set_number_native(INTERP, SELF,
                fmod(DYNSELF.get_number() , value));
    }

    void i_cmodulus_float (FLOATVAL value) {
        if (value == 0.0)
            real_exception(INTERP, NULL, E_ZeroDivisionError,
                    "float cmodulus by zero");
        VTABLE_set_number_native(INTERP, SELF,
                fmod(DYNSELF.get_number() , value));
    }

/*

=item C<PMC* modulus(PMC *value, PMC *dest)>

=item C<PMC* modulus(INTVAL value, PMC *dest)>

=item C<PMC* modulus(FLOATVAL value, PMC *dest)>

Calculates the value of corrected C<mod> C<value> and returns
the result in C<dest>. See also ops/math.ops.

=item C<void i_modulus(PMC *value)>

=item C<void i_modulus(INTVAL value)>

=item C<void i_modulus(FLOATVAL value)>

Calculates modulus inplace

=cut

*/

    PMC* modulus (PMC* value, PMC* dest) {
        FLOATVAL d = VTABLE_get_number(INTERP, value);

        if (d == 0.0)
            real_exception(INTERP, NULL, E_ZeroDivisionError,
                    "float modulus by zero");
        if (!dest)
            dest = pmc_new(INTERP, SELF->vtable->base_type);
        VTABLE_set_number_native(INTERP, dest,
                floatval_mod(DYNSELF.get_number(), d));
        return dest;
    }

    PMC* modulus_int (INTVAL value, PMC* dest) {
        if (value == 0)
            real_exception(INTERP, NULL, E_ZeroDivisionError,
                    "float modulus by zero");
        if (!dest)
            dest = pmc_new(INTERP, SELF->vtable->base_type);
        VTABLE_set_number_native(INTERP, dest,
                floatval_mod(DYNSELF.get_number(), value));
        return dest;
    }

    PMC* modulus_float (FLOATVAL value, PMC* dest) {
        if (value == 0.0)
            real_exception(INTERP, NULL, E_ZeroDivisionError,
                    "float modulus by zero");
        if (!dest)
            dest = pmc_new(INTERP, SELF->vtable->base_type);
        VTABLE_set_number_native(INTERP, dest,
                floatval_mod(DYNSELF.get_number(), value));
        return dest;
    }

    void i_modulus (PMC* value) {
        FLOATVAL d = VTABLE_get_number(INTERP, value);

        if (d == 0.0)
            real_exception(INTERP, NULL, E_ZeroDivisionError,
                    "float modulus by zero");
        VTABLE_set_number_native(INTERP, SELF,
                floatval_mod(DYNSELF.get_number() , d));
    }

    void i_modulus_int (INTVAL value) {
        if (value == 0)
            real_exception(INTERP, NULL, E_ZeroDivisionError,
                    "float modulus by zero");
        VTABLE_set_number_native(INTERP, SELF,
                floatval_mod(DYNSELF.get_number() , value));
    }

    void i_modulus_float (FLOATVAL value) {
        if (value == 0.0)
            real_exception(INTERP, NULL, E_ZeroDivisionError,
                    "float modulus by zero");
        VTABLE_set_number_native(INTERP, SELF,
                floatval_mod(DYNSELF.get_number() , value));
    }

/*

=item C<PMC* pow(PMC *value, PMC *dest)>

=item C<PMC* pow_int(INTVAL value, PMC *dest)>

=item C<PMC* pow_float(FLOATVAL value, PMC *dest)>

Calculates  C<SELF pow value> and returns
the result in C<dest>. See also ops/math.ops.

=item C<void i_pow(PMC *value)>

=item C<void i_pow_int(INTVAL value)>

=item C<void i_pow_float(FLOATVAL value)>

Calculates pow inplace

=cut

*/

    PMC* pow (PMC* value, PMC* dest) {
        FLOATVAL d = VTABLE_get_number(INTERP, value);

        if (!dest)
            dest = pmc_new(INTERP, SELF->vtable->base_type);
        VTABLE_set_number_native(INTERP, dest,
                pow(DYNSELF.get_number(), d));
        return dest;
    }

    PMC* pow_int (INTVAL value, PMC* dest) {
        if (!dest)
            dest = pmc_new(INTERP, SELF->vtable->base_type);
        VTABLE_set_number_native(INTERP, dest,
                pow(DYNSELF.get_number(), value));
        return dest;
    }

    PMC* pow_float (FLOATVAL value, PMC* dest) {
        if (!dest)
            dest = pmc_new(INTERP, SELF->vtable->base_type);
        VTABLE_set_number_native(INTERP, dest,
                pow(DYNSELF.get_number(), value));
        return dest;
    }

    void i_pow (PMC* value) {
        FLOATVAL d = VTABLE_get_number(INTERP, value);

        VTABLE_set_number_native(INTERP, SELF,
                pow(DYNSELF.get_number(), d));
    }

    void i_pow_int (INTVAL value) {
        VTABLE_set_number_native(INTERP, SELF,
                pow(DYNSELF.get_number(), value));
    }

    void i_pow_float (FLOATVAL value) {
        VTABLE_set_number_native(INTERP, SELF,
                pow(DYNSELF.get_number(), value));
    }

/*

=item C<void neg(PMC *dest)>

Set C<dest> to the negated value of C<SELF>.

=cut

*/

    void neg (PMC* dest) {
        VTABLE_set_number_native(INTERP, dest, -DYNSELF.get_number());
    }

/*

=back

=head2 Bitwise Methods

=over 4

=item C<PMC* bitwise_or(PMC *value, PMC *dest)>

=item C<PMC* bitwise_or_int(INTVAL value, PMC *dest)>

Returns in C<*dest> the bitwise C<OR> of the scalar and C<value>.

=item C<void i_bitwise_or(PMC *value)>

=item C<void i_bitwise_or_int(INTVAL value)>

Inplace bitwise or.

=cut

*/

    PMC* bitwise_or (PMC* value, PMC* dest) {
        INTVAL result;

        result = DYNSELF.get_integer() | VTABLE_get_integer(INTERP, value);
        if (!dest)
            dest = pmc_new(INTERP, SELF->vtable->base_type);
        VTABLE_set_integer_native(INTERP, dest, result);
        return dest;
    }


    PMC* bitwise_or_int (INTVAL value, PMC* dest) {
        INTVAL result;

        result = DYNSELF.get_integer() | value;
        if (!dest)
            dest = pmc_new(INTERP, SELF->vtable->base_type);
        VTABLE_set_integer_native(INTERP, dest, result);
        return dest;
    }

    void i_bitwise_or (PMC* value) {
        INTVAL result;

        result = DYNSELF.get_integer() | VTABLE_get_integer(INTERP, value);
        DYNSELF.set_integer_native(result);
    }


    void i_bitwise_or_int (INTVAL value) {
        INTVAL result;

        result = DYNSELF.get_integer() | value;
        DYNSELF.set_integer_native(result);
    }

/*

=item C<PMC* bitwise_and(PMC *value, PMC *dest)>

=item C<PMC* bitwise_and_int(INTVAL value, PMC *dest)>

Returns in C<*dest> the bitwise C<AND> of the scalar and C<value>.

=item C<void i_bitwise_and(PMC *value)>

=item C<void i_bitwise_and_int(INTVAL value)>

Inplace bitwise and.

=cut

*/

    PMC* bitwise_and (PMC* value, PMC* dest) {
        INTVAL result;

        result = DYNSELF.get_integer() & VTABLE_get_integer(INTERP, value);
        if (!dest)
            dest = pmc_new(INTERP, SELF->vtable->base_type);
        VTABLE_set_integer_native(INTERP, dest, result);
        return dest;
    }

    PMC* bitwise_and_int (INTVAL value, PMC* dest) {
        INTVAL result;

        result = DYNSELF.get_integer() & value;
        if (!dest)
            dest = pmc_new(INTERP, SELF->vtable->base_type);
        VTABLE_set_integer_native(INTERP, dest, result);
        return dest;
    }

    void i_bitwise_and (PMC* value) {
        INTVAL result;

        result = DYNSELF.get_integer() & VTABLE_get_integer(INTERP, value);
        DYNSELF.set_integer_native(result);
    }


    void i_bitwise_and_int (INTVAL value) {
        INTVAL result;

        result = DYNSELF.get_integer() & value;
        DYNSELF.set_integer_native(result);
    }

/*

=item C<void bitwise_xor(PMC *value, PMC *dest)>

=item C<void bitwise_xor_int(INTVAL value, PMC *dest)>

Returns in C<*dest> the bitwise C<XOR> of the scalar and C<*value>.

=item C<void i_bitwise_xor(PMC *value)>

=item C<void i_bitwise_xor_int(INTVAL value)>

Inplace bitwise and.

=cut

*/

    PMC* bitwise_xor (PMC* value, PMC* dest) {
        INTVAL result;

        result = DYNSELF.get_integer() ^ VTABLE_get_integer(INTERP, value);
        if (!dest)
            dest = pmc_new(INTERP, SELF->vtable->base_type);
        VTABLE_set_integer_native(INTERP, dest, result);
        return dest;
    }

    PMC* bitwise_xor_int (INTVAL value, PMC* dest) {
        INTVAL result;

        result = DYNSELF.get_integer() ^ value;
        if (!dest)
            dest = pmc_new(INTERP, SELF->vtable->base_type);
        VTABLE_set_integer_native(INTERP, dest, result);
        return dest;
    }

    void i_bitwise_xor (PMC* value) {
        INTVAL result;

        result = DYNSELF.get_integer() ^ VTABLE_get_integer(INTERP, value);
        DYNSELF.set_integer_native(result);
    }

    void i_bitwise_xor_int (INTVAL value) {
        INTVAL result;

        result = DYNSELF.get_integer() ^ value;
        DYNSELF.set_integer_native(result);
    }

/*

=item C<void bitwise_not(PMC *dest)>

Returns in C<*dest> the bitwise negation of the scalar and C<value>.

=cut

*/

    void bitwise_not (PMC* dest) {
        VTABLE_set_integer_native(INTERP, dest, ~DYNSELF.get_integer());
    }


/*

=item C<PMC* bitwise_shr(PMC *value, PMC *dest)>

=item C<PMC* bitwise_shr_int(INTVAL value, PMC *dest)>

Returns in C<*dest> the arithmetic shift right of the scalar by C<value>.

=item C<void i_bitwise_shr(PMC *value)>

=item C<void i_bitwise_shr_int(INTVAL value)>

Inplace shift right.

=cut

*/

    PMC* bitwise_shr (PMC* value, PMC* dest) {
        INTVAL result;

        result = DYNSELF.get_integer() >> VTABLE_get_integer(INTERP, value);
        if (!dest)
            dest = pmc_new(INTERP, SELF->vtable->base_type);
        VTABLE_set_integer_native(INTERP, dest, result);
        return dest;
    }

    PMC* bitwise_shr_int (INTVAL value, PMC* dest) {
        INTVAL result;

        result = DYNSELF.get_integer() >> value;
        if (!dest)
            dest = pmc_new(INTERP, SELF->vtable->base_type);
        VTABLE_set_integer_native(INTERP, dest, result);
        return dest;
    }

    void i_bitwise_shr (PMC* value) {
        INTVAL result;

        result = DYNSELF.get_integer() >> VTABLE_get_integer(INTERP, value);
        DYNSELF.set_integer_native(result);
    }

    void i_bitwise_shr_int (INTVAL value) {
        INTVAL result;

        result = DYNSELF.get_integer() >> value;
        DYNSELF.set_integer_native(result);
    }

/*

=item C<PMC* bitwise_lsr(PMC *value, PMC *dest)>

=item C<PMC* bitwise_lsr_int(INTVAL value, PMC *dest)>

Returns in C<*dest> the logical shift right of the scalar by C<*value>.

=item C<void i_bitwise_lsr(PMC *value)>

=item C<void i_bitwise_lsr_int(INTVAL value)>

Inplace shift right.

=cut

*/

    PMC* bitwise_lsr (PMC* value, PMC* dest) {
        INTVAL result;

        result = (UINTVAL)DYNSELF.get_integer() >>
            VTABLE_get_integer(INTERP, value);
        if (!dest)
            dest = pmc_new(INTERP, SELF->vtable->base_type);
        VTABLE_set_integer_native(INTERP, dest, result);
        return dest;
    }

    PMC* bitwise_lsr_int (INTVAL value, PMC* dest) {
        INTVAL result;

        result = (UINTVAL)DYNSELF.get_integer() >> value;
        if (!dest)
            dest = pmc_new(INTERP, SELF->vtable->base_type);
        VTABLE_set_integer_native(INTERP, dest, result);
        return dest;
    }

    void i_bitwise_lsr (PMC* value) {
        INTVAL result;

        result = (UINTVAL)DYNSELF.get_integer() >>
                VTABLE_get_integer(INTERP, value);
        DYNSELF.set_integer_native(result);
    }

    void i_bitwise_lsr_int (INTVAL value) {
        INTVAL result;

        result = (UINTVAL)DYNSELF.get_integer() >> value;
        DYNSELF.set_integer_native(result);
    }

/*

=item C<PMC* bitwise_shl(PMC *value, PMC *dest)>

=item C<PMC* bitwise_shl_int(INTVAL value, PMC *dest)>

Returns in C<*dest> the shift left of the scalar by C<*value>.

=item C<void i_bitwise_shl(PMC *value)>

=item C<void i_bitwise_shl_int(INTVAL value)>

Inplace shift left.

=cut

*/

    PMC* bitwise_shl (PMC* value, PMC* dest) {
        INTVAL result;

        result = DYNSELF.get_integer() << VTABLE_get_integer(INTERP, value);
        if (!dest)
            dest = pmc_new(INTERP, SELF->vtable->base_type);
        VTABLE_set_integer_native(INTERP, dest, result);
        return dest;
    }

    PMC* bitwise_shl_int (INTVAL value, PMC* dest) {
        INTVAL result;

        result = DYNSELF.get_integer() << value;
        if (!dest)
            dest = pmc_new(INTERP, SELF->vtable->base_type);
        VTABLE_set_integer_native(INTERP, dest, result);
        return dest;
    }

    void i_bitwise_shl (PMC* value) {
        INTVAL result;

        result = DYNSELF.get_integer() << VTABLE_get_integer(INTERP, value);
        DYNSELF.set_integer_native(result);
    }

    void i_bitwise_shl_int (INTVAL value) {
        INTVAL result;

        result = DYNSELF.get_integer() << value;
        DYNSELF.set_integer_native(result);
    }

/*

=back

=head2 String Methods

=over 4

=item C<PMC* concatenate(PMC *value, PMC *dest)>

=item C<PMC* concatenate_str(STRING *value, PMC *dest)>

Returns in C<*dest> the result of concatenating the scalar and C<*value>.

=item C<void concatenate(PMC *value)>

=item C<void concatenate_str(STRING *value)>

Concatenate the string C<value> in place.

=cut

*/

    PMC* concatenate (PMC* value,  PMC* dest) {
        STRING* s = string_concat(INTERP,
            DYNSELF.get_string(),
            VTABLE_get_string(INTERP, value), 0);
        if (!dest)
            dest = pmc_new(INTERP, SELF->vtable->base_type);
        VTABLE_set_string_native(INTERP, dest, s);
        return dest;
    }

    PMC* concatenate_str (STRING* value,  PMC* dest) {
        STRING* s = string_concat(INTERP,
            DYNSELF.get_string(), value, 0);
        if (!dest)
            dest = pmc_new(INTERP, SELF->vtable->base_type);
        VTABLE_set_string_native(INTERP, dest, s);
        return dest;
    }

    void i_concatenate (PMC* value) {
        STRING* s = DYNSELF.get_string();
        STRING* v = VTABLE_get_string(INTERP, value);
        DYNSELF.set_string_native(string_append(INTERP, s, v, 1));
    }

    void i_concatenate_str (STRING* value) {
        STRING* s = DYNSELF.get_string();
        DYNSELF.set_string_native( string_append(INTERP, s, value, 1));
    }

/*

=item C<PMC* repeat(PMC *value, PMC *dest)>

=item C<PMC* repeat_int(INTVAL value, PMC *dest)>

Returns in C<*dest> the result of repeating the scalar C<value> times.

=item C<void i_repeat(PMC *value)>

=item C<void i_repeat_int(INTVAL value)>

Repeat the string C<SELF> in place C<value> times.

=cut

*/

    PMC* repeat (PMC* value,  PMC* dest) {
        STRING* s = DYNSELF.get_string();
        UINTVAL n = (UINTVAL)VTABLE_get_integer(INTERP, value);
        if (!dest)
            dest = pmc_new(INTERP, SELF->vtable->base_type);
        VTABLE_set_string_native(INTERP, dest,
            string_repeat(INTERP, s, n, NULL));
        return dest;
    }

    PMC* repeat_int (INTVAL value, PMC* dest) {
        STRING* s = DYNSELF.get_string();
        UINTVAL n = value;
        if (!dest)
            dest = pmc_new(INTERP, SELF->vtable->base_type);
        VTABLE_set_string_native(INTERP, dest,
            string_repeat(INTERP, s, n, NULL));
        return dest;
    }


    void i_repeat (PMC* value) {
        STRING* s = DYNSELF.get_string();
        UINTVAL n = (UINTVAL)VTABLE_get_integer(INTERP, value);
        DYNSELF.set_string_native(string_repeat(INTERP, s, n, NULL));
    }

    void i_repeat_int (INTVAL value) {
        STRING* s = DYNSELF.get_string();
        UINTVAL n = value;
        DYNSELF.set_string_native(string_repeat(INTERP, s, n, NULL));
    }



/*

=back

=head2 Compare Methods

=over 4

=item C<INTVAL cmp_num(PMC *value)>

Returns the result of comparing the floating-point values of the scalar
and C<*value>.

=cut

*/

    INTVAL cmp_num (PMC* value) {
        /* XXX - Floating-point precision errors possible? */
        FLOATVAL diff = VTABLE_get_number(INTERP, value) -
                        DYNSELF.get_number();

        return diff == 0.0 ? 0 : diff < 0.0 ? -1 : 1;
    }

/*

=item C<INTVAL cmp_string(PMC *value)>

Returns the result of comparing the string values of the scalar and
C<*value>.

=cut

*/

    INTVAL cmp_string (PMC* value) {
        return string_compare(INTERP, DYNSELF.get_string(),
            VTABLE_get_string(INTERP, value));
    }

/*

=back

=head2 Logical Methods

=over 4

=item C<void logical_or(PMC *value, PMC *dest)>

Returns in C<*dest> the result of the logical C<OR> of the scalar and
C<*value>.

=cut

*/

    void logical_or (PMC* value,  PMC* dest) {
        if (DYNSELF.get_bool()) {
            VTABLE_set_pmc(INTERP, dest, SELF);
        }
        else {
            VTABLE_set_pmc(INTERP, dest, value);
        }
    }

/*

=item C< void logical_and(PMC *value, PMC *dest)>

Returns in C<*dest> the result of the logical C<AND> of the scalar and
C<*value>.

=cut

*/

    void logical_and (PMC* value,  PMC* dest) {
        if (DYNSELF.get_bool()) {
            VTABLE_set_pmc(INTERP, dest, value);
        }
        else {
            VTABLE_set_pmc(INTERP, dest, SELF);
        }
    }

/*

=item C<void logical_xor(PMC *value, PMC *dest)>

Returns in C<*dest> the result of the logical C<XOR> of the scalar and
C<*value>.

=cut

*/

    void logical_xor (PMC* value,  PMC* dest) {

        INTVAL my_bool, value_bool;

        my_bool = DYNSELF.get_bool();
        value_bool = VTABLE_get_bool(INTERP, value);

        if (my_bool && ! value_bool) {
            VTABLE_set_pmc(INTERP, dest, SELF);
        }
        else if (value_bool && ! my_bool) {
            VTABLE_set_pmc(INTERP, dest, value);
        }
        else {
            /* XXX - Need a better way to set FALSE */
            VTABLE_set_integer_native(INTERP, dest, 0);
        }
    }

/*

=item C<void logical_not(PMC *dest)>

Returns in C<*dest> the result of the logical negation of the scalar and
C<*value>.

=cut

*/

    void logical_not (PMC* dest) {
        /* XXX - Need a better way to set boolean state */
        VTABLE_set_integer_native(INTERP, dest,
            ! DYNSELF.get_bool());
    }


/*

=item C<INTVAL defined()>

Always returns true.

=cut

*/

    INTVAL defined () {
        return 1;
    }


/*

=item C<STRING *substr_str(INTVAL offset, INTVAL length)>

Returns the substring of length C<length> of the scalar starting at
C<offset>.

=cut

*/

    STRING* substr_str(INTVAL offset, INTVAL length) {
        return string_substr(INTERP, VTABLE_get_string(INTERP,SELF),
            offset, length, NULL, 0);
    }

}

/*

=back

=cut

*/

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
 * vim: expandtab shiftwidth=4:
*/
