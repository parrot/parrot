/*
Copyright: 2001-2003 The Perl Foundation.  All Rights Reserved.
$Id$

=head1 NAME

classes/scalar.pmc - Scalar Abstract Superclass

=head1 DESCRIPTION

These are the vtable functions for the scalar base PMC class

=head2 Methods

=over 4

=cut

*/

#include "parrot/parrot.h"

#define INT2KEY(i,k) ((k) ? key_new_integer((i), *(k)) : NULL)

pmclass scalar abstract noinit {

/*

=item C<PMC *clone()>

Creates and returns a clone of the scalar.

=cut

*/

    PMC* clone () {
        PMC* dest = pmc_new(INTERP, SELF->vtable->base_type);
        memcpy(&PMC_union(dest), &PMC_union(SELF), sizeof(UnionVal));
        return dest;
    }

/*

=item C<INTVAL get_integer()>

Returns the integer value of the scalar.

=cut

*/

    INTVAL get_integer () {
        return PMC_int_val(SELF);
    }

/*

=item C<FLOATVAL get_number()>

Returns the floating-point value of the scalar.

=cut

*/

    FLOATVAL get_number () {
        return PMC_num_val(SELF);
    }


/*

=item C<STRING *get_string()>


=cut

*/

    STRING* get_string () {
        return (STRING*) PMC_str_val(SELF);
    }

/*

=item C<INTVAL get_bool()>

Returns the boolean value for the scalar.

=cut

*/

    INTVAL get_bool () {
        return PMC_int_val(SELF) != 0;
    }

/*

=back

=head2 Accessor Methods

The set methods merely make the appropriate part of the cache be what it
should be, more complex behaviour is left as an exercise for the
inheriting class.

=over 4

=item C<void set_integer_native(INTVAL value)>

Sets the integer value.

=cut

*/

    void set_integer_native (INTVAL value) {
        PMC_int_val(SELF) = value;
    }

/*

=item C<void set_number_native(FLOATVAL value)>

Sets the floating-point value.

=cut

*/

    void set_number_native (FLOATVAL value) {
        PMC_num_val(SELF) = value;
    }


/*

=item C<void set_string_native(STRING *value)>

Sets the Parrot string value.

=cut

*/

    void set_string_native (STRING* value) {
        PMC_str_val(SELF) = string_copy(INTERP, value);
    }

/*

=back

=head1 Mathematical Methods

=over 4

=item C<PMC* add_int(INTVAL value, PMC *dest)>

Adds C<value> to the scalar and returns the result in C<*dest>.

=cut

*/

    PMC* add_int (INTVAL value, PMC* dest) {
        INTVAL result;

        result = DYNSELF.get_integer() + value;
        if (!dest)
            dest = pmc_new(INTERP, SELF->vtable->base_type);
        VTABLE_set_integer_native(INTERP, dest, result);
        return dest;
    }

/*

=item C<PMC* add_float(FLOATVAL value, PMC *dest)>

Adds C<value> to the scalar and returns the result in C<*dest>.

=cut

*/

    PMC* add_float (FLOATVAL value, PMC* dest) {
        FLOATVAL result;

        result = DYNSELF.get_number() + value;

        if (!dest)
            dest = pmc_new(INTERP, SELF->vtable->base_type);
        VTABLE_set_number_native(INTERP, dest, result);
        return dest;
    }

/*

=item C<PMC* subtract(PMC *value, PMC *dest)>

=cut

*/

    PMC* subtract (PMC* value,  PMC* dest) {
        FLOATVAL result;

        result = DYNSELF.get_number()
            - VTABLE_get_number(INTERP, value);

        if (!dest)
            dest = pmc_new(INTERP, SELF->vtable->base_type);
        VTABLE_set_number_native(INTERP, dest, result);
        return dest;
    }

/*

=item C<PMC* subtract_int(INTVAL value, PMC *dest)>

Subtracts C<value> from the scalar and returns the result in C<*dest>.

TODO - overflow detection, bigint promotion?

=cut

*/

    PMC* subtract_int (INTVAL value,  PMC* dest) {
        FLOATVAL result;

        result = DYNSELF.get_number()
            - value;

        if (!dest)
            dest = pmc_new(INTERP, SELF->vtable->base_type);
        VTABLE_set_number_native(INTERP, dest, result);
        return dest;
    }


/*

=item C<PMC* subtract_float (FLOATVAL value,  PMC* dest)>

Subtracts C<value> from the scalar and returns the result in C<*dest>.

TODO - overflow detection, bigint promotion?

=cut

*/

    PMC* subtract_float (FLOATVAL value,  PMC* dest) {
        FLOATVAL result;

        result = DYNSELF.get_number() - value;
        if (!dest)
            dest = pmc_new(INTERP, SELF->vtable->base_type);
        VTABLE_set_number_native(INTERP, dest, result);
        return dest;
    }

/*

=item C<PMC* multiply (PMC* value,  PMC* dest)>

Multiplies the scalar by C<*value> and returns the result in C<*dest>.

=cut

*/

    PMC* multiply (PMC* value,  PMC* dest) {
        FLOATVAL result;

        result = DYNSELF.get_number() * VTABLE_get_number(INTERP, value);
        if (!dest)
            dest = pmc_new(INTERP, SELF->vtable->base_type);
        VTABLE_set_number_native(INTERP, dest, result);
        return dest;
    }

/*

=item C<PMC* multiply_int(INTVAL value,  PMC *dest)>

Multiplies the scalar by C<value> and returns the result in C<*dest>.

=cut

*/

    PMC* multiply_int (INTVAL value,  PMC* dest) {
        FLOATVAL result;

        result = DYNSELF.get_number() * value;
        if (!dest)
            dest = pmc_new(INTERP, SELF->vtable->base_type);
        VTABLE_set_number_native(INTERP, dest, result);
        return dest;
    }

/*

=item C<PMC* multiply_float(FLOATVAL value, PMC *dest)>

Multiplies the scalar by C<value> and returns the result in C<*dest>.

=cut

*/

    PMC* multiply_float (FLOATVAL value,  PMC* dest) {
        FLOATVAL result;

        result = DYNSELF.get_number() * value;
        VTABLE_set_number_native(INTERP, dest, result);
        if (!dest)
            dest = pmc_new(INTERP, SELF->vtable->base_type);
        return dest;
    }

/*

=item C<void divide(PMC *value, PMC *dest)>

Divides the scalar by C<*value> and returns the result in C<*dest>.

TODO - overflow detection, bigint promotion?

=cut

*/

    void divide (PMC* value,  PMC* dest) {
        FLOATVAL result;

        result = DYNSELF.get_number()
            / VTABLE_get_number(INTERP, value);

        VTABLE_set_number_native(INTERP, dest, result);
    }

/*

=item C<void divide_int(INTVAL value, PMC *dest)>

Divides the scalar by C<value> and returns the result in C<*dest>.

TODO - overflow detection, bigint promotion?

=cut

*/

    void divide_int (INTVAL value,  PMC* dest) {
        FLOATVAL result;

        result = DYNSELF.get_number()
            / value;

        VTABLE_set_number_native(INTERP, dest, result);
    }

/*

=item C<void divide_float(FLOATVAL value, PMC *dest)>

Divides the scalar by C<value> and returns the result in C<*dest>.

TODO - overflow detection, bigint promotion?

=cut

*/

    void divide_float (FLOATVAL value,  PMC* dest) {
        /* dest = SELF / value */

        /* XXX: overflow detection, bignum promotion? */

        FLOATVAL result;

        result = DYNSELF.get_number()
            / value;

        VTABLE_set_number_native(INTERP, dest, result);
    }

/*

=item C<void modulus(PMC* value, PMC* dest)>

This does perl-like modulus.

Returns in C<*dest> the value of the scalar C<mod> the integer value of
C<*value>.

=cut

*/

    void modulus (PMC* value,  PMC* dest) {
        INTVAL result;

        result = DYNSELF.get_integer()
            % VTABLE_get_integer(INTERP, value);

        VTABLE_set_integer_native(INTERP, dest, result);
    }

/*

=item C<void modulus_int(INTVAL value, PMC* dest)>

Returns in C<*dest> the value of the scalar C<mod> C<value>.

=cut

*/

    void modulus_int (INTVAL value,  PMC* dest) {
        INTVAL result;

        result = DYNSELF.get_integer()
            % value;

        VTABLE_set_integer_native(INTERP, dest, result);
    }

/*

=item C<void modulus_float(FLOATVAL value, PMC *dest)>

Calls the superclass implementation.

=cut

*/

    void modulus_float (FLOATVAL value,  PMC* dest) {
        SUPER(value, dest);
    }

/*

=item C<void neg(PMC *dest)>

Set C<dest> to the negated value of C<SELF>.

=cut

*/

    void neg (PMC* dest) {
        VTABLE_set_integer_native(INTERP, dest, -DYNSELF.get_integer());
    }

/*

=back

=head2 Bitwise Methods

=over 4

=item C<void bitwise_or(PMC *value, PMC *dest)>

Returns in C<*dest> the bitwise C<OR> of the scalar and C<*value>.

=cut

*/

    void bitwise_or (PMC* value, PMC* dest) {
        INTVAL result;

        result = DYNSELF.get_integer()
            | VTABLE_get_integer(INTERP, value);

        VTABLE_set_integer_native(INTERP, dest, result);
    }

/*

=item C<void bitwise_or_int(INTVAL value, PMC *dest)>

Returns in C<*dest> the bitwise C<OR> of the scalar and C<value>.

=cut

*/

    void bitwise_or_int (INTVAL value, PMC* dest) {
        INTVAL result;

        result = DYNSELF.get_integer()
            | value;

        VTABLE_set_integer_native(INTERP, dest, result);
    }

/*

=item C<void bitwise_and(PMC *value, PMC *dest)>

Returns in C<*dest> the bitwise C<AND> of the scalar and C<*value>.

=cut

*/

    void bitwise_and (PMC* value, PMC* dest) {
        INTVAL result;

        result = DYNSELF.get_integer()
            & VTABLE_get_integer(INTERP, value);

        VTABLE_set_integer_native(INTERP, dest, result);
    }

/*

=item C<void bitwise_and_int(INTVAL value, PMC *dest)>

Returns in C<*dest> the bitwise C<AND> of the scalar and C<value>.

=cut

*/

    void bitwise_and_int (INTVAL value, PMC* dest) {
        INTVAL result;

        result = DYNSELF.get_integer()
            & value;

        VTABLE_set_integer_native(INTERP, dest, result);
    }

/*

=item C<void bitwise_xor(PMC *value, PMC *dest)>

Returns in C<*dest> the bitwise C<XOR> of the scalar and C<*value>.

=cut

*/

    void bitwise_xor (PMC* value, PMC* dest) {
        INTVAL result;

        result = DYNSELF.get_integer()
            ^ VTABLE_get_integer(INTERP, value);

        VTABLE_set_integer_native(INTERP, dest, result);
    }

/*

=item C<void bitwise_xor_int(INTVAL value, PMC *dest)>

Returns in C<*dest> the bitwise C<XOR> of the scalar and C<value>.

=cut

*/

    void bitwise_xor_int (INTVAL value, PMC* dest) {
        INTVAL result;

        result = DYNSELF.get_integer()
            ^ value;

        VTABLE_set_integer_native(INTERP, dest, result);
    }

/*

=item C<void bitwise_not(PMC *dest)>

Returns in C<*dest> the bitwise negation of the scalar and C<value>.

=cut

*/

    void bitwise_not (PMC* dest) {
        VTABLE_set_integer_native(INTERP, dest, ~DYNSELF.get_integer());
    }


/*

=item C<void bitwise_shr(PMC *value, PMC *dest)>

Returns in C<*dest> the shift right of the scalar by C<*value>.

=cut

*/

    void bitwise_shr (PMC* value, PMC* dest) {
        INTVAL result;

        result = DYNSELF.get_integer()
            >> VTABLE_get_integer(INTERP, value);

        VTABLE_set_integer_native(INTERP, dest, result);
    }

/*

=item C<void bitwise_shr_int(INTVAL value, PMC *dest)>

Returns in C<*dest> the shift right of the scalar by C<value>.

=cut

*/

    void bitwise_shr_int (INTVAL value, PMC* dest) {
        INTVAL result;

        result = DYNSELF.get_integer()
            >> value;

        VTABLE_set_integer_native(INTERP, dest, result);
    }

/*

=item C<void bitwise_shl(PMC *value, PMC *dest)>

Returns in C<*dest> the shift left of the scalar by C<*value>.

=cut

*/

    void bitwise_shl (PMC* value, PMC* dest) {
        INTVAL result;

        result = DYNSELF.get_integer()
            << VTABLE_get_integer(INTERP, value);

        VTABLE_set_integer_native(INTERP, dest, result);
    }

/*

=item C<void bitwise_shl_int(INTVAL value, PMC *dest)>

Returns in C<*dest> the shift left of the scalar by C<value>.

=cut

*/

    void bitwise_shl_int (INTVAL value, PMC* dest) {
        INTVAL result;

        result = DYNSELF.get_integer()
            << value;

        VTABLE_set_integer_native(INTERP, dest, result);
    }

/*

=back

=head2 String Methods

=over 4

=item C<void concatenate(PMC *value, PMC *dest)>

Returns in C<*dest> the result of concatenating the scalar and C<*value>.

=cut

*/

    void concatenate (PMC* value,  PMC* dest) {
        STRING* s = string_concat(INTERP,
            DYNSELF.get_string(),
            VTABLE_get_string(INTERP, value), 0);

        VTABLE_set_string_native(INTERP, dest, s);
    }

/*

=item C<void concatenate_str(STRING *value, PMC *dest)>

Returns in C<*dest> the result of concatenating the scalar and C<*value>.

=cut

*/

    void concatenate_str (STRING* value,  PMC* dest) {
        /* dest = SELF (concat) value */
        STRING* s = string_concat(INTERP,
            DYNSELF.get_string(),
            value, 0);

        VTABLE_set_string_native(INTERP, dest, s);
    }

/*

=back

=head2 Comparison Methods

=over 4

=item C<INTVAL is_equal(PMC *value)>

Returns whether the scalar is equal to C<*value>.

=cut

*/

    INTVAL is_equal (PMC* value) {
        /* I think we need to check everything, do the easiest first... */
        if (DYNSELF.get_integer()
                == VTABLE_get_integer(INTERP, value)
            && DYNSELF.get_number()
                == VTABLE_get_number(INTERP, value)
            && 0 == string_compare(INTERP,
                DYNSELF.get_string(),
                VTABLE_get_string(INTERP, value))
            )
        {
            return 1;
        }
        return 0;
    }


/*

=item C<INTVAL cmp_num(PMC *value)>

Returns the result of comparing the floating-point values of the scalar
and C<*value>.

=cut

*/

    INTVAL cmp_num (PMC* value) {
        /* XXX - Floating-point precision errors possible? */
        FLOATVAL diff = VTABLE_get_number(INTERP, value) -
                        DYNSELF.get_number();

        return diff == 0.0 ? 0 : diff < 0.0 ? -1 : 1;
    }

/*

=item C<INTVAL cmp_string(PMC *value)>

Returns the result of comparing the string values of the scalar and
C<*value>.

=cut

*/

    INTVAL cmp_string (PMC* value) {
        return string_compare(INTERP, DYNSELF.get_string(),
            VTABLE_get_string(INTERP, value));
    }

/*

=back

=head2 Logical Methods

=over 4

=item C<void logical_or(PMC *value, PMC *dest)>

Returns in C<*dest> the result of the logical C<OR> of the scalar and
C<*value>.

=cut

*/

    void logical_or (PMC* value,  PMC* dest) {
        if (DYNSELF.get_bool()) {
            VTABLE_set_pmc(INTERP, dest, SELF);
        }
        else {
            VTABLE_set_pmc(INTERP, dest, value);
        }
    }

/*

=item C< void logical_and(PMC *value, PMC *dest)>

Returns in C<*dest> the result of the logical C<AND> of the scalar and
C<*value>.

=cut

*/

    void logical_and (PMC* value,  PMC* dest) {
        if (DYNSELF.get_bool()) {
            VTABLE_set_pmc(INTERP, dest, value);
        }
        else {
            VTABLE_set_pmc(INTERP, dest, SELF);
        }
    }

/*

=item C<void logical_xor(PMC *value, PMC *dest)>

Returns in C<*dest> the result of the logical C<XOR> of the scalar and
C<*value>.

=cut

*/

    void logical_xor (PMC* value,  PMC* dest) {

        INTVAL my_bool, value_bool;

        my_bool = DYNSELF.get_bool();
        value_bool = VTABLE_get_bool(INTERP, value);

        if (my_bool && ! value_bool) {
            VTABLE_set_pmc(INTERP, dest, SELF);
        }
        else if (value_bool && ! my_bool) {
            VTABLE_set_pmc(INTERP, dest, value);
        }
        else {
            /* XXX - Need a better way to set FALSE */
            VTABLE_set_integer_native(INTERP, dest, 0);
        }
    }

/*

=item C<void logical_not(PMC *dest)>

Returns in C<*dest> the result of the logical negation of the scalar and
C<*value>.

=cut

*/

    void logical_not (PMC* dest) {
        /* XXX - Need a better way to set boolean state */
        VTABLE_set_integer_native(INTERP, dest,
            ! DYNSELF.get_bool());
    }

/*

=item C<void repeat(PMC *value, PMC *dest)>

Returns in C<*dest> the result of repeating the scalar C<*value> times.


=cut

*/

    void repeat (PMC* value,  PMC* dest) {
        VTABLE_set_string_native(INTERP, dest,
            string_repeat(INTERP, VTABLE_get_string(INTERP,SELF),
                (UINTVAL)VTABLE_get_integer(INTERP, value), NULL) );
    }

/*

=item C<void repeat_int(INTVAL value, PMC *dest)>

Returns in C<*dest> the result of repeating the scalar C<value> times.

=cut

*/

    void repeat_int (INTVAL value, PMC* dest) {
        VTABLE_set_string_native(INTERP, dest,
            string_repeat(INTERP, VTABLE_get_string(INTERP,SELF),
                (UINTVAL)value, NULL) );
    }


/*

=item C<INTVAL defined()>

Always returns true.

=cut

*/

    INTVAL defined () {
        return 1;
    }


/*

=item C<STRING *substr_str(INTVAL offset, INTVAL length)>

Returns the substring of length C<length> of the scalar starting at
C<offset>.

=cut

*/

    STRING* substr_str(INTVAL offset, INTVAL length) {
        return string_substr(INTERP, VTABLE_get_string(INTERP,SELF),
            offset, length, NULL, 0);
    }

}

/*

=back

=cut

*/

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
 * vim: expandtab shiftwidth=4:
*/
