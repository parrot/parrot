/*
Copyright: 2001-2003 The Perl Foundation.  All Rights Reserved.
$Id$

=head1 NAME

classes/default.pmc - Abstract root class

head1 DESCRIPTION

These are the vtable functions for the default PMC class.

All methods which are not defined here get a default implementation
generated from F<vtable.tbl> by F<build_tools/pmc2c.pl>.

=head2 Functions

=over 4

=cut

*/

#include "parrot/parrot.h"

#define INT2KEY(i,k) key_new_integer((i), (k))

/*

=item C<static const char *caller(Interp* interpreter, PMC *pmc)>

Returns a C string for the name of C<*pmc>.

=cut

*/

static const char *
caller(Interp* interpreter, PMC * pmc)
{
    return pmc && pmc->vtable && pmc->vtable->whoami ?
    VTABLE_name(interpreter, pmc)->strstart : "(null)";
}

/*

=item C<static void cant_do_method(Interp* interpreter, PMC * pmc, const char *methname)>

Throws an exception "$methname() not implemented in class '$class'", used by
all unimplemented messages.

*/

static void
cant_do_method(Interp* interpreter, PMC * pmc, const char *methname)
{
    real_exception(interpreter, NULL, ILL_INHERIT,
                       "%s() not implemented in class '%s'", methname,
        	       caller(interpreter, pmc));
}

/*

=item C<static void
check_set_std_props(Interp* interpreter, PMC *pmc, STRING *key, PMC *value)>

Called from C<setprop()>.

=cut

*/

static void
check_set_std_props(Interp* interpreter, PMC *pmc, STRING *key, PMC *value)
{
#if  1
    /* XXX
     * a quick hack, to prevent freeing that string during DOD
     * triggered in t/pmc/pmc_62.t when configured with --gc=libc
     */
    static STRING *ro;
    if (!ro)
        ro = string_make(interpreter, "_ro", 3, "ascii",
            PObj_constant_FLAG|PObj_external_FLAG);
    if (!string_compare(interpreter, key, ro)) {
#else

    /*
     * s2 in string_compare is freed here
     */
    if (!string_compare(interpreter, key,
        string_from_cstring(interpreter, "_ro", 0))) {
#endif
        /* pmc should set/clear readonly */
        INTVAL on = VTABLE_get_bool(interpreter, value);
        /* morph to Const/normal class */
        if (on && (pmc->vtable->flags & VTABLE_HAS_CONST_TOO))
            pmc->vtable = Parrot_base_vtables[pmc->vtable->base_type + 1];
        else if (!on && (pmc->vtable->flags & VTABLE_IS_CONST_FLAG))
            VTABLE_morph(interpreter, pmc, pmc->vtable->base_type - 1);
    }
}

/*

=item C<static INTVAL
does_isa(Interp* interpreter, STRING *method, STRING *what)>

Compares C<*method> and C<*what>.

=cut

*/

static INTVAL
does_isa (Interp* interpreter, STRING *method, STRING *what)
{
    INTVAL len, pos = 0;

    do {
        pos = string_str_index(interpreter, what, method, pos);
        if (pos < 0)
            return 0;
        if (pos >= (INTVAL)string_length(interpreter, what))
            return 0;
        len = string_length(interpreter, method);
        if (pos && string_index(interpreter, what, pos - 1) != 32) {
            pos += len;
            continue;
        }

        if (pos+len < (INTVAL)string_length(interpreter, what) &&
            string_index(interpreter, what, pos + len) != 32) {
            pos += len;
            continue;
        }
        return 1;
    } while(1);
    return 0;
}

pmclass default abstract noinit {

/*

=back

=head2 Methods

=over 4

=item C<void init()>

Does nothing.

=cut

*/

    void init () {
    }

/*

=item C<void init_pmc(PMC *value)>

Calls C<init()>. C<*value> is ignored.

=cut

*/

    void init_pmc (PMC* value) {
        DYNSELF.init();
    }

/*

=item C<void init_pmc_props (PMC* initializer, PMC* properties)>

Sets C<properties> as the PMC's metadata, and calls C<init_pmc()> with
C<initializer> if it is supplied, otherwise C<init()> is called.

=cut

*/

    void init_pmc_props (PMC* initializer, PMC* properties) {
        if (!SELF->pmc_ext)
            add_pmc_ext(INTERP, SELF);
        DOD_WRITE_BARRIER(INTERP, SELF, NULL, properties);
        PMC_metadata(SELF) = properties;
        if (initializer)
            DYNSELF.init_pmc(initializer);
        else
            DYNSELF.init();
    }

/*

=item C<PMC* instantiate()>

Default fallback. Creates a new PMC of the type of the class SELF and
calls init().

=cut

*/

    PMC* instantiate() {
        INTVAL type = SELF->vtable->base_type;
        PMC* ret = pmc_new_noinit(INTERP, type);
        VTABLE_init(INTERP, ret);
        return ret;
    }

/*

=item C<void mark()>

Panics with a "no custom mark routine defined" error message.

=cut

*/

    void mark () {
        PANIC("custom_mark flag set but no custom mark routine defined");
    }

/*

=item C<PMC *getprop(STRING *key)>

Returns the property for C<*key>. If no property is defined then an
"undef" PMC is returned.

=cut

*/

    PMC* getprop(STRING* key) {
        if (SELF->pmc_ext && PMC_metadata(SELF)) {
          return VTABLE_get_pmc_keyed_str(INTERP, PMC_metadata(SELF), key);
        }
        else {
          PMC* undef = pmc_new(INTERP, enum_class_PerlUndef);
          return undef;
        }
    }

/*

=item C<void setprop(STRING *key, PMC *value)>

Sets the property for C<*key> to C<*value>.

=cut

*/

    void setprop(STRING* key, PMC* value) {
        check_set_std_props(INTERP, SELF, key, value);
        if (SELF->pmc_ext && PMC_metadata(SELF)) {
            VTABLE_set_pmc_keyed_str(INTERP,
                PMC_metadata(SELF), key, value);
        } else {
            PMC *prop;
            if (!SELF->pmc_ext)
                add_pmc_ext(INTERP, SELF);
            /* first make new hash */
            PMC_metadata(SELF) = prop =
                pmc_new_noinit(INTERP, enum_class_PerlHash);
            DOD_WRITE_BARRIER(INTERP, SELF, NULL, prop);
            VTABLE_init(INTERP, prop);
            /* then the key, else it vanishes with --gc-debug */
            VTABLE_set_pmc_keyed_str(INTERP, prop, key, value);
#if 0
    PObj_report_SET(PMC_metadata(SELF));
#endif
        }
        return;
    }

/*

=item C<void delprop(STRING *key)>

Deletes the property for C<*key>.

=cut

*/

    void delprop(STRING* key) {
        if (SELF->pmc_ext && PMC_metadata(SELF)) {
            VTABLE_delete_keyed_str(INTERP, PMC_metadata(SELF), key);
        }
        return;
    }

/*

=item C<PMC *getprops()>

Returns the PMC's properties.

=cut

*/

    PMC* getprops() {
        if (!SELF->pmc_ext)
            add_pmc_ext(INTERP, SELF);
        if (!PMC_metadata(SELF)) {
            PMC *prop;
            PMC_metadata(SELF) = prop =
                pmc_new_noinit(INTERP, enum_class_PerlHash);
            DOD_WRITE_BARRIER(INTERP, SELF, NULL, prop);
            VTABLE_init(INTERP, prop);
        }
        return PMC_metadata(SELF);
    }

/*

=item C<INTVAL type()>

Returns the PMC's type.

=cut

*/

    INTVAL type () {
        return SELF->vtable->base_type;
    }

/*

=item C<INTVAL type_keyed_int(INTVAL key)>

Converts C<key> to a PMC key and returns the result of calling
C<type_keyed()> with it.

=cut

*/

    INTVAL type_keyed_int (INTVAL key) {
        PMC* r_key = INT2KEY(INTERP, key);
        return DYNSELF.type_keyed(r_key);
    }

/*

=item C<STRING *name()>

Returns the name of the PMC.

=item C<STRING *namespace_name()>

Returns the namespace name of the PMC.

=cut

*/

    STRING* name () {
        return SELF->vtable->whoami;
    }

    STRING* namespace_name () {
        return SELF->vtable->whoami;
    }


/*

=item C<PMC *find_method(STRING *method_name)>

Looks up the method for C<*method_name> and returns it. If no method is
found then C<NULL> is returned.

=item C<void add_method(STRING *method_name, PMC *sub)>

Store the method as a global in the namespace of this class.

=cut

*/


    PMC* find_method(STRING* method_name) {
        PMC *method = Parrot_find_method_with_cache(INTERP, SELF, method_name);
        if (method && method->vtable->base_type == enum_class_MultiSub &&
                REG_STR(1)) {
            return Parrot_MMD_dispatch_func(interpreter,
                    method, method_name, REG_STR(1));
        }
        return method;
    }

    void add_method(STRING *method_name, PMC *sub_pmc) {
        STRING *names = DYNSELF.namespace_name();
        Parrot_store_global(INTERP, names, method_name, sub_pmc);
    }
/*

=item C<INTVAL get_integer_keyed_int(INTVAL key)>

Converts C<key> to a PMC key and returns the result of calling
C<get_integer_keyed()> with it.

=cut

*/

    INTVAL get_integer_keyed_int (INTVAL key) {
        PMC* r_key = INT2KEY(INTERP, key);
        return DYNSELF.get_integer_keyed(r_key);
    }

/*

=item C<FLOATVAL get_number_keyed_int(INTVAL key)>

Converts C<key> to a PMC key and returns the result of calling
C<get_number_keyed()> with it.

=cut

*/

    FLOATVAL get_number_keyed_int (INTVAL key) {
        PMC* r_key = INT2KEY(INTERP, key);
        return DYNSELF.get_number_keyed(r_key);
    }


/*

=item C<STRING *get_string_keyed_int(INTVAL key)>

Converts C<key> to a PMC key and returns the result of calling
C<get_string_keyed()> with it.

=cut

*/

    STRING* get_string_keyed_int (INTVAL key) {
        PMC* r_key = INT2KEY(INTERP, key);
        return DYNSELF.get_string_keyed(r_key);
    }

/*

=item C<INTVAL get_bool_keyed_int(INTVAL key)>

Converts C<key> to a PMC key and returns the result of calling
C<get_bool_keyed()> with it.

=cut

*/

    INTVAL get_bool_keyed_int (INTVAL key) {
        PMC* r_key = INT2KEY(INTERP, key);
        return DYNSELF.get_bool_keyed(r_key);
    }

/*

=item C<INTVAL elements_keyed_int(INTVAL key)>

Converts C<key> to a PMC key and returns the result of calling
C<elements_keyed()> with it.

=cut

*/

    INTVAL elements_keyed_int (INTVAL key) {
        PMC* r_key = INT2KEY(INTERP, key);
        return DYNSELF.elements_keyed(r_key);
    }


/*

=item C<PMC *get_pmc_keyed_int(INTVAL key)>

Converts C<key> to a PMC key and returns the result of calling
C<get_pmc_keyed()> with it.

=cut

*/

    PMC* get_pmc_keyed_int (INTVAL key) {
        PMC* r_key = INT2KEY(INTERP, key);
        return DYNSELF.get_pmc_keyed(r_key);
    }

/*

=item C<INTVAL is_same(PMC *value)>

Returns whether the PMC is numerically equal to C<value>.

=cut

*/

    INTVAL is_same (PMC* value) {
        return SELF == value;
    }

/*

=item C<void assign_pmc (PMC* value)>

=item C<void assign_string_native (PMC* value)>

Defaults fall back to C<set_pmc> and C<set_string_native>.

=cut

*/

    void assign_pmc (PMC* value) {
        DYNSELF.set_pmc(value);
    }

    void assign_string_native (STRING* value) {
        DYNSELF.set_string_native(value);
    }
/*

=item C<void set_integer_keyed_int (INTVAL key, INTVAL value)>

Converts C<key> to a PMC key and calls C<set_integer_keyed()> with it
and C<value>.

=cut

*/

    void set_integer_keyed_int (INTVAL key, INTVAL value) {
        PMC* r_key = INT2KEY(INTERP, key);
        DYNSELF.set_integer_keyed(r_key, value);
    }

/*

=item C<void set_number_keyed_int (INTVAL key, FLOATVAL value)>

Converts C<key> to a PMC key and calls C<set_number_keyed()> with it
and C<value>.

=cut

*/

    void set_number_keyed_int (INTVAL key, FLOATVAL value) {
        PMC* r_key = INT2KEY(INTERP, key);
        DYNSELF.set_number_keyed(r_key, value);
    }


/*

=item C<void set_string_keyed_int(INTVAL key, STRING *string)>

Converts C<key> to a PMC key and calls C<set_string_keyed()> with it
and C<value>.

=cut

*/

    void set_string_keyed_int (INTVAL key, STRING* string) {
        PMC* r_key = INT2KEY(INTERP, key);
        DYNSELF.set_string_keyed(r_key, string);
    }

/*

=item C<void set_bool_keyed_int(INTVAL key, INTVAL value)>

Converts C<key> to a PMC key and calls C<set_bool_keyed()> with it
and C<value>.

=cut

*/

    void set_bool_keyed_int (INTVAL key, INTVAL value) {
        PMC* r_key = INT2KEY(INTERP, key);
        DYNSELF.set_bool_keyed(r_key, value);
    }

/*

=item C<void set_pmc_keyed_int(INTVAL key, PMC *value)>

Converts C<key> to a PMC key and calls C<set_pmc_keyed()> with it
and C<value>.

=cut

*/

    void set_pmc_keyed_int (INTVAL key, PMC* value) {
        PMC* r_key = INT2KEY(INTERP, key);
        DYNSELF.set_pmc_keyed(r_key, value);
    }

/*

=item C<INTVAL is_equal(PMC *value)>

Returns whether the PMC is equal to C<*value>.

=cut

*/

    INTVAL is_equal (PMC* value) {
        return (SELF->vtable == value->vtable
            && PMC_struct_val(SELF) == PMC_struct_val(value)
            && PMC_data(SELF) == PMC_data(value));
    }

/*

=item C<INTVAL is_equal_num(PMC *value)>

Returns whether the PMC is numerically equal to C<*value>.

=cut

*/

    INTVAL is_equal_num (PMC* value) {
        return (VTABLE_get_number(INTERP, SELF) == VTABLE_get_number(INTERP, value));
    }

/*

=item C<INTVAL is_equal_str(PMC *value)>

Returns whether the PMC is numerically equal to C<*value>.

=cut

*/

    INTVAL is_equal_str (PMC* value) {
        return (0 == string_equal(INTERP, VTABLE_get_string(INTERP, SELF),
                                       VTABLE_get_string(INTERP, value)));
    }

/*



=item C<INTVAL exists_keyed_int(INTVAL key)>

Converts C<key> to a PMC key and returns the result of calling
C<exists_keyed()> with it.

=cut

*/

    INTVAL exists_keyed_int (INTVAL key) {
        PMC* r_key = INT2KEY(INTERP, key);
        return DYNSELF.exists_keyed(r_key);
    }

/*

=item C<INTVAL defined()>

Returns true.

=cut

*/

    INTVAL defined () {
        return 1;
    }


/*

=item C<INTVAL defined_keyed_int(INTVAL key)>

Converts C<key> to a PMC key and returns the result of calling
C<defined_keyed()> with it.

=cut

*/

    INTVAL defined_keyed_int (INTVAL key) {
        PMC* r_key = INT2KEY(INTERP, key);
        return DYNSELF.defined_keyed(r_key);
    }

/*

=item C<void delete_keyed_int(INTVAL key)>

Converts C<key> to a PMC key and calls C<delete_keyed()> with it.

=cut

*/

    void delete_keyed_int(INTVAL key) {
        PMC* r_key = INT2KEY(INTERP, key);
        DYNSELF.delete_keyed(r_key);
    }

/*

=item C<PMC *nextkey_keyed_int(INTVAL key, INTVAL w)>

Converts C<key> to a PMC key and returns the result of calling
C<nextkey_keyed()> with it.

=cut

*/

    PMC* nextkey_keyed_int (INTVAL key, INTVAL w) {
        PMC* r_key = INT2KEY(INTERP, key);
        return DYNSELF.nextkey_keyed(r_key, w);
    }

/*

=item C<INTVAL can(STRING *method)>

Returns whether the PMC "can" perform C<*method>.

=cut

*/

    INTVAL can (STRING* method) {
        return VTABLE_find_method(INTERP, SELF, method) != NULL;
    }

/*

=item C<INTVAL does(STRING *method)>

Returns whether the PMC "does" perform C<*method>.

=cut

*/

    INTVAL does(STRING* method) {
        return does_isa(INTERP, method, SELF->vtable->does_str);
    }

/*

=item C<INTVAL isa(STRING *method)>

Returns whether the PMC "isa" C<*method>.

=cut

*/

    INTVAL isa (STRING* method) {
        return does_isa(INTERP, method, SELF->vtable->isa_str);
    }

/*

=item C<PMC* subclass(STRING* name)>

Creates a subclass, optionally with a given C<name>.

=cut

*/

    PMC* subclass(STRING *name) {
        return Parrot_single_subclass(INTERP, SELF, name);
    }

/*

=item C<PMC* get_class()>

Returns SELF. A PMC is it's own class.

=item C<PMC* get_attr_str(STRING* attr)>

Look for NCI methods and properties.

=cut

*/
    PMC* get_class() {
        return SELF;
    }

    PMC* get_attr_str(STRING* name) {
        PMC *p = NULL;
        HashBucket* b;
        /* lets look for props first
         * XXX do we need that in the default object system?
         */
        if (SELF->pmc_ext && PMC_metadata(SELF)) {
             b = hash_get_bucket(INTERP, (Hash*) PMC_metadata(SELF), name);
             if (b)
                 p = b->value;
        }
        if (PMC_IS_NULL(p)) {
            /* may be NCI? */
            p = VTABLE_find_method(INTERP, SELF, name);
        }
        if (PMC_IS_NULL(p)) {
            /* TODO AttributeError */
        }
        else if (VTABLE_isa(INTERP, p, CONST_STRING(INTERP, "NCI"))) {
            PMC *bound_meth = VTABLE_clone(INTERP, p);
            bound_meth->vtable = Parrot_base_vtables[enum_class_Bound_NCI];
            VTABLE_set_pmc(INTERP, bound_meth, SELF);
            return bound_meth;
        }
        else if (p->vtable->base_type == enum_class_MultiSub) {
            PMC *bound_meth = pmc_new(INTERP, enum_class_Bound_NCI);
            VTABLE_set_pmc(INTERP, bound_meth, SELF);
            PMC_struct_val(bound_meth) = p;
            PObj_get_FLAGS(bound_meth) |= PObj_private0_FLAG;
            return bound_meth;
        }
        /* TODO bound user functions */
        return p;
    }

/*

=item C<void add_parent(PMC *parent)>

Add class C<parent> to the list of our parents.

=cut

*/

    void add_parent(PMC *parent) {
        Parrot_add_parent(INTERP, SELF, parent);
    }

/*

=item C<void visit(visit_info *info)>

Used by DOD to mark the PMC.

=cut

*/

    void visit(visit_info *info) {
        /* default - mark prop hash */
        if (SELF->pmc_ext && PMC_metadata(SELF) &&
            info->extra_flags != EXTRA_IS_PROP_HASH) {
            info->extra_flags = EXTRA_IS_PROP_HASH;
            info->extra = PMC_metadata(SELF);
            /* place escape mark */
            (info->visit_pmc_now)(INTERP, SELF, info);
            /* place and the prop hash */
            (info->visit_pmc_now)(INTERP, PMC_metadata(SELF), info);
        }
    }

/*

=item C<void freeze(visit_info *info)>

Does nothing.

=cut

*/

    void freeze(visit_info *info) {
        /* default - no action */
    }

/*

=item C<void thaw(visit_info *info)>

Initializes the PMC during unarchiving.

=cut

*/

    void thaw(visit_info *info) {
        /* default - initialize the PMC */
        if (info->extra_flags == EXTRA_IS_PROP_HASH) {
            if (!SELF->pmc_ext)
                add_pmc_ext(INTERP, SELF);
            info->thaw_ptr = &PMC_metadata(SELF);
            info->container = SELF;
            (info->visit_pmc_now)(INTERP, PMC_metadata(SELF), info);
        }
        else
            DYNSELF.init();
    }

/*

=item C<void thawfinish(visit_info *info)>

Does nothing.

=cut

*/

    void thawfinish(visit_info *info) {
        /* default - no action */
    }
}

/*

=back

=cut

*/

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
 * vim: expandtab shiftwidth=4:
*/
