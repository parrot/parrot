/*
Copyright: 2001-2003 The Perl Foundation.  All Rights Reserved.
$Id$

=head1 NAME

classes/resizablepmcarray.pmc - resizable array for PMCs only

=head1 DESCRIPTION

This class, ResizablePMCArray, implements an resizable array,
which stores PMCs. It puts things into Integer, Float, or String PMCs
as appropriate.

=head2 Functions

=over 4

=cut

*/

#include "parrot/parrot.h"


pmclass ResizablePMCArray extends FixedPMCArray need_ext does array {

/*

=item C<void* invoke(void* next)>

Pythonic object constructor. SELF is a ResizeablePMCArray Class object.
Return a new C<list> object according to 2.1. Built-in Functions.

=cut

*/
    void* invoke(void* next) {
        int argcP = REG_INT(3);
        PMC *res = pmc_new(INTERP, enum_class_ResizablePMCArray);
        PMC *arg;

        if (argcP) {
            if (argcP > 1) {
                real_exception(INTERP, NULL, E_TypeError,
                        "TypeError: list expected at most 1 arguments, got %d",
                        (int)argcP);
            }
            arg = REG_PMC(5);
            Parrot_py_fill(INTERP, res, arg);
        }
        REG_PMC(5) = res;
        return next;
    }

/*

=item C<void set_integer_native(INTVAL size)>

Resizes the array to C<size> elements.

=cut

*/

    void set_integer_native (INTVAL size) {

        if (size < 0)
            internal_exception(OUT_OF_BOUNDS,
                    "ResizablePMCArray: Can't resize!");

        if (!PMC_data(SELF)) {
            /* empty - used fixed routine */
            if (size < 8) {
                SUPER(8);
                PMC_int_val(SELF) = size;
                PMC_int_val2(SELF) = 8;
            }
            else {
                SUPER(size);
                PMC_int_val2(SELF) = size;
            }
        }
        else if (size <= PMC_int_val2(SELF)) {
            PMC_int_val(SELF) = size;
            /* we could shrink here if necessary */
            return;
        }
        else {
            INTVAL i, cur, needed;
            i = cur = PMC_int_val2(SELF);
            if (cur < 8192)
                cur = size < 2 * cur ? 2 * cur : size;
            else {
                needed = size - cur;
                cur += needed + 4096;
                cur &= ~0xfff;
            }
            PMC_data(SELF) = mem_sys_realloc(PMC_data(SELF),
                    cur * sizeof(PMC*));
            for (; i < cur; i++)
                ((PMC**)PMC_data(SELF))[i] = PMCNULL;
            PMC_int_val2(SELF) = cur;
            PMC_int_val(SELF) = size;
        }
    }
/*

=item C<PMC *get_pmc_keyed_int(INTVAL key)>

Returns the PMC value of the element at index C<key>.

=cut

*/

    PMC* get_pmc_keyed_int (INTVAL key) {
        PMC **data;

        if (key < 0)
            key += PMC_int_val(SELF);
        if (key < 0)
            internal_exception(OUT_OF_BOUNDS,
                "ResizablePMCArray: index out of bounds!");
        if (key >= PMC_int_val(SELF))
            DYNSELF.set_integer_native(key+1);
        data = PMC_data(SELF);
        if (data[key] == PMCNULL)
            data[key] = pmc_new(INTERP, enum_class_Undef);
        return data[key];
    }

/*

=item C<void set_pmc_keyed_int(INTVAL key, PMC *src)>

Sets the PMC value of the element at index C<key> to C<*src>.

=item C<void set_pmc_keyed(PMC *key, PMC *src)>

If key is a slice, do a splice as set that item.

=cut

*/

    void set_pmc_keyed_int (INTVAL key, PMC* src) {
        PMC **data;

        /*
         * TODO in python mode, only .append is allowed
         */
        if (key < 0)
            key += PMC_int_val(SELF);
        if (key < 0)
            internal_exception(OUT_OF_BOUNDS,
                "ResizablePMCArray: index out of bounds!");
        if (key >= PMC_int_val(SELF))
            DYNSELF.set_integer_native(key+1);
        data = (PMC**)PMC_data(SELF);
        DOD_WRITE_BARRIER(INTERP, SELF, data[key], src);
        data[key] = src;
    }

    void set_pmc_keyed (PMC* key, PMC* src) {
        if (key->vtable->base_type == enum_class_Slice)
            Parrot_py_set_slice(INTERP, SELF, key, src);
        else
            SUPER(key, src);
    }

    void delete_keyed (PMC* key) {
        if (key->vtable->base_type == enum_class_Slice)
            Parrot_py_set_slice(INTERP, SELF, key, NULL);
        else
            internal_exception(OUT_OF_BOUNDS,
                "ResizablePMCArray: unimplemented delete!");
    }

/*

=item C<void push_pmc (PMC* value)>

Extends the array by adding an element of value C<*value> to the end of
the array.

=cut

*/

    void push_pmc(PMC* value) {
        INTVAL size = PMC_int_val(SELF);

        /* let set_integer_native() worry about memory allocation */
        DYNSELF.set_integer_native(size + 1);
        ((PMC**)PMC_data(SELF))[size] = value;

        return;
    }

    METHOD void append(PMC* value) {
        Parrot_ResizablePMCArray_push_pmc(INTERP, SELF, value);
    }

/*

=item C<void push_integer(INTVAL value)>

=item C<void push_string(INTVAL value)>

Extends the array by adding an element of value C<*value> to the end of
the array.

=cut

*/

    void push_integer(INTVAL value) {
        PMC *val;
        INTVAL size;

        size = PMC_int_val(SELF);
        val = pmc_new(INTERP, enum_class_Integer);
        VTABLE_set_integer_native(INTERP, val, value);
        /* let set_pmc_keyed_int() worry about memory allocation */
        DYNSELF.set_pmc_keyed_int(size, val);

        return;
    }

    void push_string(STRING* value) {
        PMC *val;
        INTVAL size;

        size = PMC_int_val(SELF);
        val = pmc_new(INTERP, enum_class_String);
        VTABLE_assign_string_native(INTERP, val, value);
        /* let set_pmc_keyed_int() worry about memory allocation */
        DYNSELF.set_pmc_keyed_int(size, val);

        return;
    }
/*

=item C<PMC *clone()>

Creates and returns a copy of the array.

=cut

*/

    PMC* clone () {
        PMC *copy = SUPER();

        PMC_int_val2(copy) = PMC_int_val(SELF);
        return copy;
    }

    STRING* get_repr () {
        return SELF.get_string();
    }

    STRING* get_string () {
        if (Interp_flags_TEST(INTERP, PARROT_PYTHON_MODE)) {
            STRING *res, *s;
            INTVAL j, n;
            PMC *val;

            res = string_from_cstring(INTERP, "[", 0);
            n = VTABLE_elements(INTERP, SELF);
            for (j = 0; j < n; ++j) {
                STRING *vals;
                val = SELF.get_pmc_keyed_int(j);
                REG_INT(3) = 0;
                vals = VTABLE_get_repr(INTERP, val);
                res = string_append(INTERP, res, vals, 0);
                if (j < n - 1)
                    res = string_append(INTERP, res,
                            const_string(INTERP, ", "), 0);
            }
            res = string_append(INTERP, res,
                        const_string(INTERP, "]"), 0);
            return res;
        }

        return string_from_int(INTERP, DYNSELF.elements());
    }
/*

=item C<INTVAL is_equal (PMC* value)>

The C<==> operation. Compares two array to hold equal elements.

=cut

*/

    INTVAL is_equal (PMC* value) {
        INTVAL j, n;

        if (value->vtable->base_type != enum_class_ResizablePMCArray)
            return 0;
        n = DYNSELF.elements();
        if (VTABLE_elements(INTERP, value) != n)
            return 0;
        for (j = 0; j < n; ++j) {
            PMC *item1, *item2;
            item1 = DYNSELF.get_pmc_keyed_int(j);
            item2 = VTABLE_get_pmc_keyed_int(INTERP, value, j);
            if (item1 == item2)
                continue;
            if (!mmd_dispatch_i_pp(INTERP, item1, item2, MMD_EQ))
                return 0;
        }
        return 1;
    }
/*

=item C<void multiply_int(INTVAL value,  PMC *dest)>

Python (b6.main):

 # L = [1] * 1000000

  4           0 LOAD_CONST               1 (1)
              3 BUILD_LIST               1
              6 LOAD_CONST               2 (1000000)
              9 BINARY_MULTIPLY
             10 STORE_FAST               2 (L)

Build a list by duplicating the passed list N times. Only implemented for
list.elements == 1.

=cut

*/

    void multiply_int (INTVAL value,  PMC* dest) {
        INTVAL k = DYNSELF.elements();
        INTVAL i;
        PMC *elem;
        PMC **data;

        if (k != 1)
            internal_exception(1, "multiply_int: unimplemented list size");
        elem = VTABLE_get_pmc_keyed_int(INTERP, SELF, 0);
        pmc_reuse(INTERP, dest, enum_class_ResizablePMCArray, 0);
        VTABLE_set_integer_native(INTERP, dest, value);
        data = PMC_data(dest);
        for (i = 0; i < value; ++i)
            data[i] = elem;
    }


}

/*

=back

=head1 SEE ALSO

F<docs/pdds/pdd17_basic_types.pod>.

=head1 HISTORY

Initial version                  - Matt Fowles 2004-06-11
Changed allocator to double size - Matt Fowles 2004-06-15

=cut

*/

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
 * vim: expandtab shiftwidth=4:
*/
