/*
Copyright: 2001-2003 The Perl Foundation.  All Rights Reserved.
$Id$

=head1 NAME

classes/resizablepmcarray.pmc - resizable size array for PMCs only

=head1 DESCRIPTION

This class, ResizablePMCArray, implements an array of resizable size, which stores PMCs,
it puts things into Integer, Float, or String PMCs as appropriate
TODO currently this uses PerlString instead of String PMCs.

=head2 Functions

=over 4

=cut

*/

#include "parrot/parrot.h"

typedef struct _SizePMCData {
    INTVAL size;
    PMC* data[1];
} SizePMCData;
#define NEEDED_SIZE(n) ((n-1)*sizeof(PMC*) + sizeof(SizePMCData))

pmclass ResizablePMCArray extends FixedPMCArray need_ext does array {

/*

=item C<PMC *get_pmc_keyed_int(INTVAL key)>

Returns the PMC value of the element at index C<key>.

=cut

*/

    PMC* get_pmc_keyed_int (INTVAL key) {
        SizePMCData *sd;
        if (key < 0)
            internal_exception(OUT_OF_BOUNDS,
                "ResizablePMCArray: index out of bounds!\n");
        if(key >= PMC_int_val(SELF))
            DYNSELF.set_integer_native(key+1);

        sd = (SizePMCData *)PMC_data(SELF);
        if(sd->data[key] == PMCNULL)
            sd->data[key] = pmc_new(INTERP, enum_class_Undef);
        return sd->data[key];
    }

/*

=item C<void set_pmc_keyed_int(INTVAL key, PMC *src)>

Sets the PMC value of the element at index C<key> to C<*src>.

=cut

*/

    void set_pmc_keyed_int (INTVAL key, PMC* src) {
        SizePMCData *sd;
        if (key < 0)
            internal_exception(OUT_OF_BOUNDS,
                "ResizablePMCArray: index out of bounds!\n");
        if(key >= PMC_int_val(SELF))
            DYNSELF.set_integer_native(key+1);

        sd = (SizePMCData *)PMC_data(SELF);
        sd->data[key] = src;
    }


/*

=item C<void set_integer_native(INTVAL size)>

Resizes the array to C<size> elements.

=cut

*/

    void set_integer_native (INTVAL size) {
        int i;
        SizePMCData *sd;

        if (size < 0)
            internal_exception(OUT_OF_BOUNDS,
                    "ResizablePMCArray: Can't resize!\n");

        sd = (SizePMCData *)PMC_data(SELF);
        PMC_int_val(SELF) = size;
        if(sd == NULL) {
            i = 0;
            sd = mem_sys_allocate(NEEDED_SIZE(size));
            sd->size = size;
        } else if(size >= sd->size) {
            i = sd->size;
            sd->size =  size < 2*sd->size ? sd->size*2 : size;
            sd = mem_sys_realloc(sd, NEEDED_SIZE(sd->size));
        } else {
            return;
        }
        for(; i < sd->size; i++)
            sd->data[i] = PMCNULL;

        PMC_data(SELF) = sd;
        PObj_custom_mark_destroy_SETALL(SELF);
    }

/*

=item C<PMC *clone()>

Creates and returns a copy of the array.

=cut

*/

    PMC* clone () {
        SizePMCData *sd;
        PMC * dest = pmc_new(INTERP, SELF->vtable->base_type);

        if (!PMC_data(SELF))
            return dest;
        PMC_int_val(dest) = PMC_int_val(SELF);
        sd = (SizePMCData *)PMC_data(SELF);

        PMC_data(dest) = mem_sys_allocate(NEEDED_SIZE(sd->size));
        mem_sys_memcopy(PMC_data(dest), PMC_data(SELF), NEEDED_SIZE(sd->size));
        PObj_custom_mark_destroy_SETALL(SELF);
        return dest;
    }

/*

=item C<void mark()>

Marks the array as live.

=cut

*/

    void mark () {
        SizePMCData *sd;
        int i, end;
        PMC **data;
        if (!PMC_data(SELF))
            return;
        sd = (SizePMCData *)PMC_data(SELF);
        data = sd->data;
        end = PMC_int_val(SELF);
        for(i = 0; i < end; i++) {
            if(data[i]) {
                pobject_lives(INTERP, (PObj *) data[i]);
            }
        }
    }

}

/*

=back

=head1 SEE ALSO

F<docs/pdds/pdd03_calling_conventions.pod>.

=head1 HISTORY

Initial version 2004.06.11 by Matt Fowles
Changed allocator to double size - MF 2004.06.15

=cut

*/

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
 * vim: expandtab shiftwidth=4:
*/
