/*
 *  Copyright: 2001-2003 The Perl Foundation.  All Rights Reserved.
 *  CVS Info
 *     $Id$
 *  Overview:
 *     PMC class to hold structs that parrot's not responsible for
 *     disposing of.
 *
 *     Buffer can be accessed using keyed assignments to PMC.  Out of
 *     bounds access will very likely segfault.
 *
 *  Data Structure and Algorithms:
 *  History:
 *     Initial revision by sean 2002/08/04
 *  Notes:
 *  References:
 *     F<docs/pmc/struct.pod>
 */

#include "parrot/parrot.h"
#include <assert.h>


INTVAL key_2_idx(Parrot_Interp interpreter, PMC *pmc, PMC *key);

static char *
char_offset_int(Parrot_Interp interpreter, PMC *pmc, INTVAL ix, int *type)
{
    size_t offs, n;

    ix *= 3;
    if (!PMC_pmc_val(pmc))
	internal_exception(1, "Missing struct initializer");
    n = (size_t)VTABLE_elements(interpreter, PMC_pmc_val(pmc));
    if ((size_t)ix >= n)
	internal_exception(1, "Non existent elements in struct");
    /* use structure init */
    *type = (int) VTABLE_get_integer_keyed_int(interpreter,
	    PMC_pmc_val(pmc), ix);
    offs = (size_t) VTABLE_get_integer_keyed_int(interpreter,
	    PMC_pmc_val(pmc), ix + 2);
    return ((char *)PMC_data(pmc)) + offs;
}

INTVAL
key_2_idx(Parrot_Interp interpreter, PMC *pmc, PMC *key)
{
    int ix;

    if (!PMC_pmc_val(pmc))
	internal_exception(1, "Missing struct initializer");
    if (PObj_get_FLAGS(key) & KEY_string_FLAG) {
	PMC *types = PMC_pmc_val(pmc);
	if (types->vtable->base_type == enum_class_OrderedHash) {
	    Hash *hash = (Hash*)PMC_struct_val(types);
	    HashBucket *b = hash_get_bucket(interpreter, hash,
		    key_string(interpreter, key));
	    if (!b)
		internal_exception(1, "key doesn't exist");
	    ix = VTABLE_get_integer(interpreter, (PMC*) b->value);
	}
	else
	    internal_exception(1, "unhandled type aggregate");
	ix /= 3;
    }
    else
	ix = key_integer(interpreter, key);
    return ix;
}

static char *
char_offset_key(Parrot_Interp interpreter, PMC *pmc, PMC *key, int *type)
{
    size_t offs, n, count, size, max;
    PMC *next, *init;
    int ix;
    char *p;

    ix = key_2_idx(interpreter, pmc, key);
    next = key_next(interpreter, key);
    p = char_offset_int(interpreter, pmc, ix, type);
    ix *= 3;
    if (!next)
	return p;
    count = (size_t) key_integer(interpreter, next);
    init = PMC_pmc_val(pmc);
    max = (size_t) VTABLE_get_integer_keyed_int(interpreter, init, ix + 1);
    /* TODO make that _struct_ptr */
    if (*type == enum_type_ptr) {
	PMC *ptr;
	/* for now ignore count */
	assert((int)max <= 1);
	/* the struct PMC is hanging off the initializer element
	 * as property "_struct"
	 */
	ptr = VTABLE_get_pmc_keyed_int(interpreter, init, ix);
	init = VTABLE_getprop(interpreter, ptr,
		string_from_cstring(interpreter, "_struct", 0));
	assert(init && init->vtable->base_type == enum_class_UnManagedStruct);
	/*
	 * now point PMC_data of this struct to the real data
	 */
	PMC_data(init) = *(void**)p;
	return char_offset_key(interpreter, init, next, type);
    }
    if (count >= max)
	internal_exception(1, "Non existent array element in struct");
    size = data_types[*type - enum_first_type].size;
    return p + count * size;
}

/*
 * if e.g. char or short type size doesn't match, this will fail
 * we need some more configure support for type sizes
 */
static INTVAL
ret_int(char *p, int type)
{
    switch (type) {
	case enum_type_INTVAL:
	case enum_type_int:
	    return *(INTVAL*) p;
	case enum_type_int16:
	case enum_type_uint16:
	case enum_type_short:
	    return *(short*) p;
	case enum_type_uint8:
	case enum_type_int8:
	case enum_type_char:
	case enum_type_uchar:
	    return *p;
	default:
	    internal_exception(1, "returning unhandled int type in struct");
    }
    return -1;
}

static FLOATVAL
ret_float(char *p, int type)
{
    switch (type) {
	case enum_type_FLOATVAL:
	    return (FLOATVAL) *(FLOATVAL*) p;
	case enum_type_float:
	    return (FLOATVAL) *(float*) p;
	case enum_type_double:
	    return (FLOATVAL) *(double*) p;
	default:
	    internal_exception(1, "returning unhandled float type in struct");
    }
    return -1.0;
}

static STRING*
ret_string(Parrot_Interp interpreter, char *p, int type)
{
    char *cstr;
    size_t len;

    switch (type) {
	case enum_type_cstr:
	    cstr = *(char **) p;
	    len = strlen(cstr);
	    return string_make(interpreter, cstr, len, NULL,
		    PObj_external_FLAG, NULL);
	default:
	    internal_exception(1, "returning unhandled string type in struct");
    }
    return NULL;
}

static void
set_int(char *p, int type, INTVAL value)
{
    switch (type) {
	case enum_type_uint8:
	case enum_type_int8:
	case enum_type_char:
	case enum_type_uchar:
	    *(char*) p = value & 0xff;
	    break;
	case enum_type_INTVAL:
	    *(INTVAL*) p = value;
	    break;
	case enum_type_int:
	    *(int*) p = value;
	    break;
	case enum_type_int16:
	case enum_type_uint16:
	case enum_type_short:
	    *(short*)p = (short)value;
	    break;
	default:
	    internal_exception(1, "setting unhandled int type in struct");
	    break;
    }
}

static void
set_float(char *p, int type, FLOATVAL value)
{
    switch (type) {
	case enum_type_FLOATVAL:
	    *(FLOATVAL*) p = (FLOATVAL) value;
	    break;
	case enum_type_float:
	    *(float*) p = (float) value;
	    break;
	case enum_type_double:
	    *(double*) p = (double) value;
	    break;
	default:
	    internal_exception(1, "setting unhandled float type in struct");
	    break;
    }
}

static void
set_string(char *p, int type, STRING* value)
{
    char *cstr;
    switch (type) {
	case enum_type_cstr:
	    /* XXX assumes 0-terminate C-string here
	     *     we can't use string_to_cstring easily
	     */
	    cstr = value->strstart;
	    *(char **) p = cstr;
	    break;
	default:
	    internal_exception(1, "setting unhandled string type in struct");
	    break;
    }
}

/*
 * XXX
 * this does only minimal alignment
 * gcc-2.95, -3.3 /i386
 *
  #include <stddef.h>
  struct xt {
	char x;                     // 0
	struct yt {
		char y;             // 4
		char i;             // 5
		int  j;             // 8
	} _y;
	char z;                     // 12
  } _x;

  ...
	printf("i : %d\n", offsetof(struct xt, _y.i));

 *
 * *BUT* if the nested structure contains only char - then
 *       all is char aligned
 *       if the nested structure contains a short then align is 2
 *
 *       long long is aligned on 4
 */

static int
calc_align(int type, int offs)
{
    int align = data_types[type - enum_first_type].size;

    if (offs % align) {
	int diff;
	if ((type == enum_type_ulonglong ||
		    type == enum_type_longlong 	||
		    type == enum_type_int64     ||
		    type == enum_type_uint64) &&
		!strcmp(PARROT_CPU_ARCH, "i386"))
	    align = 4;
	diff = align - (offs % align);
	offs += diff;
    }
    return offs;
}

pmclass UnManagedStruct extends default need_ext {

    void init() {
	PMC_pmc_val(SELF) = NULL;
    }

    /* Initialize the struct with some data. This should be an array
     * of triples of
     *   - datatype (enum from datatypes.h)
     *   - count
     *   - offset
     */

    void init_pmc (PMC* value) {
	SELF.set_pmc(value);
    }

    void set_pmc (PMC* value) {
	size_t i, n = (size_t)VTABLE_elements(interpreter, value);
	size_t toff = 0;

	if (n % 3)
	    internal_exception(1, "Illegal initializer for struct");
	PMC_pmc_val(SELF) = value;

	for (i = 0; i < n; i += 3) {
	    int type = (int) VTABLE_get_integer_keyed_int(interpreter,
		    value, i);
	    int count= (int) VTABLE_get_integer_keyed_int(interpreter,
		    value, i+1);
	    int offs = (int) VTABLE_get_integer_keyed_int(interpreter,
		    value, i+2);

	    if (type < enum_first_type || type >= enum_last_type)
		internal_exception(1, "Illegal type in initializer for struct");
	    if (count <= 0) {
		count = 1;
		VTABLE_set_integer_keyed_int(interpreter, value, i+1, count);
	    }
	    if (offs <= 0) {
		offs = toff = calc_align(type, toff);
		VTABLE_set_integer_keyed_int(interpreter, value, i+2, offs);
	    }
	    else
		toff = offs;
	    toff += count * (data_types[type - enum_first_type].size);
	    if (i == n - 3 &&
		    pmc->vtable->base_type == enum_class_ManagedStruct)
		DYNSELF.set_integer_native(toff);
	}
	PObj_custom_mark_SET(SELF);
    }

    void mark() {
	if (PMC_pmc_val(SELF))
	    pobject_lives(interpreter, (PObj *) PMC_pmc_val(SELF));
    }

    INTVAL is_equal (PMC* value) {
	return (SELF->vtable == value->vtable &&
		PMC_data(SELF) == PMC_data(value));
    }

    INTVAL defined () {
	return PMC_data(SELF) != NULL;
    }

    INTVAL get_integer_keyed_int(INTVAL ix) {
	int type;
	char *p;

	if (ix < 0)
            return -1;
	/* assume char array */
	if (!PMC_pmc_val(SELF)) {
	    type = enum_type_char;
	    p = ((char *)PMC_data(SELF)) + ix;
	}
	else
	    p = char_offset_int(interpreter, pmc, ix, &type);
	return ret_int(p, type);
    }



    /* May cause segfaults if value is out of bounds */
    INTVAL get_integer_keyed(PMC* key) {
	INTVAL ix;
	int type;
	char *p;

	/* assume char array */
	if (!PMC_pmc_val(SELF)) {
	    ix = key_integer(INTERP, key);
	    if (ix < 0)
		return -1;
	    type = enum_type_char;
	    p = ((char *)PMC_data(SELF)) + ix;
	}
	else
	    p = char_offset_key(interpreter, pmc, key, &type);
	return ret_int(p, type);
    }

    FLOATVAL get_number_keyed_int (INTVAL key) {
	int type;
	char *p = char_offset_int(interpreter, pmc, key, &type);
	return ret_float(p, type);
    }

    FLOATVAL get_number_keyed (PMC* key) {
	int type;
	char *p = char_offset_key(interpreter, pmc, key, &type);
	return ret_float(p, type);
    }

    STRING* get_string_keyed_int (INTVAL key) {
	int type;
	char *p = char_offset_int(interpreter, pmc, key, &type);
	return ret_string(interpreter, p, type);
    }

    STRING* get_string_keyed (PMC* key) {
	int type;
	char *p = char_offset_key(interpreter, pmc, key, &type);
	return ret_string(interpreter, p, type);
    }

    INTVAL get_integer() {
       return (INTVAL)*(INTVAL *)PMC_data(SELF);
    }

    void* get_pointer() {
	return PMC_data(SELF);
    }

    void set_integer_native(INTVAL value) {
       *(INTVAL *)PMC_data(SELF) = value;
    }

    void set_integer_keyed_int (INTVAL ix, INTVAL value) {
	int type;
	char *p;
	if (!PMC_pmc_val(SELF)) {
	    if (ix < 0)
		return;
	    type = enum_type_char;
	    p = ((char *)PMC_data(SELF)) + ix;
	}
	else
	    p = char_offset_int(interpreter, pmc, ix, &type);
	set_int(p, type, value);
    }

    /* May cause segfaults if value is out of bounds */
    void set_integer_keyed (PMC* key, INTVAL value) {
	INTVAL ix;
	int type;
	char *p;

	if (!PMC_pmc_val(SELF)) {
	    ix = key_integer(INTERP, key);
	    if (ix < 0)
		return;
	    type = enum_type_char;
	    p = ((char *)PMC_data(SELF)) + ix;
	}
	else
	    p = char_offset_key(interpreter, pmc, key, &type);
	set_int(p, type, value);
    }

    void set_number_keyed_int (INTVAL key, FLOATVAL value) {
	int type;
	char *p = char_offset_int(interpreter, pmc, key, &type);
	set_float(p, type, value);
    }

    void set_number_keyed (PMC *key, FLOATVAL value) {
	int type;
	char *p = char_offset_key(interpreter, pmc, key, &type);
	set_float(p, type, value);
    }

    void set_string_keyed_int (INTVAL key, STRING* value) {
	int type;
	char *p = char_offset_int(interpreter, pmc, key, &type);
	set_string(p, type, value);
    }

    void set_string_keyed (PMC *key, STRING* value) {
	int type;
	char *p = char_offset_key(interpreter, pmc, key, &type);
	set_string(p, type, value);
    }

}
