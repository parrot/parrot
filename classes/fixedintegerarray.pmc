/*
Copyright: 2001-2003 The Perl Foundation.  All Rights Reserved.
$Id$

=head1 NAME

classes/fixedintegerarray.pmc - fixed size array for integers only

=head1 DESCRIPTION

This class, FixedIntegerArray, implements an array of fixed size, which stored INTVALs,
it uses Integer PMCs for all of the conversions

=head2 Functions

=over 4

=cut

*/

#include "parrot/parrot.h"

pmclass FixedIntegerArray need_ext does array {

/*

=back

=head2 Methods

=over 4

=item C<void init()>

Initializes the array.

=cut

*/

    void init () {
        PMC_int_val(SELF) = 0;
        PMC_data(SELF) = NULL;
    }

/*

=item C<PMC new_from_string(STRING *rep)>

Class method to construct an array from the string representation C<rep>,
which is a string I<"(el0, el1, ...)">.

=cut

*/
    PMC* new_from_string(STRING *rep, INTVAL flags) {
        INTVAL type, n, elem;
        char *p, *start;
        UINTVAL i, l;
        int base;

        type = SELF->vtable->base_type;
        if (flags & PObj_constant_FLAG)
            SELF = constant_pmc_new(INTERP, type);
        else
            SELF = pmc_new(INTERP, type);
        if ((l = string_length(INTERP, rep)) <= 2)      /* "()" - no args */
            return SELF;
        if (rep->encoding != Parrot_fixed_8_encoding_ptr)
            real_exception(INTERP, NULL, E_ValueError,
                    "unhandled string encoding in constructor");
        /* count commas */
        p = rep->strstart;
        for (i = l, n = 0; i; --i, ++p) {
            if (*p == ',')
                ++n;
        }
        /* presize the array */
        SELF.set_integer_native(n + 1);
        /* parse string */
        p = rep->strstart;
        for (i = l, n = 0; i; --i, ++p) {
            switch (*p) {
                case ' ': continue;
                case '\t': continue;
                case '(': continue;
                case ')': break;
                case ',':
                          n++;
                          break;
                default:
                          base = 10;
                          if (*p == '0') {
                              ++p;
                              --i;
                              if (*p == 'b' || *p == 'B') {
                                  base = 2;
                                  ++p;
                                  --i;
                              }
                              else if (*p == 'x' || *p == 'X') {
                                  base = 16;
                                  ++p;
                                  --i;
                              }
                          }
                          start = p;
                          elem = strtoul(p, &p, base);
                          --p;
                          i -= (p - start);
                          SELF.set_integer_keyed_int(n, elem);
                          break;
            }
        }
        return SELF;
    }

/*

=item C<void morph(INTVAL type)>

Const classes must have a C<morph()>.

=cut

*/

    void morph(INTVAL type) {
        SUPER(type);
    }


/*

=item C<void destroy()>

Destroys the array.

=cut

*/

    void destroy () {
        if (PMC_data(SELF))
            mem_sys_free(PMC_data(SELF));
        PMC_data(SELF) = NULL;
        PMC_int_val(SELF) = 0;
    }

/*

=item C<PMC *clone()>

Creates and returns a copy of the array.

=cut

*/

    PMC* clone () {
        INTVAL size;
        PMC * dest;
        /* a quick hack to create a clone in the constant PMC arena
         * this is needed for the call signatures
         *
         * a better way would be probably to supply a flag to the clone
         * vtable
         */

        if (PObj_constant_TEST(SELF))
            dest = constant_pmc_new(INTERP, SELF->vtable->base_type);
        else
            dest = pmc_new(INTERP, SELF->vtable->base_type);

        if (!PMC_data(SELF))
            return dest;
        size = PMC_int_val(SELF);
        PMC_int_val(dest) = size;

        PMC_data(dest) = mem_sys_allocate(size * sizeof(INTVAL));
        mem_sys_memcopy(PMC_data(dest), PMC_data(SELF), size*sizeof(INTVAL));
        PObj_active_destroy_SET(dest);
        return dest;
    }

/*

=item C<INTVAL get_bool()>

Returns whether the array has any elements (meaning been initialized, for a
fixed sized array).

=cut

*/
    INTVAL get_bool () {
        INTVAL size = SELF.elements();
        return (INTVAL)(size != 0);
    }

/*

=item C<INTVAL elements()>

=cut

*/

    INTVAL elements () {
        return PMC_int_val(SELF);
    }

/*

=item C<INTVAL get_integer()>

Returns the number of elements in the array.

=cut

*/

    INTVAL get_integer () {
        return SELF.elements();
    }


/*

=item C<INTVAL get_integer_keyed_int(INTVAL key)>

Returns the integer value of the element at index C<key>.

=cut

*/

    INTVAL get_integer_keyed_int (INTVAL key) {
        INTVAL *data;
        if (key < 0 || key >= PMC_int_val(SELF))
            internal_exception(OUT_OF_BOUNDS,
                "FixedIntegerArray: index out of bounds!");

        data = (INTVAL *)PMC_data(SELF);
        return data[key];
    }

/*

=item C<INTVAL get_integer_keyed(PMC *key)>

Returns the integer value of the element at index C<*key>.

=cut

*/

    INTVAL get_integer_keyed (PMC* key) {
        /* simple int keys only */
        INTVAL k = key_integer(INTERP, key);
        return DYNSELF.get_integer_keyed_int(k);
    }


/*

=item C<FLOATVAL get_number_keyed_int(INTVAL key)>

Returns the floating-point value of the element at index C<key>.

=cut

*/

    FLOATVAL get_number_keyed_int (INTVAL key) {
        return (FLOATVAL)DYNSELF.get_integer_keyed_int(key);
    }

/*

=item C<FLOATVAL get_number_keyed (PMC* key)>

Returns the floating-point value of the element at index C<*key>.

=cut

*/

    FLOATVAL get_number_keyed (PMC* key) {
        INTVAL k = key_integer(INTERP, key);
        return DYNSELF.get_number_keyed_int(k);
    }

/*

=item C<STRING *get_string_keyed_int(INTVAL key)>

Returns the Parrot string value of the element at index C<key>.

=cut

*/

    STRING* get_string_keyed_int (INTVAL key) {
        PMC *temp;
        temp = DYNSELF.get_pmc_keyed_int(key);
        return VTABLE_get_string(INTERP, temp);
    }

/*

=item C<STRING *get_string_keyed(PMC *key)>

Returns the Parrot string value of the element at index C<*key>.

=cut

*/

    STRING* get_string_keyed(PMC* key) {
        INTVAL k = key_integer(INTERP, key);
        return DYNSELF.get_string_keyed_int(k);
    }


/*

=item C<PMC *get_pmc_keyed_int(INTVAL key)>

Returns the PMC value of the element at index C<key>.

=cut

*/

    PMC* get_pmc_keyed_int (INTVAL key) {
        PMC *ret;
        INTVAL val;

        ret = pmc_new(INTERP, enum_class_Integer);
        val = DYNSELF.get_integer_keyed_int(key);
        VTABLE_set_integer_native(INTERP, ret, val);
        return ret;
    }

/*

=item C<PMC *get_pmc_keyed(PMC *key)>

Returns the PMC value of the element at index C<*key>.

=cut

*/

    PMC* get_pmc_keyed(PMC* key) {
        INTVAL k = key_integer(INTERP, key);
        return DYNSELF.get_pmc_keyed_int(k);
    }

/*

=item C<void set_integer_native(INTVAL size)>

Resizes the array to C<size> elements.

=cut

*/

    void set_integer_native (INTVAL size) {
        if (PMC_int_val(SELF) || size < 1)
            internal_exception(OUT_OF_BOUNDS,
                "FixedIntegerArray: Can't resize!");
        PMC_int_val(SELF) = size;
        PMC_data(SELF) = mem_sys_allocate_zeroed(size * sizeof(INTVAL));
        PObj_active_destroy_SET(SELF);
    }

/*

=item C<void set_integer_keyed_int(INTVAL key, INTVAL value)>

Sets the integer value of the element at index C<key> to C<value>.

=cut

*/

    void set_integer_keyed_int (INTVAL key, INTVAL value) {
        INTVAL *data;
        if (key < 0 || key >= PMC_int_val(SELF))
            internal_exception(OUT_OF_BOUNDS,
                "FixedIntegerArray: index out of bounds!");

        data = (INTVAL*)PMC_data(SELF);
        data[key] = value;
    }

/*

=item C<void set_integer_keyed(PMC *key, INTVAL value)>

Sets the integer value of the element at index C<key> to C<value>.

=cut

*/

    void set_integer_keyed (PMC *key, INTVAL value) {
        INTVAL k;
        k = key_integer(INTERP, key);
        DYNSELF.set_integer_keyed_int(k, value);
    }

/*

=item C<void set_number_keyed_int(INTVAL key, FLOATVAL value)>

Sets the floating-point value of the element at index C<key> to
C<value>.

=cut

*/

    void set_number_keyed_int (INTVAL key, FLOATVAL value) {
        DYNSELF.set_integer_keyed_int(key, (INTVAL)value);
    }

/*

=item C<void set_number_keyed(PMC *key, FLOATVAL value)>

Sets the floating-point value of the element at index C<key> to
C<value>.

=cut

*/

    void set_number_keyed(PMC *key, FLOATVAL value) {
        INTVAL k;
        k = key_integer(INTERP, key);
        DYNSELF.set_number_keyed_int(k, value);
    }

/*

=item C<void set_string_keyed_int(INTVAL key, STRING *value)>

Sets the Parrot string value of the element at index C<key> to C<value>.

=cut

*/

    void set_string_keyed_int (INTVAL key, STRING* value) {
        INTVAL tempInt;
        PMC *tempPMC;

        tempPMC = pmc_new(INTERP, enum_class_Integer);
        VTABLE_set_string_native(INTERP, tempPMC, value);
        tempInt = VTABLE_get_integer(INTERP, tempPMC);
        DYNSELF.set_integer_keyed_int(key, tempInt);
    }

/*

=item C<void set_string_keyed(PMC *key, STRING* value)>

Sets the string value of the element at index C<key> to
C<value>.

=cut

*/

    void set_string_keyed(PMC *key, STRING* value) {
        INTVAL k;
        k = key_integer(INTERP, key);
        DYNSELF.set_string_keyed_int(k, value);
    }

/*

=item C<void set_pmc_keyed_int(INTVAL key, PMC *src)>

Sets the PMC value of the element at index C<key> to C<*src>.

=cut

*/

    void set_pmc_keyed_int (INTVAL key, PMC* src) {
        INTVAL tempInt;

        tempInt = VTABLE_get_integer(INTERP, src);
        DYNSELF.set_integer_keyed_int(key, tempInt);
    }

/*

=item C<void set_pmc_keyed(PMC *key, PMC* value)>

Sets the string value of the element at index C<key> to
C<value>.

=cut

*/

    void set_pmc_keyed(PMC *key, PMC* value) {
        INTVAL k;
        k = key_integer(INTERP, key);
        DYNSELF.set_pmc_keyed_int(k, value);
    }

}

/*

=back

=head1 SEE ALSO

F<docs/pdds/pdd17_basic_types.pod>.

=head1 HISTORY

Initial version 2004.06.11 by Matt Fowles

=cut

*/

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
 * vim: expandtab shiftwidth=4:
*/
