/*
Copyright: 2001-2003 The Perl Foundation.  All Rights Reserved.
$Id$

=head1 NAME

classes/sharedref.pmc - Shared PMC Reference

=head1 DESCRIPTION

The vtable functions for the SharedRef base class.

This class wraps locking around PMC access.

All methods not present below get a default body autogenerated inside
C<Parrot::Pmc2c>.

Currently all access is locked. When we have a non-copying GC allocator
we can relax that a bit.

=head2 Methods

=over 4

=cut

*/

#include "parrot/parrot.h"
#include "parrot/method_util.h"

/*
 * TODO we should catch exceptions around these locks
 *      if the vtable meth throws the lock is never unlocked
 */
#define LOCK_PMC(interp, pmc) LOCK(PMC_sync(pmc)->pmc_lock);
#define UNLOCK_PMC(interp, pmc) UNLOCK(PMC_sync(pmc)->pmc_lock);

/*
 * MMD dispatch macros
 */

#define VTABLE_bitwise_xor(i,l,r,d) mmd_dispatch_v_ppp(i,l,r,d,MMD_BXOR)
#define VTABLE_bitwise_xor_int(i,l,r,d) mmd_dispatch_v_pip(i,l,r,d,MMD_BXOR_INT)
#define VTABLE_add(i, l, r, d) mmd_dispatch_v_ppp(i, l, r, d, MMD_ADD)
#define VTABLE_add_int(i, l, r, d) mmd_dispatch_v_pip(i, l, r, d, MMD_ADD_INT)
#define VTABLE_add_float(i, l, r, d) mmd_dispatch_v_pnp(i, l, r, d, MMD_ADD_FLOAT)
#define VTABLE_subtract(i,l,r,d) mmd_dispatch_v_ppp(i,l,r,d,MMD_SUBTRACT)
#define VTABLE_subtract_int(i,l,r,d) mmd_dispatch_v_pip(i,l,r,d,MMD_SUBTRACT_INT)
#define VTABLE_subtract_float(i,l,r,d) mmd_dispatch_v_pnp(i,l,r,d,MMD_SUBTRACT_FLOAT)
#define VTABLE_multiply(i,l,r,d) mmd_dispatch_v_ppp(i,l,r,d,MMD_MULTIPLY)
#define VTABLE_multiply_int(i,l,r,d) mmd_dispatch_v_pip(i,l,r,d,MMD_MULTIPLY_INT)
#define VTABLE_multiply_float(i,l,r,d) mmd_dispatch_v_pnp(i,l,r,d,MMD_MULTIPLY_FLOAT)
#define VTABLE_divide(i,l,r,d) mmd_dispatch_v_ppp(i,l,r,d,MMD_DIVIDE)
#define VTABLE_divide_int(i,l,r,d) mmd_dispatch_v_pip(i,l,r,d,MMD_DIVIDE_INT)
#define VTABLE_divide_float(i,l,r,d) mmd_dispatch_v_pnp(i,l,r,d,MMD_DIVIDE_FLOAT)
#define VTABLE_floor_divide(i,l,r,d) mmd_dispatch_v_ppp(i,l,r,d,MMD_FLOOR_DIVIDE)
#define VTABLE_floor_divide_int(i,l,r,d) mmd_dispatch_v_pip(i,l,r,d,MMD_FLOOR_DIVIDE_INT)
#define VTABLE_floor_divide_float(i,l,r,d) mmd_dispatch_v_pnp(i,l,r,d,MMD_FLOOR_DIVIDE_FLOAT)
#define VTABLE_modulus(i,l,r,d) mmd_dispatch_v_ppp(i,l,r,d,MMD_MOD)
#define VTABLE_modulus_int(i,l,r,d) mmd_dispatch_v_pip(i,l,r,d,MMD_MOD_INT)
#define VTABLE_modulus_float(i,l,r,d) mmd_dispatch_v_pnp(i,l,r,d,MMD_MOD_FLOAT)
#define VTABLE_cmodulus(i,l,r,d) mmd_dispatch_v_ppp(i,l,r,d,MMD_CMOD)
#define VTABLE_cmodulus_int(i,l,r,d) mmd_dispatch_v_pip(i,l,r,d,MMD_CMOD_INT)
#define VTABLE_cmodulus_float(i,l,r,d) mmd_dispatch_v_pnp(i,l,r,d,MMD_CMOD_FLOAT)
#define VTABLE_bitwise_and(i,l,r,d) mmd_dispatch_v_ppp(i,l,r,d,MMD_BAND)
#define VTABLE_bitwise_and_int(i,l,r,d) mmd_dispatch_v_pip(i,l,r,d,MMD_BAND_INT)
#define VTABLE_bitwise_ors(i,l,r,d) mmd_dispatch_v_ppp(i,l,r,d,MMD_SOR)
#define VTABLE_bitwise_ors_str(i,l,r,d) mmd_dispatch_v_psp(i,l,r,d,MMD_SOR_STR)
#define VTABLE_bitwise_ands(i,l,r,d) mmd_dispatch_v_ppp(i,l,r,d,MMD_SAND)
#define VTABLE_bitwise_ands_str(i,l,r,d) mmd_dispatch_v_psp(i,l,r,d,MMD_SAND_STR)
#define VTABLE_bitwise_xors(i,l,r,d) mmd_dispatch_v_ppp(i,l,r,d,MMD_SXOR)
#define VTABLE_bitwise_xors_str(i,l,r,d) mmd_dispatch_v_psp(i,l,r,d,MMD_SXOR_STR)
#define VTABLE_bitwise_shl(i,l,r,d) mmd_dispatch_v_ppp(i,l,r,d,MMD_BSL)
#define VTABLE_bitwise_shl_int(i,l,r,d) mmd_dispatch_v_pip(i,l,r,d,MMD_BSL_INT)
#define VTABLE_bitwise_shr(i,l,r,d) mmd_dispatch_v_ppp(i,l,r,d,MMD_BSR)
#define VTABLE_bitwise_shr_int(i,l,r,d) mmd_dispatch_v_pip(i,l,r,d,MMD_BSR_INT)
#define VTABLE_bitwise_or(i,l,r,d) mmd_dispatch_v_ppp(i,l,r,d,MMD_BOR)
#define VTABLE_bitwise_or_int(i,l,r,d) mmd_dispatch_v_pip(i,l,r,d,MMD_BOR_INT)
#define VTABLE_concatenate(i,l,r,d) mmd_dispatch_v_ppp(i,l,r,d,MMD_CONCAT)
#define VTABLE_concatenate_str(i,l,r,d) mmd_dispatch_v_psp(i,l,r,d,MMD_CONCAT_STR)
#define VTABLE_logical_or(i,l,r,d) mmd_dispatch_v_ppp(i,l,r,d,MMD_LOR)
#define VTABLE_logical_and(i,l,r,d) mmd_dispatch_v_ppp(i,l,r,d,MMD_LAND)
#define VTABLE_logical_xor(i,l,r,d) mmd_dispatch_v_ppp(i,l,r,d,MMD_LXOR)
#define VTABLE_repeat(i,l,r,d) mmd_dispatch_v_ppp(i,l,r,d,MMD_REPEAT)
#define VTABLE_repeat_int(i,l,r,d) mmd_dispatch_v_pip(i,l,r,d,MMD_REPEAT_INT)
#define VTABLE_cmp(i,l,r) mmd_dispatch_i_pp(i,l,r,MMD_CMP)
#define VTABLE_cmp_num(i,l,r) mmd_dispatch_i_pp(i,l,r,MMD_NUMCMP)
#define VTABLE_cmp_string(i,l,r) mmd_dispatch_i_pp(i,l,r,MMD_STRCMP)
#define VTABLE_is_equal(i,l,r) mmd_dispatch_i_pp(i,l,r,MMD_EQ)
#define VTABLE_is_equal_num(i,l,r) mmd_dispatch_i_pp(i,l,r,MMD_NUMEQ)
#define VTABLE_is_equal_string(i,l,r) mmd_dispatch_i_pp(i,l,r,MMD_STREQ)
#define VTABLE_pow(i, l, r, d) mmd_dispatch_v_ppp(i, l, r, d, MMD_POW)
#define VTABLE_pow_float(i, l, r, d) mmd_dispatch_v_pnp(i, l, r, d, MMD_POW_FLOAT)
#define VTABLE_pow_int(i, l, r, d) mmd_dispatch_v_pnp(i, l, r, d, MMD_POW_INT)

pmclass SharedRef does ref need_ext is_shared extends Ref {


    void init () {
        SUPER();
    }

/*

=item C<void init_pmc(PMC *init)>

Initialize the shared reference.

TODO - If the PMC we refer to is an aggregate (or has properties) then:

=over 4

=item *

call C<share()> on the aggregate, which calls C<share()> on its contents
- so getting aggregate members only yields shared PMCs

=item *

and unshare the aggregate itself, because we lock on behalf of the
referee

=back

A direct dereference of the C<SharedRef> is currently not enabled so we
shouldn't leak unshared PMCs into different threads.

=cut

*/

    void init_pmc(PMC* init) {
        SUPER(init);
        PObj_active_destroy_SET(SELF);
    }

/*

=item C<void init_pmc_props(PMC *init, PMC *props)>

Initialize the shared reference with the specified properties.

=cut

*/

    void init_pmc_props(PMC* init, PMC* props) {
        SUPER(init, props);
        PObj_active_destroy_SET(SELF);
    }

/*

=item C<void share()>

We do already sharing - so just ignore.

=cut

*/

    void share () {
    }

/*

=item C<void mark()>

Marks the reference as live.

=cut

*/

    void mark () {
        SUPER();
    }

/*

=item C<void set_pmc(PMC *other)>

Sets the referenced PMC to C<*other>.

=item C<PMC* get_pmc()>

Catch dereferencing. This would unshare the referred PMC.

=cut

*/

    void set_pmc(PMC* other) {
        SUPER(other);
        PObj_active_destroy_SET(SELF);
    }

    PMC* get_pmc () {
        internal_exception(1, "deref not allowed");
        return NULL;
    }

/*

=item C<void destroy()>

Destroys the referred object and itself. This probably needs destroy ordering
or at least a detection if the referred PMC is already destroyed.

=cut

*/

    void destroy() {
        PMC *ref = PMC_pmc_val(SELF);
        if (PObj_active_destroy_TEST(ref))
            VTABLE_destroy(INTERP, ref);
        if (PMC_sync(SELF)->owner != INTERP)
            PANIC("SharedRef destroyed by wrong interpreter");
        MUTEX_DESTROY(PMC_sync(SELF)->pmc_lock);
        mem_sys_free(PMC_sync(SELF));
    }
}

/*

=back

=head1 HISTORY

Initial revision by leo 2004.01.14.

=cut

*/

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
 * vim: expandtab shiftwidth=4:
*/
