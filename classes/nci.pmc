/*
Copyright: 2001-2003 The Perl Foundation.  All Rights Reserved.
$Id$

=head1 NAME

classes/nci.pmc - Native Call Interface

=head1 DESCRIPTION

The vtable functions for the native C call functions.

Invoking an NCI function changes some registers according to PDD 3.

The caller has to preserve registers if needed.

=head2 Methods

=over 4

=cut

*/

#include "parrot/parrot.h"
#include "parrot/method_util.h"

pmclass NCI need_ext {

/*

=item C<void init()>

Initializes the NCI with a C<NULL> function pointer.

=cut

*/

    void init() {
        PMC_struct_val(SELF) = NULL;
        PMC_pmc_val(SELF) = NULL;
    }

/*

=item C<void set_pointer_keyed_str(STRING *key, void *func)>

Sets the specified function pointer and signature (C<*key>).

=cut

*/

    void set_pointer_keyed_str(STRING *key, void *func) {
        /* key = signature */
        PMC_struct_val(SELF) = func;
        PMC_data(SELF) = build_call_func(INTERP, SELF, key);
    }

/*

=item C<void destroy()>

Destroys the NCI, freeing any allocated memory.

=cut

*/

    void destroy() {
        if (PMC_data(SELF))
            mem_free_executable(PMC_data(SELF));
    }

/*

=item C<PMC *clone()>

Creates and returns a clone of the NCI.

=cut

*/

    PMC* clone () {
        PMC* ret = pmc_new_noinit(INTERP, SELF->vtable->base_type);
        PMC_struct_val(ret) = PMC_struct_val(SELF);
        PMC_pmc_val(ret) = NULL;
        /* FIXME if data is malloced (JIT/i386!) then we need
         * the length of data here, to memcpy it
         * ManagedStruct or Buffer?
         */
        PMC_data(ret) = PMC_data(SELF);
        return ret;
    }

/*

=item C<INTVAL defined()>

Returns whether the NCI is defined.

=cut

*/

    INTVAL defined () {
        return PMC_data(SELF) != NULL;
    }

/*

=item C<void *invoke(void *next)>

Calls the associated C function, returning C<*next>. If
the invocant is a class, the PMC arguments are
shifted down.

=cut

*/

    void* invoke (void * next) {
        Parrot_csub_t func = (Parrot_csub_t)D2FPTR(PMC_data(SELF));
        PMC *obj;
        /*
         * if the invocant is a class shift down arguments
         */
        obj = REG_PMC(2);
        if (PObj_is_class_TEST(obj) || obj->vtable->class == obj) {
            INTVAL i, n;
            REG_PMC(2) = REG_PMC(5);    /* obj = 1st arg */
            n = --REG_INT(3);             /* argcP */
            for (i = 0; i < n; ++i) {
                REG_PMC(i) = REG_PMC(i+1);
            }
        }
        func(INTERP, SELF);
        return next;
    }

/*

=item C<INTVAL get_integer()>

Returns the function pointer as an integer.

=cut

*/

    INTVAL get_integer () {
        return((INTVAL)PMC_data(SELF));
    }

/*

=item C<INTVAL get_bool()>

Returns the boolean value of the pointer.

=cut

*/

    INTVAL get_bool () {
        return(0 != (INTVAL)PMC_data(SELF));
    }

}

/*

=back

=head1 SEE ALSO

F<docs/pdds/pdd03_calling_conventions.pod>.

=head1 HISTORY

Initial revision by sean 2002/08/04.

=cut

*/

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
 * vim: expandtab shiftwidth=4:
*/
