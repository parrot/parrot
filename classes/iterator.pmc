/*
Copyright: 2001-2003 The Perl Foundation.  All Rights Reserved.
$Id$

=head1 NAME

classes/iterator.pmc - Iterator PMC

=head1 DESCRIPTION

These are the vtable functions for the Iterator base class

=head2 Methods

=over 4

=cut

*/

#include "parrot/parrot.h"

pmclass Iterator {

    void class_init() {
        if (pass) {
            enter_nci_method(INTERP, enum_class_Iterator,
                    F2DPTR(Parrot_Iterator_shift_pmc), "next", "PIO");
        }
    }

/*

=item C<void init()>

Raises an exception. Use C<init_pmc()>.

=cut

*/

void init () {
        internal_exception(1, "Iterator init without aggregate\n");
    }

/*

=item C<void init_pmc(PMC *initializer)>

Initializes the iterator with an aggregate PMC.

=cut

*/

    void init_pmc (PMC* initializer) {
        PMC_pmc_val(SELF) = initializer; /* the aggregate itself */
        PMC_struct_val(SELF) = NULL;
        PObj_custom_mark_SET(SELF);
    }

/*

=item C<void mark()>

Marks the current idx/key and the aggregate as live.

=cut

*/

    void mark () {
        if (PMC_struct_val(SELF)) /* the KEY */
             pobject_lives(INTERP, (PObj *) PMC_struct_val(SELF));
        if (PMC_pmc_val(SELF))      /* the aggregate */
             pobject_lives(INTERP, (PObj *) PMC_pmc_val(SELF));
    }

/*

=item C<PMC *clone()>

Unimplemented. Calls the C<default> method.

=cut

*/

    PMC* clone () {
        return SUPER();
        /* XXX TODO */
    }

/*

=item C<INTVAL get_integer()>

Get number of remaining elements. Does not work for hashes yet.
TODO: keep track of current position and direction

=cut

*/

    INTVAL get_integer () {
        PMC *agg = PMC_pmc_val(SELF);
        return VTABLE_get_integer(INTERP, agg );
    }

/*

=item C<STRING *get_string()>

Returns the number of remaining elements as a Parrot string.
TODO: keep track of current position and direction

=cut

*/

    STRING* get_string () {
        PMC *agg = PMC_pmc_val(SELF);
        return string_from_int(INTERP, VTABLE_get_integer(INTERP, agg ) );
    }

/*

=item C<INTVAL get_integer_keyed(PMC *key)>

=cut

*/

    INTVAL get_integer_keyed (PMC* key) {
        return VTABLE_get_integer_keyed(INTERP, (PMC *)PMC_pmc_val(SELF), key);
    }

/*

=item C<INTVAL get_integer_keyed_int(INTVAL idx)>

Get integer value of current position plus idx.

=cut

*/

    INTVAL get_integer_keyed_int (INTVAL idx) {
        PMC *key = PMC_struct_val(SELF);
        PMC *agg = PMC_pmc_val(SELF);
        return VTABLE_get_integer_keyed_int(INTERP, agg, PMC_int_val(key) + idx );
    }

/*

=item C<FLOATVAL get_number_keyed(PMC *key)>

=cut

*/

    FLOATVAL get_number_keyed (PMC* key) {
        return VTABLE_get_number_keyed(INTERP,(PMC *)PMC_pmc_val(SELF), key );
    }

/*

=item C<FLOATVAL get_number_keyed_int(INTVAL idx)>

Get number value of current position plus idx.

=cut

*/

    FLOATVAL get_number_keyed_int (INTVAL idx) {
        PMC *key = PMC_struct_val(SELF);
        PMC *agg = PMC_pmc_val(SELF);
        return VTABLE_get_number_keyed_int(INTERP, agg, PMC_int_val(key) + idx );
    }

/*

=item C<BIGNUM *get_bignum_keyed(PMC *key)>

=cut

*/

    BIGNUM* get_bignum_keyed (PMC* key) {
        return VTABLE_get_bignum_keyed(INTERP, (PMC *)PMC_pmc_val(SELF), key);
    }

/*

=item C<BIGNUM *get_bignum_keyed_int(INTVAL idx)>

Get bignum value of current position plus idx.

=cut

*/

    BIGNUM* get_bignum_keyed_int (INTVAL idx) {
        PMC *key = PMC_struct_val(SELF);
        PMC *agg = PMC_pmc_val(SELF);
        return VTABLE_get_bignum_keyed_int(INTERP, agg, PMC_int_val(key) + idx );
    }

/*

=item C<STRING *get_string_keyed(PMC *key)>

=cut

*/

    STRING* get_string_keyed (PMC* key) {
        return VTABLE_get_string_keyed(INTERP, (PMC *)PMC_pmc_val(SELF), key);
    }

/*

=item C<STRING *get_string_keyed_int(INTVAL idx)>

Get string value of current position plus idx.

=cut

*/

    STRING* get_string_keyed_int (INTVAL idx) {
        PMC *key = PMC_struct_val(SELF);
        PMC *agg = PMC_pmc_val(SELF);
        return VTABLE_get_string_keyed_int(INTERP, agg, PMC_int_val(key) + idx );
    }

/*

=item C<INTVAL get_bool()>

Returns true if the idx/key is not C<-1>.

=cut

*/

    INTVAL get_bool () {
        PMC *key = PMC_struct_val(SELF);
        return key && PMC_int_val(key) != -1;
    }

/*

=item C<INTVAL elements()>

Returns the number of elements in the aggregate.

=cut

*/

    INTVAL elements () {
        return VTABLE_elements(INTERP, (PMC *)PMC_pmc_val(SELF));
    }

/*

=item C<PMC *get_pmc_keyed(PMC *key)>

Returns the element for C<*key>.

=cut

*/

    PMC* get_pmc_keyed (PMC* key) {
        return VTABLE_get_pmc_keyed(INTERP, (PMC *)PMC_pmc_val(SELF), key);
    }

/*

=item C<PMC *get_pmc_keyed_int(INTVAL key)>

Returns the element for C<key>.

=cut

*/

    PMC* get_pmc_keyed_int (INTVAL idx) {
        PMC *key = PMC_struct_val(SELF);
        PMC *agg = PMC_pmc_val(SELF);
        return VTABLE_get_pmc_keyed_int(INTERP, agg, PMC_int_val(key) + idx );
    }

/*

=item C<void set_integer_native(INTVAL value)>

Reset the Iterator. C<value> must be one of

 ITERATE_FROM_START        ... Iterate from start
 ITERATE_FROM_START_KEYS   ... OrderedHash by keys
 ITERATE_FROM_END          ... Arrays and PerlString only

=cut

*/

    void set_integer_native (INTVAL value) {
        PMC *key, *agg;
        if (value < ITERATE_FROM_START || value > ITERATE_FROM_END)
            internal_exception(1, "Illegal set_integer on iterator\n");
        /* reset iterator on aggregate */
        agg = (PMC*) PMC_pmc_val(SELF);
        if (agg->vtable->base_type == enum_class_Slice) {
            /* its an xrange serving as its own aggregate */
            PMC_struct_val(SELF) =
                VTABLE_nextkey_keyed(INTERP, agg, NULL, value);
        }
        else {
            if (!PMC_struct_val(SELF)) {
                PMC_struct_val(SELF) = key_new(INTERP);
            }
            if (agg->vtable->base_type == enum_class_OrderedHash &&
                    value == ITERATE_FROM_START_KEYS) {
                PObj_get_FLAGS(agg) |= PObj_private0_FLAG;
            }
            key = PMC_struct_val(SELF);
            PMC_struct_val(SELF) =
                VTABLE_nextkey_keyed(INTERP, key, agg, value);
        }
    }

/*

=item C<INTVAL pop_integer()>

=cut

*/

    INTVAL pop_integer () {
        PMC *key = PMC_struct_val(SELF);
        PMC *agg = PMC_pmc_val(SELF);
        INTVAL ret = VTABLE_get_integer_keyed(INTERP, agg, key);
        PMC_struct_val(SELF) =
            VTABLE_nextkey_keyed(INTERP, key, agg, ITERATE_GET_PREV);
        return ret;
    }

/*

=item C<FLOATVAL pop_float()>

=cut

*/

    FLOATVAL pop_float () {
        PMC *key = PMC_struct_val(SELF);
        PMC *agg = PMC_pmc_val(SELF);
        FLOATVAL ret = VTABLE_get_number_keyed(INTERP, agg, key);
        PMC_struct_val(SELF) =
            VTABLE_nextkey_keyed(INTERP, key, agg, ITERATE_GET_PREV);
        return ret;
    }

/*

=item C<BIGNUM *pop_bignum()>

=cut

*/

    BIGNUM* pop_bignum () {
        PMC *key = PMC_struct_val(SELF);
        PMC *agg = PMC_pmc_val(SELF);
        BIGNUM *ret = VTABLE_get_bignum_keyed(INTERP, agg, key);
        PMC_struct_val(SELF) =
            VTABLE_nextkey_keyed(INTERP, key, agg, ITERATE_GET_PREV);
        return ret;
    }

/*

=item C<STRING *pop_string()>

=cut

*/

    STRING* pop_string () {
        PMC *key = PMC_struct_val(SELF);
        PMC *agg = PMC_pmc_val(SELF);
        STRING *ret = VTABLE_get_string_keyed(INTERP, agg, key);
        PMC_struct_val(SELF) =
            VTABLE_nextkey_keyed(INTERP, key, agg, ITERATE_GET_PREV);
        return ret;
    }

/*

=item C<PMC *pop_pmc()>

Returns the element for the current idx/key and sets the idx/key to
the previous one.

=cut

*/

    PMC* pop_pmc () {
        PMC *key = PMC_struct_val(SELF);
        PMC *agg = PMC_pmc_val(SELF);
        PMC *ret = VTABLE_get_pmc_keyed(INTERP, agg, key);
        PMC_struct_val(SELF) =
            VTABLE_nextkey_keyed(INTERP, key, agg, ITERATE_GET_PREV);
        return ret;
    }

/*

=item C<INTVAL shift_integer()>

Returns the element for the current idx/key and sets the idx/key to
the next one.

=cut

*/

    INTVAL shift_integer () {
        PMC *key = PMC_struct_val(SELF);
        PMC *agg = PMC_pmc_val(SELF);
        INTVAL ret = VTABLE_get_integer_keyed(INTERP, agg, key);
        PMC_struct_val(SELF) =
            VTABLE_nextkey_keyed(INTERP, key, agg, ITERATE_GET_NEXT);
        return ret;
    }

/*

=item C<void* invoke(void* next)>

Return the next element of the aggregate. The return type may depend on
the aggregate. If there are no more items in the aggregate I1 .. I4 are
zero.

See F<docs/pdds/pdd03_calling_conventions.pod>.

=cut

*/
    void* invoke(void *next) {
        PMC *agg, *key, *res;
        INTVAL ires;

        REG_INT(1) = REG_INT(2) = REG_INT(3) = REG_INT(4) = 0;
        if (!key)
            return next;
        if (PMC_int_val(key) == -1) {
            real_exception(INTERP, NULL, E_StopIteration, "StopIteration");
            return next;
        }
        key = PMC_struct_val(SELF);
        agg = PMC_pmc_val(SELF);
        switch (agg->vtable->base_type) {
            case enum_class_IntList:
                ires = DYNSELF.shift_integer();
                REG_INT(1) = 1;
                REG_INT(5) = ires;
                return next;
            default:
                res = DYNSELF.shift_pmc();
                REG_INT(3) = 1;
                REG_PMC(5) = res;
                return next;
        }
    }

/*

=item C<FLOATVAL shift_float()>

=cut

*/

    FLOATVAL shift_float () {
        PMC *key = PMC_struct_val(SELF);
        PMC *agg = PMC_pmc_val(SELF);
        FLOATVAL ret = VTABLE_get_number_keyed(INTERP, agg, key);
        PMC_struct_val(SELF) =
            VTABLE_nextkey_keyed(INTERP, key, agg, ITERATE_GET_NEXT);
        return ret;
    }

/*

=item C<BIGNUM *shift_bignum()>

=cut

*/

    BIGNUM* shift_bignum () {
        PMC *key = PMC_struct_val(SELF);
        PMC *agg = PMC_pmc_val(SELF);
        BIGNUM *ret = VTABLE_get_bignum_keyed(INTERP, agg, key);
        PMC_struct_val(SELF) =
            VTABLE_nextkey_keyed(INTERP, key, agg, ITERATE_GET_NEXT);
        return ret;
    }

/*

=item C<STRING *shift_string()>

=cut

*/

    STRING* shift_string () {
        PMC *key = PMC_struct_val(SELF);
        PMC *agg = PMC_pmc_val(SELF);
        STRING * ret = VTABLE_get_string_keyed(INTERP, agg, key);
        PMC_struct_val(SELF) =
            VTABLE_nextkey_keyed(INTERP, key, agg, ITERATE_GET_NEXT);
        return ret;
    }

/*

=item C<PMC* shift_pmc()>

Returns the element for the current idx/key and sets the idx/key to
the next one.

=cut

*/

    PMC* shift_pmc () {
        PMC *key = PMC_struct_val(SELF);
        PMC *agg = PMC_pmc_val(SELF);
        PMC *ret = VTABLE_get_pmc_keyed(INTERP, agg, key);
        PMC_struct_val(SELF) =
            VTABLE_nextkey_keyed(INTERP, key, agg, ITERATE_GET_NEXT);
        return ret;
    }

/*

=item C<INTVAL exists_keyed(PMC *key)>

Returns whether an element for C<*key> exists in the aggregate.

=cut

*/

    INTVAL exists_keyed (PMC* key) {
        return VTABLE_exists_keyed(INTERP, (PMC *)PMC_pmc_val(SELF), key);
    }

/*

=item C<INTVAL exists_keyed_int(INTVAL idx)>

Returns whether an element for C<idx> exists in the aggregate.

=cut

*/

    INTVAL exists_keyed_int (INTVAL idx) {
        PMC *key = PMC_struct_val(SELF);
        PMC *agg = PMC_pmc_val(SELF);
        return VTABLE_exists_keyed_int(INTERP, agg, PMC_int_val(key) + idx );
    }

/*

=item C<INTVAL defined()>

Returns whether the iterator contains an aggregate.

=cut

*/

    INTVAL defined () {
        return (INTVAL) (PMC_pmc_val(SELF) != 0);
    }

/*

=item C<INTVAL defined_keyed(PMC *key)>

=cut

*/

    INTVAL defined_keyed (PMC* key) {
        return VTABLE_defined_keyed(INTERP, (PMC *)PMC_pmc_val(SELF), key);
    }

/*

=item C<INTVAL defined_keyed_int(INTVAL key)>

Returns the result of calling C<defined_keyed(key)> on the aggregate.

=cut

*/

    INTVAL defined_keyed_int (INTVAL idx) {
        PMC *key = PMC_struct_val(SELF);
        PMC *agg = PMC_pmc_val(SELF);
        return VTABLE_defined_keyed_int(INTERP, agg, PMC_int_val(key) + idx );
    }

/*

=item C<INTVAL type_keyed(PMC *key)>

Returns the result of calling C<type_keyed(key)> on the aggregate.

=cut

*/

    INTVAL type_keyed (PMC* key) {
        return VTABLE_type_keyed(INTERP, (PMC *)PMC_pmc_val(SELF), key);
    }

/*

=item C<INTVAL type_keyed_int(PMC *idx)>

Returns the result of calling C<type_keyed(key)> on the aggregate.

=cut

*/

    INTVAL type_keyed_int (INTVAL idx) {
        PMC *key = PMC_struct_val(SELF);
        PMC *agg = PMC_pmc_val(SELF);
        return VTABLE_type_keyed_int(INTERP, agg, PMC_int_val(key) + idx );
    }

    PMC* get_iter () {
        return SELF;
    }
}

/*

=back

=cut

*/

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
 * vim: expandtab shiftwidth=4:
*/
