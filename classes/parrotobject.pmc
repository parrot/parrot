/*
Copyright: 2001-2003 The Perl Foundation.  All Rights Reserved.
$Id$

=head1 NAME

classes/ - Parrot Object

=head1 DESCRIPTION

A Parrot Object is reasonably simple. Its data pointer points to an
array with the attributes of the object in it. The int cache value holds
the offset in that array of the first attribute, so we can front-load
the array with invisible options.

The array holds:

=over 4

=item 0

The first element of the attribute array is a pointer to the class PMC
for this object.

=item 1

The class name (taken from the class PMC)

=item 2...

Attributes.

=back

The object is actually constructed by the instantiation code in
F<src/objects.c>, at least for right now.

=head2 Methods

=over 4

=cut

*/

#include "parrot/parrot.h"

/* XXX duplicated from delegate.pmc */
static PMC *
find_meth(Interp* interpreter, PMC *pmc, STRING *meth) {
    PMC *class = pmc;

    if (Interp_trace_TEST(interpreter, PARROT_TRACE_SUB_CALL_FLAG)) {
        char *name = string_to_cstring(interpreter, meth);
        PIO_eprintf(interpreter, "# Calling meth '%s'\n#", name);
        string_cstring_free(name);
        print_pbc_location(interpreter);
    }
    if (PObj_is_object_TEST(pmc)) {
        class = GET_CLASS((Buffer *)PMC_data(pmc), pmc);
    }
    return Parrot_find_method_with_cache(interpreter, class, meth);
}
pmclass ParrotObject extends ParrotClass need_ext {

/*

=item C<void init()>

Raises an exception to make sure all users call C<new> on the registered
class PMC and not the ParrotObject itself.

During C<Parrot_class_register()> this C<init()> method gets replaced by
C<Parrot_instantiate_object()>.

=cut

*/

    void init() {
        internal_exception(1, "Can't create new ParrotObjects - "
            "use the registered class instead");
    }

/*

=item C<void init_pmc(PMC *init)>

=cut

*/

    void init_pmc(PMC* init) {
        SELF.init();
    }

/*

=item C<void init_pmc_props(PMC *init, PMC *props)>

These two methods just call C<init()>. The arguments are ignored.

=cut

*/

    void init_pmc_props(PMC* init, PMC* props) {
        SELF.init();
    }


    STRING* name() {
        return VTABLE_get_string(INTERP,
                (PMC *)get_attrib_num((Buffer *)PMC_data(SELF),
                                      POD_CLASS_NAME));
    }


/*

=item C<PMC *find_method(STRING *name)>

Finds the method for C<*name>.

=item C<PMC* get_attr(INTVAL idx)>

Return attribute number C<idx>.

=item C<PMC* get_attr_str(STRING *name)>

Return attribute named C<name>.

=item C<void set_attr(INTVAL idx, PMC *val)>

Set attribute number C<idx>.

=item C<void set_attr_str(STRING *name, PMC *val)>

Set attribute named C<name>.

=item C<PMC *get_class()>

Return the class of this object.

=cut

*/

    PMC* find_method(STRING* name) {
        PMC *class = VTABLE_get_class(INTERP, SELF);
        return VTABLE_find_method(INTERP, class, name);
    }

    PMC* get_attr(INTVAL idx) {
        return Parrot_get_attrib_by_num(INTERP, SELF, idx);
    }

    PMC* get_attr_str(STRING* idx) {
        return Parrot_get_attrib_by_str(INTERP, SELF, idx);
    }

    void set_attr(INTVAL idx, PMC* value) {
        Parrot_set_attrib_by_num(INTERP, SELF, idx, value);
    }

    void set_attr_str(STRING* idx, PMC* value) {
        Parrot_set_attrib_by_str(INTERP, SELF, idx, value);
    }

    PMC* get_class() {
        return GET_CLASS(PMC_data(SELF), SELF);
    }

/*

=item C<INTVAL get_integer_keyed_int(INTVAL key)>

=item C<FLOATVAL get_number_keyed_int(INTVAL key)>

=item C<STRING *get_string_keyed_int(INTVAL key)>

=item C<PMC *get_pmc_keyed_int(INTVAL key)>

=item C<void set_integer_keyed_int (INTVAL key, INTVAL value)>

=item C<void set_number_keyed_int (INTVAL key, FLOATVAL value)>

=item C<void set_string_keyed_int (INTVAL key, STRING* value)>

=item C<void set_pmc_keyed_int (INTVAL key, PMC* value)>

=item C<void delete_keyed_int(INTVAL key)>

=item C<INTVAL defined_keyed_int(INTVAL key)>

=item C<INTVAL exists_keyed_int(INTVAL key)>

These methods have default implementations in F<classes/default.pmc>
which redirect to PMC keys. Test if a specialized method exists, else
use fallback.

=cut

*/

    INTVAL get_integer_keyed_int (INTVAL key) {
        STRING *meth = CONST_STRING(interpreter, "__get_integer_keyed_int");
        PMC *sub = find_meth(interpreter, pmc, meth);
        if (sub) {
            return Parrot_run_meth_fromc_args_reti(interpreter, sub,
                                              pmc, meth, "II", key);
        }
        else
            return SUPER(key);
    }

    FLOATVAL get_number_keyed_int (INTVAL key) {
        STRING *meth = CONST_STRING(interpreter, "__get_number_keyed_int");
        PMC *sub = find_meth(interpreter, pmc, meth);
        if (sub) {
            return Parrot_run_meth_fromc_args_retf(interpreter, sub,
                                              pmc, meth, "NI", key);
        }
        else
            return SUPER(key);
    }

    STRING* get_string_keyed_int (INTVAL key) {
        STRING *meth = CONST_STRING(interpreter, "__get_string_keyed_int");
        PMC *sub = find_meth(interpreter, pmc, meth);
        if (sub) {
            return Parrot_run_meth_fromc_args(interpreter, sub,
                                              pmc, meth, "SI", key);
        }
        else
            return SUPER(key);
    }

    PMC* get_pmc_keyed_int (INTVAL key) {
        STRING *meth = CONST_STRING(interpreter, "__get_pmc_keyed_int");
        PMC *sub = find_meth(interpreter, pmc, meth);
        if (sub) {
            return Parrot_run_meth_fromc_args(interpreter, sub,
                                              pmc, meth, "PI", key);
        }
        else
            return SUPER(key);
    }

    void set_integer_keyed_int (INTVAL key, INTVAL value) {
        STRING *meth = CONST_STRING(interpreter, "__set_integer_keyed_int");
        PMC *sub = find_meth(interpreter, pmc, meth);
        if (sub) {
            (void) Parrot_run_meth_fromc_args(interpreter, sub,
                                              pmc, meth, "vII", key, value);
        }
        else
            SUPER(key, value);
    }

    void set_number_keyed_int (INTVAL key, FLOATVAL value) {
        STRING *meth = CONST_STRING(interpreter, "__set_number_keyed_int");
        PMC *sub = find_meth(interpreter, pmc, meth);
        if (sub) {
            (void) Parrot_run_meth_fromc_args(interpreter, sub,
                                              pmc, meth, "vIN", key, value);
        }
        else
            SUPER(key, value);
    }

    void set_string_keyed_int (INTVAL key, STRING* value) {
        STRING *meth = CONST_STRING(interpreter, "__set_string_keyed_int");
        PMC *sub = find_meth(interpreter, pmc, meth);
        if (sub) {
            (void) Parrot_run_meth_fromc_args(interpreter, sub,
                                              pmc, meth, "vIS", key, value);
        }
        else
            SUPER(key, value);
    }

    void set_pmc_keyed_int (INTVAL key, PMC* value) {
        STRING *meth = CONST_STRING(interpreter, "__set_pmc_keyed_int");
        PMC *sub = find_meth(interpreter, pmc, meth);
        if (sub) {
            (void) Parrot_run_meth_fromc_args(interpreter, sub,
                                              pmc, meth, "vIP", key, value);
        }
        else
            SUPER(key, value);
    }

    void delete_keyed_int (INTVAL key) {
        STRING *meth = CONST_STRING(interpreter, "__delete_keyed_int");
        PMC *sub = find_meth(interpreter, pmc, meth);
        if (sub) {
            (void) Parrot_run_meth_fromc_args(interpreter, sub,
                                              pmc, meth, "vI", key);
        }
        else
            SUPER(key);
    }

    INTVAL defined_keyed_int (INTVAL key) {
        STRING *meth = CONST_STRING(interpreter, "__defined_keyed_int");
        PMC *sub = find_meth(interpreter, pmc, meth);
        if (sub) {
            return Parrot_run_meth_fromc_args_reti(interpreter, sub,
                                              pmc, meth, "II", key);
        }
        else
            return SUPER(key);
    }

    INTVAL exists_keyed_int (INTVAL key) {
        STRING *meth = CONST_STRING(interpreter, "__exists_keyed_int");
        PMC *sub = find_meth(interpreter, pmc, meth);
        if (sub) {
            return Parrot_run_meth_fromc_args_reti(interpreter, sub,
                                              pmc, meth, "II", key);
        }
        else
            return SUPER(key);
    }

/*

=item C<void visit(visit_info *info)>

This is used by freeze/thaw to visit the contents of the object.

C<*info> is the visit info, (see F<include/parrot/pmc_freeze.h>).

=item C<void freeze(visit_info *info)>

Used to archive the object.

=item C<void thaw(visit_info *info)>

Used to unarchive the object.

=item C<void thawfinish(visit_info *info)>

=cut

*/

    void visit(visit_info *info) {
        PMC **class_data, **pos;
        INTVAL i, n;

        class_data = (PMC **)PMC_data(SELF);

        /* 1) visit class */
        pos = class_data + POD_CLASS;
        info->thaw_ptr = pos;
        (info->visit_pmc_now)(INTERP, *pos, info);

        /* 2) visit the attributes */
        n = PMC_int_val(SELF);
        for (i = POD_FIRST_ATTRIB; i < n; ++i) {
            info->thaw_ptr = class_data + i;
            (info->visit_pmc_now)(INTERP, class_data[i], info);
        }
    }
    void freeze(visit_info *info) {
        IMAGE_IO *io = info->image_io;
        io->vtable->push_integer(INTERP, io, PMC_int_val(SELF));
    }

    void thaw(visit_info *info) {
        IMAGE_IO *io = info->image_io;
        if (info->extra_flags == EXTRA_IS_PROP_HASH) {
            SUPER(info);
        }
        else if (info->extra_flags == EXTRA_IS_NULL) {
            INTVAL n = io->vtable->shift_integer(INTERP, io);
            set_attrib_array_size(SELF, n);
        }
    }

    void thawfinish(visit_info *info) {
        PMC *class = get_attrib_num((SLOTTYPE *)PMC_data(SELF), POD_CLASS);
        PMC *class_name = get_attrib_num((SLOTTYPE *)PMC_data(class),
            PCD_CLASS_NAME);
        PMC *vtable_pmc = get_attrib_num((SLOTTYPE *)PMC_data(class),
                PCD_OBJECT_VTABLE);
        SELF->vtable = PMC_struct_val(vtable_pmc);
        set_attrib_num(SELF, PMC_data(SELF), POD_CLASS_NAME, class_name);
        set_attrib_flags(SELF);
        PObj_is_object_SET(SELF);
    }
}

/*

=back

=cut

*/

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
 * vim: expandtab shiftwidth=4:
*/
