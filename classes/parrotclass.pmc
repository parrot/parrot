/*
Copyright: 2001-2003 The Perl Foundation.  All Rights Reserved.
$Id$

=head1 NAME

classes/parrotclass.pmc - Parrot Class

=head1 DESCRIPTION

The structure of a parrot class is reasonably straightforward. The PMC's
cached integer value is the number of attribute slots that an object of
this type requires. The data pointer holds a pointer to an array of
PMCs. That array has:

=over 4

=item 0, PCD_PARENTS

An array of immediate parents.

=item 1, PCD_CLASS_NAME

The class name PMC.

=item 2, PCD_ATTRIB_OFFS

A hash, keys are the class names, values are the offsets to their attributes.

=item 3, PCD_ATTRIBUTES

A hash, the keys are the classname/attrib name pair (separated by a
C<NULL>), while the value is the offset to the attribute.

=item 4, PCD_CLASS_ATTRIBUTES

Array of attribute of this class.

=item 5, PCD_OBJECT_VTABLE

Vtable PMC that holds the vtable for objects of this class.

=item ex 2, PCD_ALL_PARENTS

Is now class->vtable->mro and contains the class itself too.

=back

=head2 Methods

=over 4

=cut

*/

#include "parrot/parrot.h"

pmclass ParrotClass extends delegate need_ext {

/*

=item C<void init()>

Initializes the class.

=cut

*/

    void init () {
        /* No attributes to start with */
        PMC_int_val(SELF) = ATTRIB_COUNT(SELF) = 0;
        /* But we are a class, really */
        PObj_is_class_SET(SELF);
        PObj_data_is_PMC_array_SET(SELF);
        /* s. Parrot_new_class() for more initialization */
    }

/*

=item C<INTVAL isa(STRING *classname)>

Returns whether the class is or inherits from C<*classname>.

=cut

*/

    INTVAL isa(STRING* classname) {
        PMC *class;
        if (SUPER(classname))
            return 1;
        class = Parrot_class_lookup(INTERP, classname);
        return Parrot_object_isa(INTERP, SELF, class);
    }


/*

=item C<PMC *get_class()>

Return SELF.

=item C<STRING* namespace_name()>

Return the name of the namespace, which is the classname of ParrotClass
classes.

=cut

*/

    PMC* get_class() {
        return SELF;
    }

    STRING* namespace_name() {
        PMC **class_data;
        class_data = (PMC **)PMC_data(SELF);

        return VTABLE_get_string(INTERP, class_data[PCD_CLASS_NAME]);
    }

/*

=item C<void visit(visit_info *info)>

This is used by freeze/thaw to visit the contents of the class.

C<*info> is the visit info, (see F<include/parrot/pmc_freeze.h>).

=item C<void freeze(visit_info *info)>

Used to archive the class.

=item C<void thaw(visit_info *info)>

Used to unarchive the class.

=item C<void thawfinish(visit_info *info)>

Create the class from the thawed parents and attributes array.

=cut

*/

    void visit(visit_info *info) {
        PMC **class_data, **pos;

        class_data = (PMC **)PMC_data(SELF);

        /* 2) direct parents array */
        if (info->what == VISIT_THAW_NORMAL ||
                info->what == VISIT_FREEZE_AT_DESTRUCT)
            pos = class_data + PCD_MAX;
        else
            pos = class_data + PCD_PARENTS;
        info->thaw_ptr = pos;
        (info->visit_pmc_now)(INTERP, *pos, info);

        /* 3) attributes array */
        if (info->what == VISIT_THAW_NORMAL ||
                info->what == VISIT_FREEZE_AT_DESTRUCT)
            pos = class_data + PCD_MAX + 1;
        else
            pos = class_data + PCD_CLASS_ATTRIBUTES;
        info->thaw_ptr = pos;
        (info->visit_pmc_now)(INTERP, *pos, info);

        SUPER(info);
    }

    void freeze(visit_info *info) {
        IMAGE_IO *io = info->image_io;
        PMC **class_data, **pos;

        SUPER(info);
        class_data = (PMC **)PMC_data(SELF);

        /* 1) freeze class name */
        pos = class_data + PCD_CLASS_NAME;
        io->vtable->push_string(INTERP, io,
                VTABLE_get_string(INTERP, *pos));

    }

    void thaw(visit_info *info) {
        IMAGE_IO *io = info->image_io;

        /*
         * Thawing a class is tricky - it might or might not exist
         * in the interpreter, where it get thawed.
         * Additionally, it could happen that a class exists
         * but the thawed one differs.
         *
         * So here's the plan:
         * During thaw, we first extend the class_data by two,
         * thaw parents and attribs into that new area, and
         * then we see what to do.
         */
        if (info->extra_flags == EXTRA_IS_PROP_HASH) {
            SUPER(info);
        }
        else if (info->extra_flags == EXTRA_IS_NULL) {
            STRING *class_name;
            INTVAL new_type;
            PMC *real_class;

            /* thaw class name */
            class_name = io->vtable->shift_string(INTERP, io);
            /* if class exists in this interpreter, check if the
             * thawed class is the same, if not bail out, if yes
             * ignore the class, consume the byte string
             */
            new_type = pmc_type(INTERP, class_name);
            if (new_type > enum_type_undef) {
                real_class = Parrot_class_lookup(INTERP, class_name);
                info->extra = real_class;
                info->extra_flags = EXTRA_CLASS_EXISTS;
            }
            else {
                real_class = SELF;
                SELF.init();
                Parrot_new_class(INTERP, SELF, class_name);
            }
            /* make room for thawed arrays */
            if (PMC_int_val(real_class) == PCD_MAX) {
                PMC **class_data;
                resize_attrib_array(real_class, PCD_MAX + 2);
                class_data = (PMC **)PMC_data(real_class);
                class_data[PCD_MAX] = NULL;
                class_data[PCD_MAX + 1] = NULL;
            }

        }
    }

    void thawfinish(visit_info *info) {
        INTVAL i, n, nold;
        PMC * class;
        PMC *parents, *attribs, *old;
        PMC **class_data;

        class = SELF;
        class_data = (PMC**)(PMC_data(class));

        old = class_data[PCD_PARENTS];
        nold = VTABLE_elements(INTERP, old);
        parents = class_data[PCD_MAX];
        if (!parents)
            n = 0;
        else
            n = VTABLE_elements(INTERP, parents);
        if (nold && n != nold)
            internal_exception(1, "thawed class differs");
        /* TODO compare elements */
        if (!nold) {
            for (i = 0; i < n; ++i) {
                Parrot_add_parent(INTERP, class,
                        VTABLE_get_pmc_keyed_int(INTERP, parents, i));
            }
        }
        /*
         * preserve the thawed attrib array
         */
        old = class_data[PCD_CLASS_ATTRIBUTES];
        nold = VTABLE_elements(INTERP, old);
        attribs = class_data[PCD_MAX + 1];
        if (!attribs)
            n = 0;
        else
            n = VTABLE_elements(INTERP, attribs);
        if (nold && n != nold)
            internal_exception(1, "thawed class differs");
        /* TODO compare attribs */

        if (!nold) {
            for (i = 0; i < n; ++i) {
                Parrot_add_attribute(INTERP, class,
                        VTABLE_get_string_keyed_int(INTERP, attribs, i));
            }
        }
        class_data[PCD_MAX] = NULL;
        class_data[PCD_MAX + 1] = NULL;
    }

}

/*

=back

=cut

*/

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
 * vim: expandtab shiftwidth=4:
*/
