/* Sub.pmc
 *  Copyright: 2001-2003 The Perl Foundation.  All Rights Reserved.
 *  CVS Info
 *     $Id$
 *  Overview:
 *     These are the vtable functions for the Sub (subroutine) base class
 *  Data Structure and Algorithms:
 *  History:
 *     Initial version by Melvin on 2002/06/6
 *  Notes:
 *  References:
 */

#include "parrot/parrot.h"
#include "parrot/method_util.h"

pmclass Sub {

    void init () {
	PMC_sub(SELF) = new_sub(INTERP, sizeof(struct Parrot_Sub));
	SELF->cache.struct_val = NULL;
	PObj_custom_mark_destroy_SETALL(SELF);
	PObj_get_FLAGS(SELF) &= ~PObj_private1_FLAG;
	if (Interp_flags_TEST(interpreter, PARROT_DEBUG_FLAG))
	    printf("Address of base segment is %p\n",
		    ((struct Parrot_Sub *)
		     PMC_sub(SELF))->seg->base.pf->byte_code);
    }

    void destroy () {
	struct Parrot_Sub * sub = (struct Parrot_Sub *)PMC_sub(SELF);
	mem_sys_free(sub);
    }

    void mark () {
	struct Parrot_Sub * sub = (struct Parrot_Sub *)PMC_sub(SELF);
	pobject_lives(INTERP, sub->ctx.warns);
    }

    void set_pointer (void* value) {
	PObj_get_FLAGS(SELF) |= PObj_private1_FLAG;
	SELF->cache.struct_val = value;
    }

    void* get_pointer () {
	return SELF->cache.struct_val;
    }

    /* This just unconditionally returns the start of bytecode. It's
       wrong, wrong, wrong, *WRONG*. And there's no other good way, so
       it's here for now. -DRS */
    INTVAL get_integer_keyed (PMC* key) {
	return (INTVAL)(((struct Parrot_Sub *)PMC_sub(SELF))->seg->base.pf->byte_code);
    }

    INTVAL defined () {
	return SELF->cache.struct_val != NULL;
    }

    void* invoke (void* next) {
	struct Parrot_Sub * sub = (struct Parrot_Sub *)PMC_sub(SELF);
	interpreter->ctx.warns = sub->ctx.warns;
	if (interpreter->code->cur_cs != sub->seg) {
	    Parrot_switch_to_cs(interpreter, sub->seg);
	}
	return SELF->cache.struct_val;
    }

    PMC* clone () {
	struct Parrot_Sub * sub;
	PMC* ret = pmc_new_noinit(INTERP, SELF->vtable->base_type);
	PObj_custom_mark_destroy_SETALL(ret);
	sub = PMC_sub(ret) = mem_sys_allocate(sizeof(struct Parrot_Sub));
	memcpy(sub, PMC_sub(SELF), sizeof(struct Parrot_Sub));
	buffer_mark_COW(sub->ctx.warns);
	ret->cache.struct_val = SELF->cache.struct_val;
	return ret;
    }

    void set_same (PMC* value) {
	SELF->cache.struct_val = value->cache.struct_val;

    }

    INTVAL is_equal (PMC* value) {
	return SELF->vtable == value->vtable &&
	    SELF->cache.struct_val == value->cache.struct_val;
    }

    void freeze(visit_info *info) {
	IMAGE_IO *io = info->image_io;
	struct Parrot_Sub * sub = (struct Parrot_Sub *)PMC_sub(SELF);
	size_t start_offs, end_offs;

	SUPER(info);
	/*
	 * we currently need to write 3 items
	 * - name of the sub's label: in properties
	 * - start offset in byte-code segment
	 * - end   offset in byte-code segment
	 * - segment TODO
	 */

	/*
	 * if sub addresses are absolute, the flag is set
	 */
	if (PObj_get_FLAGS(SELF) & PObj_private1_FLAG) {
	    ptrdiff_t code = (ptrdiff_t) sub->seg->base.data;

	    start_offs = ((ptrdiff_t) SELF->cache.struct_val - code) /
		sizeof(opcode_t*);
	    end_offs = ((ptrdiff_t)sub->end - code) /
		sizeof(opcode_t*);
	}
	else {
	    start_offs = (size_t)SELF->cache.struct_val;
	    end_offs =   (size_t)sub->end;
	}
	io->vtable->push_integer(INTERP, io, (INTVAL) start_offs);
	io->vtable->push_integer(INTERP, io, (INTVAL) end_offs);
    }

    void thaw(visit_info *info) {
	IMAGE_IO *io = info->image_io;
	SUPER(info);

	if (info->extra_flags == EXTRA_IS_NULL) {
	    struct Parrot_Sub * sub = (struct Parrot_Sub *)PMC_sub(SELF);
	    size_t start_offs, end_offs;
	    /*
	     * we get relative offsets
	     */
	    PObj_get_FLAGS(SELF) &= ~PObj_private1_FLAG;
	    start_offs = (size_t) io->vtable->shift_integer(INTERP, io);
	    end_offs   = (size_t) io->vtable->shift_integer(INTERP, io);
	    SELF->cache.struct_val = (opcode_t*) start_offs;
	    sub->end = (opcode_t*) end_offs;
	}
    }

    void thawfinish(visit_info *info) {
	/*
	 * for now do fixup here until packfile issues are sorted out
	 */
	opcode_t *code;
	struct Parrot_Sub * sub = (struct Parrot_Sub *)PMC_sub(SELF);
	opcode_t *start_offs, *end_offs;

	/* its absolute */
	if (PObj_get_FLAGS(SELF) & PObj_private1_FLAG)
	    return;
	/*
	 * XXX actually the sub might be in a different code segment
	 */
	code = INTERP->code->cur_cs->base.data;
	start_offs = code + (size_t) SELF->cache.struct_val;
	end_offs =   code + (size_t) sub->end;
	SELF->cache.struct_val = start_offs;
	sub->end = end_offs;
	PObj_get_FLAGS(SELF) |= PObj_private1_FLAG;
    }

}
