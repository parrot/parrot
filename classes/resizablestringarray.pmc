/*
Copyright: 2001-2005 The Perl Foundation.  All Rights Reserved.
$Id$

=head1 NAME

classes/resizablestringarray.pmc - resizable array for strings only

=head1 DESCRIPTION

ResizableStringArray implements a resizeable array which stores Parrot
strings only. Any ints or floats assigned to elements of the array will
first be converted to String PMCs and then to native Parrot strings.
PMCs assigned to to elements of the array will be stringified by having
their C<get_string> method called.

=head2 Functions

=over 4

=cut

*/

#include "parrot/parrot.h"

pmclass ResizableStringArray extends FixedStringArray need_ext does array {

/*

=item C<STRING *get_string_keyed_int(INTVAL key)>

Returns the Parrot string value of the element at index C<key>.

=cut

*/

    STRING* get_string_keyed_int (INTVAL key) {
        STRING **data;
        if (key < 0)
            internal_exception(OUT_OF_BOUNDS,
                "ResizableStringArray: index out of bounds!");
        if(key >= PMC_int_val(SELF))
            DYNSELF.set_integer_native(key+1);

        data = (STRING**)PMC_data(SELF);
        return data[key];
    }

/*

=item C<void set_string_keyed_int(INTVAL key, STRING *value)>

Sets the Parrot string value of the element at index C<key> to C<value>.

=cut

*/

    void set_string_keyed_int (INTVAL key, STRING* value) {
        STRING **data;
        if (key < 0)
            internal_exception(OUT_OF_BOUNDS,
                "ResizableStringArray: index out of bounds!");
        if(key >= PMC_int_val(SELF))
            DYNSELF.set_integer_native(key+1);

        data = (STRING**)PMC_data(SELF);
        DOD_WRITE_BARRIER(INTERP, SELF, data[key], value);
        data[key] = value;
    }

/*

=item C<void push_string (STRING* value)>

Extends the array by adding an element of value C<*value> to the end of
the array.

=cut

*/

    void push_string (STRING* value) {
        INTVAL nextix = DYNSELF.elements();
        DYNSELF.set_string_keyed_int(nextix, value);
    }

/*

=item C<STRING* pop_string()>

Removes and returns the last element in the array.

=cut

*/

    STRING* pop_string() {
        INTVAL size;
        STRING* value;

        size = PMC_int_val(SELF);
        if (size == 0) {
            internal_exception(OUT_OF_BOUNDS,
                    "ResizableStringArray: Can't pop from an empty array!");
        }
        value = DYNSELF.get_string_keyed_int(size-1);
        DYNSELF.set_integer_native(size - 1);
        return value;
    }

/*

=item C<void set_integer_native(INTVAL size)>

Resizes the array to C<size> elements.

=cut

*/

    void set_integer_native (INTVAL size) {
        if (size < 0)
            internal_exception(OUT_OF_BOUNDS,
                    "ResizableStringArray: Can't resize!");

        if(!PMC_data(SELF)) {
            /* empty - used fixed routine */
            if (size < 8) {
                SUPER(8);
                PMC_int_val(SELF) = size;
                PMC_int_val2(SELF) = 8;
            }
            else {
                SUPER(size);
                PMC_int_val2(SELF) = size;
            }
        }
        else if (size <= PMC_int_val2(SELF)) {
            PMC_int_val(SELF) = size;
            /* we could shrink here if necessary */
            return;
        }
        else {
            INTVAL i, cur, needed;
            i = cur = PMC_int_val2(SELF);
            if (cur < 8192)
                cur = size < 2 * cur ? 2 * cur : size;
            else {
                needed = size - cur;
                cur += needed + 4096;
                cur &= ~0xfff;
            }
            PMC_data(SELF) = mem_sys_realloc(PMC_data(SELF),
                    cur * sizeof(STRING*));
            for (; i < cur; i++)
                ((STRING**)PMC_data(SELF))[i] = NULL;
            PMC_int_val2(SELF) = cur;
            PMC_int_val(SELF) = size;
        }
    }

/*

=item C<PMC *clone()>

Creates and returns a copy of the array.

=cut

*/

    PMC* clone () {
        PMC *copy = SUPER();
        /* copy trimmed extra space */
        PMC_int_val2(copy) = PMC_int_val(SELF);
        return copy;
    }

}

/*

=back

=head1 SEE ALSO

F<docs/pdds/pdd17_basic_types.pod>.

=head1 HISTORY

Initial version                  - Matt Fowles 2004-06-11
Changed allocator to double size - Matt Fowles 2004-06-15
Added push_string                - Bernhard Schmalhofer 2004-10-17
moved available size to int_val2 - Matt Fowles 2005-07-22

=cut

*/

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
 * vim: expandtab shiftwidth=4:
*/
