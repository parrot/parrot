/*
Copyright: 2003 The Perl Foundation.  All Rights Reserved.
$Id$

=head1 NAME

classes/delegate.pmc - Delegate PMC

=head1 DESCRIPTION

Delegate each and every function to parrot bytecode.

Almost all methods are auto-generated in lib/Parrot/Pmc2c.pm

=head2 Register Save/Restore Functions

The following bit is a fast register save/restore pair. They currently
count on the registers in the interpreter structure being in the same
order as in the C<regsave struct>, and that the registers are at the
beginning of the interpreter structure.

Yes, it's damned evil, but it's what we need, since we have to preserve
the registers -- vtable methods can't change them.

Also note that if the vtable method clobbers a register that contains a
string or PMC not otherwise rooted it could be collected too early.

=head2 Functions

=over 4

=cut

*/


#include "parrot/parrot.h"
#include <assert.h>

typedef struct _reg_store {
    struct IReg int_reg;
    struct NReg num_reg;
    struct SReg string_reg;
    struct PReg pmc_reg;
} reg_store;

/*

=item C<PARROT_INLINE static struct regsave *
save_regs(Parrot_Interp interp)>

Saves the registers to the C<regsave struct>.

=cut

*/

typedef struct regsave {
    struct regsave *prev;       /* free list ptr */
    struct regsave *next;       /* mark list ptr */
    reg_store      regs;
} regsave;

/*
 * TODO move this into interpreter
 */

static regsave *reg_save_top;   /* the free list */
static regsave *reg_save_mark;  /* the mark list */

PARROT_INLINE static struct regsave *
save_regs(Parrot_Interp interp) {
    struct regsave *save;
    if (reg_save_top) {
        save = reg_save_top;
        reg_save_top = save->prev;
    }
    else {
        save = mem_sys_allocate(sizeof(struct regsave));
        save->prev = NULL;
    }
    save->next = reg_save_mark;
    reg_save_mark = save;
    mem_sys_memcopy(&save->regs, interp, sizeof(reg_store));
    return save;
}

/*

=item C<PARROT_INLINE static void
restore_regs(Parrot_Interp interp, struct regsave *data)>

Restores the registers from C<*data>.

=cut

*/

PARROT_INLINE static void
restore_regs(Parrot_Interp interpreter, struct regsave *data) {

    mem_sys_memcopy(interpreter, &data->regs, sizeof(reg_store));
    data->prev = reg_save_top;
    reg_save_top = data;
    assert(reg_save_mark == data);
    reg_save_mark = data->next;

    if (Interp_flags_TEST(interpreter, PARROT_TRACE_FLAG)) {
        PIO_eprintf(interpreter, "# return\n");
    }
}


static void
mark_regs(Parrot_Interp interpreter)
{
    struct regsave *p = reg_save_mark;
    int j;
    PObj *reg;

    for (; p; p = p->next) {
        struct PReg *pf = &p->regs.pmc_reg;
        struct SReg *sf = &p->regs.string_reg;
        for (j = 0; j < NUM_REGISTERS; j++) {
            reg = (PObj*) pf->registers[j];
            if (reg)
                pobject_lives(interpreter, reg);
            reg = (PObj*) sf->registers[j];
            if (reg)
                pobject_lives(interpreter, reg);
        }
    }
}
/*

=item C<PARROT_INLINE static PMC *
find_meth(Parrot_Interp interpreter, PMC *pmc, const char *name)>

Finds and returns the delegated method with C string C<name>.

=cut

*/


PARROT_INLINE static PMC *
find_meth(Parrot_Interp interpreter, PMC *pmc, const char *name) {
    STRING *meth = const_string(interpreter, name);
    PMC *class = pmc;

    if (Interp_flags_TEST(interpreter, PARROT_TRACE_FLAG)) {
        PIO_eprintf(interpreter, "# Calling meth '%s'\n#",
                name);
        print_pbc_location(interpreter);
    }
    if (PObj_is_object_TEST(pmc)) {
        class = GET_CLASS((Buffer *)PMC_data(pmc), pmc);
    }
    REG_STR(2) = meth;
    return Parrot_find_method_with_cache(interpreter, class, meth);
}

/*

=item C<PARROT_INLINE static PMC *
find_or_die(Parrot_Interp interpreter, PMC *pmc, const char *name)>

Returns the result of calling C<find_meth()> with the arguments, raising
an exception if no method is found.

=cut

*/

PARROT_INLINE static PMC *
find_or_die(Parrot_Interp interpreter, PMC *pmc, const char *name) {
    PMC *returnPMC = find_meth(interpreter, pmc, name);
    if (PMC_IS_NULL(returnPMC)) {
        internal_exception(METH_NOT_FOUND,
            "Can't find method '%s' for object", name);
    }
    REG_PMC(2) = pmc;
    return returnPMC;
}

/*

=back

All these functions to run code can leak a full parrot register file, as
well as potentially permanently unroot some PMCs or strings, if the
vtable method throws an exception. It really ought be caught rather than
let flow through.

=over 4

=item C<PARROT_INLINE static void
noarg_noreturn(Parrot_Interp interpreter, PMC *obj, const char *meth, int die)>

Calls the delegated method with no arguments or return value. If C<die>
is true then an exception will be raised if the method is not found.

=cut

*/

PARROT_INLINE static void
noarg_noreturn(Parrot_Interp interpreter, PMC *obj, PMC* class,
        const char *meth, int die) {
    struct regsave *data = save_regs(interpreter);
    PMC *method = die ? find_or_die(interpreter, class, meth) :
        find_meth  (interpreter, class, meth);
    if (PMC_IS_NULL(method)) {
        if (Interp_flags_TEST(interpreter, PARROT_TRACE_FLAG)) {
            PIO_eprintf(interpreter, "# not found\n");
        }
        goto ret;
    }
    REG_PMC(2) = obj;
    REG_INT(0) = 1; /* prototyped */
    REG_INT(1) = 0;
    REG_INT(2) = 0;
    REG_INT(3) = 0;
    REG_INT(4) = 0;
    Parrot_runops_fromc(interpreter, method);
ret:
    restore_regs(interpreter, data);
}

pmclass delegate {

/*

=back

=head2 Methods

=over 4

=item C<void init()>

Calls the delegated C<init()> method.

=cut

*/

    void init () {
        noarg_noreturn(INTERP, SELF, SELF, PARROT_VTABLE_INIT_METHNAME, 0);
    }

    void init_pmc (PMC* class) {
        noarg_noreturn(INTERP, SELF, class, PARROT_VTABLE_INIT_METHNAME, 0);
    }

    void mark() {
        mark_regs(INTERP);
    }
}

/*

=back

=cut

*/

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
 * vim: expandtab shiftwidth=4:
*/
