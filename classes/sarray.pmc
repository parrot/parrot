/* sarray.pmc
 *  Copyright: 2001-2003 The Perl Foundation.  All Rights Reserved.
 *  CVS Info
 *     $Id$
 *  Overview:
 *     These are the vtable functions for the SArray base class
 *  Data Structure and Algorithms:
 *     SArray data are kept in an malloced array of HashEntry's
 *     entry 0 = start_idx (for shift)
 *     entry 1 = end_idx   (for push)
 *     entry 2... data
 *  History:
 *     Initial version 2003.07.04 by leo
 *     2003.11.06 boemmels renamed HASH_ENTRY to HashEntry
 *  Notes:
 *     This is the Simple (or Static) Array class for parameter
 *     passing according to pdd03.
 *     - SArrays are fixed size, implying:
 *     - The first operation on it must be setting its size.
 *     - only the most important vtable meths are implemented
 *  References:
 *     docs/pdds/pdd03_calling_conventions.pod
 */

#include "parrot/parrot.h"

static PARROT_INLINE INTVAL
ret_int(Parrot_Interp interpreter, HashEntry *e)
{
    switch (e->type) {
	case enum_hash_int:
	    return e->val.int_val;
	case enum_hash_pmc:
	    return VTABLE_get_integer(interpreter, e->val.pmc_val);
	default:
	    break;
    }
    internal_exception(OUT_OF_BOUNDS, "SArray: Entry not an integer!\n");
    return 0;
}

static PARROT_INLINE FLOATVAL
ret_num(Parrot_Interp interpreter, HashEntry *e)
{
    switch (e->type) {
	case enum_hash_num:
	    return e->val.num_val;
	case enum_hash_pmc:
	    return VTABLE_get_number(interpreter, e->val.pmc_val);
	default:
	    break;
    }
    internal_exception(OUT_OF_BOUNDS, "SArray: Entry not a number!\n");
    return 0;
}

static PARROT_INLINE STRING*
ret_string(Parrot_Interp interpreter, HashEntry *e)
{
    switch (e->type) {
	case enum_hash_string:
	    return e->val.string_val;
	case enum_hash_pmc:
	    return VTABLE_get_string(interpreter, e->val.pmc_val);
	default:
	    break;
    }
    internal_exception(OUT_OF_BOUNDS, "SArray: Entry not a string!\n");
    return 0;
}

static PARROT_INLINE PMC*
ret_pmc(Parrot_Interp interpreter, HashEntry *e)
{
    PMC *ret;
    switch (e->type) {
	case enum_hash_int:
	    ret = pmc_new(interpreter, enum_class_PerlUndef);
	    VTABLE_set_integer_native(interpreter, ret, e->val.int_val);
	    return ret;
	case enum_hash_num:
	    ret = pmc_new(interpreter, enum_class_PerlUndef);
	    VTABLE_set_number_native(interpreter, ret, e->val.num_val);
	    return ret;
	case enum_hash_string:
	    ret = pmc_new(interpreter, enum_class_PerlUndef);
	    VTABLE_set_string_native(interpreter, ret, e->val.string_val);
	    return ret;
	case enum_hash_pmc:
	    return e->val.pmc_val;
	default:
	    internal_exception(OUT_OF_BOUNDS, "SArray: Unknown entry!\n");
    }
    return NULL;
}

static PARROT_INLINE HashEntry*
shift_entry(PMC *self)
{
    HashEntry *e = (HashEntry *) PMC_data(self);
    HashEntry *ret;
    INTVAL start_index = e[0].val.int_val;
    INTVAL end_index   = e[1].val.int_val;

    if (start_index >= end_index)
	internal_exception(OUT_OF_BOUNDS, "SArray index out of bounds!\n");

    ret = (HashEntry *) PMC_data(self) + (2 + start_index++);

    /* Update the starting index */
    e[0].val.int_val = start_index;
    return ret;
}

static PARROT_INLINE HashEntry*
get_entry(PMC *self, INTVAL key)
{
    HashEntry *e = (HashEntry *) PMC_data(self);
    INTVAL start_index = e[0].val.int_val;
    INTVAL end_index   = e[1].val.int_val;

    if (key < 0) {
	key += end_index;
    }
    key += start_index;   /* lower bound if already shifted */
    if (key < start_index || key >= end_index)
	internal_exception(OUT_OF_BOUNDS, "SArray index out of bounds!\n");
    e = (HashEntry *) PMC_data(self) + (2 + key);
    return e;
}

pmclass SArray const_too need_ext does array {
    void init () {
	PMC_int_val(SELF) = 0;
        PMC_data(SELF) = NULL;
    }

    void morph(INTVAL type) { /* Const classes must have a morph */
	SUPER(type);
    }

    void mark () {
	HashEntry *e;
	int i, start, end;
	if (!PMC_data(SELF))
	    return;
	e = (HashEntry *) PMC_data(SELF);
	start = e[0].val.int_val;
	end = e[1].val.int_val;
	e = (HashEntry *) PMC_data(SELF) + (2 + start);
	for (i = start; i < end; i++, e++) {
	    switch (e->type) {
		case enum_hash_string:
		    if (e->val.string_val)
			pobject_lives(INTERP, (PObj *)e->val.string_val);
		    break;
		case enum_hash_pmc:
		    if (e->val.pmc_val)
			pobject_lives(INTERP, (PObj *)e->val.pmc_val);
		    break;
		default:
		    break;
	    }
	}
    }

    void destroy () {
        if (PMC_data(SELF))
            mem_sys_free(PMC_data(SELF));
	PMC_data(SELF) = NULL;
    }

    PMC* clone () {
	HashEntry *e, *d;
	int i, start, end;
	INTVAL size;
	PMC * dest = pmc_new(INTERP, SELF->vtable->base_type);

	if (!PMC_data(SELF))
	    return dest;
	size = PMC_int_val(SELF);
	PMC_int_val(dest) = size;
	PMC_data(dest) = mem_sys_allocate_zeroed((2 + size) *
		sizeof(HashEntry));
	e = (HashEntry *) PMC_data(SELF);
	d = (HashEntry *) PMC_data(dest);
	start = e[0].val.int_val;
	end = e[1].val.int_val;
	d[0].val.int_val = start;
	d[1].val.int_val = end;
	e = (HashEntry *) PMC_data(SELF) + (2 + start);
	d = (HashEntry *) PMC_data(dest) + (2 + start);
	for (i = start; i < end; i++, e++, d++) {
	    d->type = e->type;
	    switch (e->type) {
		case enum_hash_int:
		    d->val.int_val = e->val.int_val;
		    break;
		case enum_hash_num:
		    d->val.num_val = e->val.num_val;
		    break;
		case enum_hash_string:
		    d->val.string_val = string_copy(INTERP, e->val.string_val);
		    break;
		case enum_hash_pmc:
		    d->val.pmc_val = VTABLE_clone(INTERP, e->val.pmc_val);
		    break;
		default:
		    break;
	    }
	}
	PObj_custom_mark_destroy_SETALL(dest);
	return dest;
    }

    INTVAL get_bool () {
        INTVAL size = DYNSELF.elements();
        return (INTVAL)(size != 0);
    }

    INTVAL elements () {
	HashEntry *e;
	if (!PMC_data(SELF))
	    return 0;
	e = (HashEntry *) PMC_data(SELF);
        return e[1].val.int_val - e[0].val.int_val;
    }

    INTVAL get_integer () {
        return DYNSELF.elements();
    }

    INTVAL type_keyed_int (INTVAL key) {
        HashEntry *e = get_entry(SELF, key);
	return e->type;
    }

    INTVAL get_integer_keyed_int (INTVAL key) {
        HashEntry *e = get_entry(SELF, key);
	return ret_int(INTERP, e);
    }

    INTVAL get_integer_keyed (PMC* key) {
	/* simple int keys only */
	INTVAL k = key_integer(INTERP, key);
	return SELF.get_integer_keyed_int(k);
    }

    INTVAL shift_integer() {
        HashEntry *ret = shift_entry(SELF);
	return ret_int(INTERP, ret);
    }

    FLOATVAL get_number_keyed_int (INTVAL key) {
        HashEntry *e = get_entry(SELF, key);
	return ret_num(INTERP, e);
    }

    FLOATVAL get_number_keyed (PMC* key) {
	INTVAL k = key_integer(INTERP, key);
	return SELF.get_number_keyed_int(k);
    }

    FLOATVAL shift_float() {
        HashEntry *ret = shift_entry(SELF);
	return ret_num(INTERP, ret);
    }

    STRING* get_string_keyed_int (INTVAL key) {
        HashEntry *e = get_entry(SELF, key);
	return ret_string(INTERP, e);
    }

    STRING* get_string_keyed(PMC* key) {
	INTVAL k = key_integer(INTERP, key);
	return SELF.get_string_keyed_int(k);
    }

    STRING* shift_string() {
        HashEntry *ret = shift_entry(SELF);
	return ret_string(INTERP, ret);
    }

    PMC* get_pmc_keyed_int (INTVAL key) {
        HashEntry *e = get_entry(SELF, key);
	return ret_pmc(INTERP, e);
    }

    PMC* get_pmc_keyed(PMC* key) {
	INTVAL k = key_integer(INTERP, key);
	return SELF.get_pmc_keyed_int(k);
    }

    PMC* shift_pmc() {
        HashEntry *ret = shift_entry(SELF);
	return ret_pmc(INTERP, ret);
    }

    void set_integer_native (INTVAL size) {
	if (PMC_int_val(SELF))
	    internal_exception(OUT_OF_BOUNDS, "SArray: Can't resize!\n");
	PMC_int_val(SELF) = size;
	PMC_data(SELF) = mem_sys_allocate_zeroed((2 + size) *
		sizeof(HashEntry));
	PObj_custom_mark_destroy_SETALL(SELF);
    }

    void set_integer_keyed_int (INTVAL key, INTVAL value) {
        HashEntry *e;
	if (key < 0 || key >= PMC_int_val(SELF))
	    internal_exception(OUT_OF_BOUNDS, "SArray index out of bounds!\n");
	e = (HashEntry *) PMC_data(SELF) + (2 + key);
	e->type = enum_hash_int;
	e->val.int_val = value;
	e = (HashEntry *) PMC_data(SELF) + 1;
	if (key >= e->val.int_val)
	    e->val.int_val = key + 1;
    }

    void push_integer (INTVAL value) {
	HashEntry *e;
	INTVAL nextix;
	if (!PMC_data(SELF))
	    internal_exception(OUT_OF_BOUNDS, "SArray index out of bounds!\n");
	e = (HashEntry *) PMC_data(SELF) + 1;
	nextix = e->val.int_val;
	DYNSELF.set_integer_keyed_int(nextix, value);
    }

    void set_number_keyed_int (INTVAL key, FLOATVAL value) {
        HashEntry *e;
	if (key < 0 || key >= PMC_int_val(SELF))
	    internal_exception(OUT_OF_BOUNDS, "SArray index out of bounds!\n");
	e = (HashEntry *) PMC_data(SELF) + (2 + key);
	e->type = enum_hash_num;
	e->val.num_val = value;
	e = (HashEntry *) PMC_data(SELF) + 1;
	if (key >= e->val.int_val)
	    e->val.int_val = key + 1;
    }

    void push_float (FLOATVAL value) {
        HashEntry *e;
	INTVAL nextix;
	if (!PMC_data(SELF))
	    internal_exception(OUT_OF_BOUNDS, "SArray index out of bounds!\n");
	e = (HashEntry *) PMC_data(SELF) + 1;
	nextix = e->val.int_val;
        DYNSELF.set_number_keyed_int(nextix, value);
    }

    void set_string_keyed_int (INTVAL key, STRING* value) {
        HashEntry *e;
	if (key < 0 || key >= PMC_int_val(SELF))
	    internal_exception(OUT_OF_BOUNDS, "SArray index out of bounds!\n");
	e = (HashEntry *) PMC_data(SELF) + (2 + key);
	e->type = enum_hash_string;
	e->val.string_val = value;
	e = (HashEntry *) PMC_data(SELF) + 1;
	if (key >= e->val.int_val)
	    e->val.int_val = key + 1;
    }

    void push_string (STRING* value) {
        HashEntry *e;
	INTVAL nextix;
	if (!PMC_data(SELF))
	    internal_exception(OUT_OF_BOUNDS, "SArray index out of bounds!\n");
	e = (HashEntry *) PMC_data(SELF) + 1;
	nextix = e->val.int_val;
        DYNSELF.set_string_keyed_int(nextix, value);
    }

    void set_pmc_keyed_int (INTVAL key, PMC* src) {
        HashEntry *e;
	if (key < 0 || key >= PMC_int_val(SELF))
	    internal_exception(OUT_OF_BOUNDS, "SArray index out of bounds!\n");
	e = (HashEntry *) PMC_data(SELF) + (2 + key);
	e->type = enum_hash_pmc;
	e->val.pmc_val = src;
	e = (HashEntry *) PMC_data(SELF) + 1;
	if (key >= e->val.int_val)
	    e->val.int_val = key + 1;
    }

    void push_pmc (PMC* value) {

        HashEntry *e;
	INTVAL nextix;
	if (!PMC_data(SELF))
	    internal_exception(OUT_OF_BOUNDS, "SArray index out of bounds!\n");
	e = (HashEntry *) PMC_data(SELF) + 1;
	nextix = e->val.int_val;
        DYNSELF.set_pmc_keyed_int(nextix, value);
    }

    PMC* nextkey_keyed (PMC* key, INTVAL what) {
	PMC *ret = key;
        HashEntry *e;
	INTVAL n = SELF.elements();
        INTVAL start_index, end_index;

	PObj_get_FLAGS(ret) &= ~KEY_type_FLAGS;
	PObj_get_FLAGS(ret) |= KEY_integer_FLAG;
	if (!n) {
	    PMC_int_val(ret) = -1;
	    return ret;
	}
	e = (HashEntry *) PMC_data(SELF);
        start_index = e[0].val.int_val;
        end_index   = e[1].val.int_val;

	switch (what) {
	    case ITERATE_FROM_START:	/* reset key, iterate from start */
		PMC_int_val(ret) = start_index;
		break;
	    case ITERATE_GET_NEXT:
		if (PMC_int_val(ret) < end_index - 1)
		    ++PMC_int_val(ret);
		else
		    PMC_int_val(ret) = -1;
		break;
	    case ITERATE_GET_PREV:
		if (PMC_int_val(ret) >= start_index)
		    --PMC_int_val(ret);
		else
		    PMC_int_val(ret) = -1;
		break;
	    case ITERATE_FROM_END:
		PMC_int_val(ret) = end_index - 1;
		break;
	}
	return ret;
    }
}

