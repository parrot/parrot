/*
Copyright: 2001-2003 The Perl Foundation.  All Rights Reserved.
$Id$

=head1 NAME

classes/coroutine.pmc - Co-Routine PMC

=head1 DESCRIPTION

C<Coroutine> extends C<Continuation> to provide a subroutine that can
stop in the middle, and start back up later at the point at which it
stopped. See the L<Glossary|docs/glossary.pod> for more information.

=head2 Flags

=over 4

=item private0 call flip flop

=item private3 restore current sub after "flop".  Used by generators.

=back

=head2 Methods

=over 4

=cut

*/

#include "parrot/parrot.h"
#include "parrot/method_util.h"
#include "parrot/oplib/ops.h"
#include <assert.h>

/*
 * XXX put these into exceptions.h
 */


#define TRY \
    do { \
        new_internal_exception(INTERP); \
        if (!setjmp(INTERP->exceptions->destination))

#define CATCH \
    else

#define ENDTRY \
    } while(0); \
    do { \
        Parrot_exception *e = INTERP->exceptions; \
        INTERP->exceptions = e->prev; \
        INTERP->exc_free_list = e; \
    } while(0)


#define THROW(e)  \
    do { \
	exceptions->err = e; \
	longjmp(exceptions->dest, 1); \
    } while(0)

pmclass Coroutine extends Sub need_ext {

/*

=item C<void init()>

Initializes the co-routine.

=item C<PMC* clone()>

Clone the couroutine.

=cut

*/

    void init () {
        PMC_coro_ASSIGN(SELF, new_coroutine(INTERP));
        PMC_pmc_val(SELF) = NULL;
        PObj_custom_mark_destroy_SETALL(SELF);
    }

    PMC* clone () {
        struct Parrot_coro * sub;
        PMC* ret = pmc_new_noinit(INTERP, SELF->vtable->base_type);
        PObj_custom_mark_destroy_SETALL(ret);
        sub = mem_sys_allocate(sizeof(struct Parrot_coro));
        memcpy(sub, PMC_sub(SELF), sizeof(struct Parrot_coro));
        sub->name = string_copy(INTERP, sub->name);
        PMC_coro_ASSIGN(ret, sub);
        PMC_pmc_val(ret) = NULL;
        return ret;
    }

/*

=item C<void *invoke(void *next)>

Swaps the "context".

=cut

*/

    void* invoke (void* next) {
        struct Parrot_coro * co = PMC_coro(SELF);
        parrot_context_t *caller_ctx;
        struct PackFile_ByteCode *wanted_seg;
        opcode_t * dest = co->address;
        parrot_context_t *ctx;
        PMC *ccont;

        if (!co->ctx) {
            PMC *pad;

            /* TODO factor out common code with Sub.invoke
             *      and inherit it
             */
            ccont = INTERP->current_cont;
            if (ccont == NEED_CONTINUATION) {
                ccont = new_ret_continuation_pmc(interpreter, next);
            }
            if (PObj_get_FLAGS(ccont) & SUB_FLAG_TAILCALL) {
                internal_exception(1, "tail call to coro not allowed");
            }
            caller_ctx = CONTEXT(INTERP->ctx);
            /*
             * first time set current sub, cont, object
             */
            Parrot_alloc_context(INTERP, co->n_regs_used);
            co->ctx = ctx = CONTEXT(INTERP->ctx);
            ctx->caller_ctx = caller_ctx;
            PMC_cont(ccont)->from_ctx = ctx;
            /*
             * XXX are our coroutines closures?
             */
            pad = scratchpad_get_current(INTERP);
            if (pad) {
                stack_push(INTERP, &ctx->pad_stack, pad,
                        STACK_ENTRY_PMC, STACK_CLEANUP_NULL);
            }
            ctx->current_sub = SELF;
            ctx->current_cont = ccont;
            ctx->current_object = NULL;
            INTERP->current_object = NULL;
            INTERP->current_cont = NULL;

            /* create pad if needed */
            if (!PMC_IS_NULL(co->lex_info)) {
                ctx->lex_pad = pmc_new_init(INTERP,
                        Parrot_get_ctx_HLL_type(interpreter,
                            enum_class_LexPad),
                        co->lex_info);
                VTABLE_set_pointer(INTERP, ctx->lex_pad, ctx);
            }

            PObj_get_FLAGS(SELF) |= SUB_FLAG_CORO_FF;
            wanted_seg = co->seg;
            co->caller_seg = INTERP->code;
        }
        /* if calling the Coro we need the segment of the Coro */
        else if (!(PObj_get_FLAGS(SELF) & SUB_FLAG_CORO_FF)) {
            PObj_get_FLAGS(SELF) |= SUB_FLAG_CORO_FF;
            wanted_seg = co->seg;
            /* remember segment of caller */
            co->caller_seg = INTERP->code;
            /* and the recent call context */
            ccont = co->ctx->current_cont;
            PMC_cont(ccont)->to_ctx = CONTEXT(INTERP->ctx);
            /* set context to coro context */
            CONTEXT(INTERP->ctx) = ctx = co->ctx;
            INTERP->ctx.bp = ctx->bp;
            INTERP->ctx.bp_ps = ctx->bp_ps;
        }
        else {
            PObj_get_FLAGS(SELF) &= ~SUB_FLAG_CORO_FF;
            /* switch back to last remembered code seg and context */
            wanted_seg = co->caller_seg;
            ccont = co->ctx->current_cont;
            CONTEXT(INTERP->ctx) = ctx = PMC_cont(ccont)->to_ctx;
            INTERP->ctx.bp = ctx->bp;
            INTERP->ctx.bp_ps = ctx->bp_ps;
            if (INTERP->current_returns && ctx->current_results)
                parrot_pass_args(INTERP,
                        co->ctx,
                        ctx,
                        PARROT_OP_get_results_pc);
        }

        /* toggle address */
        co->address = next;
        if (INTERP->code != wanted_seg) {
            Parrot_switch_to_cs(INTERP, wanted_seg, 1);
        }
        return dest;
    }

/*

=item C<void mark()>

Marks the coroutine as live.

=cut

*/

    void mark () {
        struct Parrot_coro *c = PMC_coro(SELF);
        if (c && c->ctx)
            mark_context(INTERP, c->ctx);
        SUPER();
    }
}

/*

=back

=head1 HISTORY

Initial version by Melvin on 2002/06/6.

=cut

*/

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
 * vim: expandtab shiftwidth=4:
*/
