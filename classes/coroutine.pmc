/*
Copyright: 2001-2003 The Perl Foundation.  All Rights Reserved.
$Id$

=head1 NAME

classes/coroutine.pmc - Co-Routine PMC

=head1 DESCRIPTION

C<Coroutine> extends C<Continuation> to provide a subroutine that can
stop in the middle, and start back up later at the point at which it
stopped. See the L<Glossary|docs/glossary.pod> for more information.

=head2 Flags

=over 4

=item private0 call flip flop

=item private3 called first time, used for python

=back

=head2 Methods

=over 4

=cut

*/

#include "parrot/parrot.h"
#include "parrot/method_util.h"
#include <assert.h>

/*
 * XXX put these into exceptions.h
 */


#define TRY \
    do { \
        new_internal_exception(interpreter); \
        if (!setjmp(interpreter->exceptions->destination))

#define CATCH \
    else

#define ENDTRY \
    } while(0); \
    do { \
        Parrot_exception *e = interpreter->exceptions; \
        interpreter->exceptions = e->prev; \
        interpreter->exc_free_list = e; \
    } while(0)


#define THROW(e)  \
    do { \
	exceptions->err = e; \
	longjmp(exceptions->dest, 1); \
    } while(0)

pmclass Coroutine extends Sub {

    void class_init() {
        if (pass) {
            enter_nci_method(INTERP, enum_class_Coroutine,
                    F2DPTR(Parrot_Coroutine_shift_pmc), "next", "PIO");
        }
    }

    /*

       =item C<void init()>

       Initializes the co-routine.

       =cut

*/

    void init () {
        PMC_coro(SELF) = new_coroutine(INTERP);
        PMC_struct_val(SELF) = NULL;
        PObj_custom_mark_destroy_SETALL(SELF);

        if (Interp_flags_TEST(INTERP, PARROT_PYTHON_MODE))
            PObj_get_FLAGS(SELF) |= PObj_private3_FLAG;
    }

    /*

       =item C<void *invoke(void *next)>

       Swaps the "context".

       =cut

*/

    void* invoke (void* next) {
        struct Parrot_coro * sub = PMC_coro(SELF);
        struct PackFile_ByteCode *wanted_seg;
        void * dest = sub->address;
        int argcP = REG_INT(3);
        /* python calls the coroutine initially during
         * setup
         */
        if (PObj_get_FLAGS(SELF) & PObj_private3_FLAG) {
            PMC *ret = SELF.get_iter();
            struct Parrot_coro *cor = PMC_coro(ret);
            struct Stack_Chunk *pad_stack = cor->ctx.pad_stack;
            PMC *pad = stack_peek(INTERP, pad_stack, NULL);
            INTVAL i;

            for (i = 0; i < argcP; ++i) {
                scratchpad_store_by_index(INTERP, pad, -1, i, REG_PMC(5+i));
            }
            REG_PMC(5) = ret;
            cor->caller_seg = interpreter->code->cur_cs;
            return next;
        }
        sub->address = next;
        /* if calling the Coro we need the segment of the Coro */
        if (!(PObj_get_FLAGS(SELF) & PObj_private0_FLAG)) {
            wanted_seg = sub->seg;
            /* remember segment of caller */
            sub->caller_seg = interpreter->code->cur_cs;
        }
        else {
            wanted_seg = sub->caller_seg;
        }
        swap_context(interpreter, SELF);

        if (interpreter->code->cur_cs != wanted_seg) {
            Parrot_switch_to_cs(interpreter, wanted_seg, 1);
        }
        return dest;
    }

    /*

       =item C<PMC* shift_pmc>)

       Run the coroutine until it yields a value. The call to the coroutine
       is actually done via the C<call_hook> below, a piece of code at the
       end of a coroutine:

       set P0, P5    # get the real coroutine
       invokecc      # run that code
       end           # terminate the runloop

       =cut

*/

    PMC* shift_pmc() {
        PMC *res;
        struct Parrot_coro * sub = PMC_coro(SELF);
        void * regs = Parrot_save_register_frames(interpreter, SELF);
        opcode_t offset, *call_hook;
        PMC *ex;
        PMC *p5 = REG_PMC(5);

        REG_PMC(5) = SELF;
        assert(sub->end);
        call_hook = sub->end - 5;
        offset = call_hook - interpreter->code->byte_code;
        /*
         * running via runops creates an exception frame
         *  but we should catch exceptions here to free the register
         *  frame
         */
        runops(interpreter, offset);
        res = REG_PMC(5);
        REG_PMC(5) = p5;
        /*
         * the generator returned None, when it's finished
         */
        if (REG_INT(3) == 1 &&
                res == Parrot_base_vtables[enum_class_None]->data) {
            Parrot_restore_register_frames(interpreter, regs);
            real_exception(interpreter, NULL, E_StopIteration, "StopIteration");
        }
        Parrot_restore_register_frames(interpreter, regs);
        return res;
    }

    /*

       Iterator interface

       =item C<INTVAL elements ()>

       Return much, we don't know.

*/

    INTVAL elements () {
        return (2^31) - 1;
    }

    PMC* get_iter () {
        if (PObj_get_FLAGS(SELF) & PObj_private3_FLAG) {
            struct Parrot_coro * sub = PMC_coro(SELF);
            PMC *ret = pmc_new(INTERP, enum_class_Coroutine);
            struct Parrot_coro * coro = PMC_coro(ret);
            coro->end = sub->end;
            coro->address = sub->address;

            PObj_get_FLAGS(ret) |= PObj_private1_FLAG; /* fixup done */
            PObj_get_FLAGS(ret) &= ~PObj_private3_FLAG;
            PObj_flag_CLEAR(custom_mark, SELF);
            return ret;
        }
        return SELF;
    }

    INTVAL get_bool () {
        return 1;
    }

    /*

       =item C<void mark()>

       Marks the coroutine as live.

       =cut

*/

    void mark () {
        struct Parrot_coro *c = PMC_coro(SELF);
        mark_stack(INTERP, c->co_control_stack);
        mark_stack(INTERP, c->co_control_base);
        /* mark_stack(INTERP, c->co_pad_stack); */
        mark_context(INTERP, &c->ctx);
    }
}

/*

=back

=head1 HISTORY

Initial version by Melvin on 2002/06/6.

=cut

*/

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
 * vim: expandtab shiftwidth=4:
*/
