/* timer.pmc
 *  Copyright: 2001-2003 The Perl Foundation.  All Rights Reserved.
 *  CVS Info
 *     $Id$
 *  Overview:
 *     This is the Timer base class
 *  Data Structure and Algorithms:
 *     Running timers are kept in a linked list. Each timer has a
 *     tick count, which gets decremented if the system timer
 *     expires. If the tick count reaches zero, the timer handler gets
 *     invoked via Parrot's event handling code.
 *  History:
 *     Initial proposal by leo 2003.07.15
 *     Initial revision        2003.07.17
 *     Switch to events        2004.01.07
 *  Synopsis:
 *     new P0, .Timer
 *     set P0[.PARROT_TIMER_SEC], I_seconds        # whole seconds
 *     set P0[.PARROT_TIMER_USEC], I_micro seconds # and/or micro seconds
 *     set P0[.PARROT_TIMER_NSEC], N_seconds_frac  # or fraction in seconds
 *     set P0[.PARROT_TIMER_REPEAT], I_repeat      # 0 = one shot ...
 *     set P0[.PARROT_TIMER_HANDLER], P_sub        # set handler sub PMC
 *     invoke P0                                   # start timer
 *     set P0[.PARROT_TIMER_RUNNING], 1            # same
 *
 *     new P0, .Timer, P1                          # set everything
 *
 *     set I0, P0[.PARROT_TIMER_SEC]               # query current timer status
 *     set N0, P0[.PARROT_TIMER_NSEC]
 *     ...
 *     set P0[.PARROT_TIMER_RUNNING], 0            # turn timer off
 *
 *  Notes:
 *     The Timer resolution is operating system dependent. It's only
 *     guaranteed that the Timer will fire some time after the
 *     programmed interval.
 *     The Timer stops after invoking the handler (repeat+1) times.
 *     To create a Timer that will run forever, set "repeat" to -1.
 *     Turning the Timer off preserves set values; the Timer is
 *     not destroyed.
 *     When setting both PARROT_TIMER_SEC and PARROT_TIMER_USEC it
 *     must be done in that sequence, whole seconds first.
 *     If a timer is constructed with an initializer and it should
 *     be run immediately, the PARROT_TIMER_RUNNING value has to be in the
 *     last key of the initializer.
 *
 *  References:
 */

#include "parrot/parrot.h"
#include "parrot/method_util.h"

/* interface constants */
/* &gen_from_enum(timer.pasm) */
typedef enum {
    PARROT_TIMER_SEC,
    PARROT_TIMER_USEC,
    PARROT_TIMER_NSEC,
    PARROT_TIMER_REPEAT,
    PARROT_TIMER_RUNNING,
    PARROT_TIMER_HANDLER,
    PARROT_TIMER_MAX
} parrot_timer_enum_t;
/* &end_gen */

static void
add_timer(Parrot_Interp interpreter, PMC *pmc)
{
    parrot_timer_event *t = pmc->cache.struct_val;
    if (!PMC_IS_NULL(t->sub))
	Parrot_new_timer_event(interpreter, pmc, t->abs_time,
			t->interval, t->repeat, t->sub);
}

static void
del_timer(Parrot_Interp interpreter, PMC *pmc)
{
   Parrot_del_timer_event(interpreter, pmc);
}


pmclass Timer does event {

    void init() {
	/*
	 * t->abs_time actually is relative, its converted to an
	 * absolute time, when the timer is started
	 */
	parrot_timer_event *t =
	    mem_sys_allocate_zeroed(sizeof(parrot_timer_event));
	SELF->cache.struct_val = t;
	PObj_active_destroy_SET(SELF);
 	++interpreter->num_early_DOD_PMCs;
    }

    void init_pmc(PMC *init) {
	/*
	 * s. pdd02_vtables for intializers
	 */
	INTVAL n = VTABLE_get_integer(interpreter, init);
	INTVAL i;
	INTVAL val;
	FLOATVAL nval;
	PMC *pval;

	SELF.init();
	for (i = 0; i < n; i += 2) {
	    INTVAL key = VTABLE_get_integer_keyed_int(interpreter, init, i);
	    switch (key) {
		case PARROT_TIMER_SEC:
		case PARROT_TIMER_USEC:
		case PARROT_TIMER_REPEAT:
		case PARROT_TIMER_RUNNING:
		    val =
			VTABLE_get_integer_keyed_int(interpreter, init, i+1);
		    SELF.set_integer_keyed_int(key, val);
		    break;
		case PARROT_TIMER_NSEC:
		    nval =
			VTABLE_get_number_keyed_int(interpreter, init, i+1);
		    SELF.set_number_keyed_int(key, nval);
		    break;
		case PARROT_TIMER_HANDLER:
		    pval =
			VTABLE_get_pmc_keyed_int(interpreter, init, i+1);
		    SELF.set_pmc_keyed_int(key, pval);
		    break;
	    }
	}
    }

    void destroy() {
	parrot_timer_event *t = SELF->cache.struct_val;
	del_timer(INTERP, SELF);
	mem_sys_free(t);
    }

    INTVAL get_integer_keyed_int(INTVAL key) {
	parrot_timer_event *t = SELF->cache.struct_val;

	switch(key) {
	    case PARROT_TIMER_SEC:
		return (INTVAL)t->abs_time;
	    case PARROT_TIMER_USEC:
		return (t->abs_time - (INTVAL)t->abs_time) *1000000.0;
	    case PARROT_TIMER_REPEAT:
		return (INTVAL) t->repeat;
	    case PARROT_TIMER_RUNNING:
		return 0;
	}
	return -1;
    }

    PMC* get_pmc_keyed_int(INTVAL key) {
	parrot_timer_event *t = SELF->cache.struct_val;
	switch(key) {
	    case PARROT_TIMER_HANDLER:
		return t->sub;
		break;
	    default:
		return PMCNULL;
	}
	return PMCNULL;
    }

    FLOATVAL get_number_keyed_int(INTVAL key) {
	parrot_timer_event *t = SELF->cache.struct_val;

	switch(key) {
	    case PARROT_TIMER_NSEC:
		return t->abs_time;
		break;
	}
	return -1.0;
    }

    void set_integer_keyed_int(INTVAL key, INTVAL value) {
	parrot_timer_event *t = SELF->cache.struct_val;

	switch(key) {
	    case PARROT_TIMER_SEC:
		t->abs_time = value;
		break;
	    case PARROT_TIMER_USEC:
		t->abs_time += value / 1000000.0;
		break;
	    case PARROT_TIMER_REPEAT:
		t->repeat = value;
		break;
	    case PARROT_TIMER_RUNNING:
		if (value) {
		    add_timer(INTERP, SELF);
		}
		else {
		    del_timer(INTERP, SELF);
		}
		break;
	}
    }

    void set_pmc_keyed_int(INTVAL key, PMC* value) {
	parrot_timer_event *t = SELF->cache.struct_val;
	switch(key) {
	    case PARROT_TIMER_HANDLER:
		t->sub = value;
		break;
	    default:
		break;
	}
    }

    void* invoke(void *next) {
	add_timer(INTERP, SELF);
	return next;
    }

    void set_number_keyed_int(INTVAL key, FLOATVAL value) {
	parrot_timer_event *t = SELF->cache.struct_val;

	switch(key) {
	    case PARROT_TIMER_NSEC:
		t->abs_time = value;
		break;
	}
    }
}
