/*
Copyright: 2001-2003 The Perl Foundation.  All Rights Reserved.
$Id$

=head1 NAME

classes/perlnum.pmc - Perl Floating-Point Number

=head1 DESCRIPTION

These are the vtable functions for the PerlNum base class

=head2 Methods

=over 4

=cut

*/

#include "parrot/parrot.h"
#include "parrot/perltypes.h"

pmclass PerlNum extends perlscalar {

/*

=item C<void init()>

Initializes the number to C<0.0>.

=cut

*/

    void init () {
        PMC_num_val(SELF) = 0.0;
    }

/*

=item C<INTVAL get_integer()>

Returns the integer value of the number.

=cut

*/

    INTVAL get_integer () {
        return (INTVAL)PMC_num_val(SELF);
    }

/*

=item C<BIGNUM *get_bignum()>

Unimplimented. Returns C<NULL>.

=cut

*/

    BIGNUM* get_bignum () {
        /* XXX */
        return NULL;
    }

/*

=item C<STRING *get_string()>

Returns the number as a Parrot string.

=cut

*/

    STRING* get_string () {
        char* buff = mem_sys_allocate(80);
        STRING* s;
#ifdef HAS_SNPRINTF
        snprintf(buff,80,FLOATVAL_FMT,PMC_num_val(SELF));
#else
        sprintf(buff,FLOATVAL_FMT,PMC_num_val(SELF));  /* XXX buffer overflow! */
#endif
        s = string_make(INTERP,buff,strlen(buff),NULL,0,NULL);
        mem_sys_free(buff);
        return s;
    }

/*

=item C<INTVAL get_bool()>

Evaluates the number as a boolean, i.e. it's true if it's not zero.

=cut

*/

    INTVAL get_bool () {
        return (INTVAL)(PMC_num_val(SELF) != 0.0);
    }

/*

=item C<void set_integer_native(INTVAL value)>

=cut

*/

    void set_integer_native (INTVAL value) {
        DYNSELF.morph(enum_class_PerlInt);
        DYNSELF.set_integer_native(value);
    }

/*

=item C<void set_number_native(FLOATVAL value)>

Sets the value of the number to C<value>.

Note that if C<value> is an integer the number morphs to a C<PerlInt>.

=cut

*/

    void set_number_native (FLOATVAL value) {
        INTVAL vali = (INTVAL) value;

        PMC_num_val(SELF) = value;
        /* don't mess around with - 0 */
        if (value == vali && (vali || !Parrot_signbit(value)))
            DYNSELF.set_integer_native(vali);
    }

/*

=item C<void set_number_same(PMC* value)>

Sets the value of the number to the value of C<*value>.

=cut

*/

    void set_number_same (PMC* value) {
        PMC_num_val(SELF) = PMC_num_val(value);
    }

/*

=item C<void set_bignum_native(BIGNUM *value)>

Unimplemented. Does nothing.

=cut

*/

    void set_bignum_native (BIGNUM* value) {
    }

/*

=item C<void set_bignum_same(PMC *value)>

Unimplemented. Does nothing.

=cut

*/

    void set_bignum_same (PMC* value) {
    }

/*

=item C<void set_string_native(STRING *value)>

Sets the value of the number to the value of C<*value>.

Note that this method morphs the number into a C<PerlString>.

=cut

*/

    void set_string_native (STRING * value) {
        DYNSELF.morph(enum_class_PerlString);
        DYNSELF.set_string_native(value);
    }

/*

=item C<void add(PMC *value, PMC *dest)>

Adds C<*value> to the number and returns the result in C<*dest>.

=cut

*/

    void add (PMC* value, PMC* dest) {
        VTABLE_set_number_native(INTERP, dest,
            PMC_num_val(SELF) +
            VTABLE_get_number(INTERP, value)
        );
    }

/*

=item C<void add_int(INTVAL value, PMC *dest)>

Adds C<value> to the number and returns the result in C<*dest>.

=cut

*/

    void add_int (INTVAL value, PMC* dest) {
        VTABLE_set_number_native(INTERP, dest,
            PMC_num_val(SELF) + value);
    }

/*

=item C<void add_bignum(BIGNUM *value, PMC *dest)>

Unimplemented. Does nothing.

=cut

*/

    void add_bignum (BIGNUM* value, PMC* dest) {
    }

/*

=item C<void add_float(FLOATVAL value, PMC *dest)>

Adds C<value> to the number and returns the result in C<*dest>.

=cut

*/

    void add_float (FLOATVAL value, PMC* dest) {
        VTABLE_set_number_native(INTERP, dest,
            PMC_num_val(SELF) + value);
    }

/*

=item C<void subtract(PMC *value, PMC *dest)>

Subtracts C<*value> from the number and returns the result in C<*dest>.

=cut

*/

    void subtract (PMC* value, PMC* dest) {
        VTABLE_set_number_native(INTERP, dest,
            PMC_num_val(SELF) -
            VTABLE_get_number(INTERP, value)
        );
    }

/*

=item C<void subtract_int(INTVAL value, PMC *dest)>

Subtracts C<value> from the number and returns the result in C<*dest>.

=cut

*/

    void subtract_int (INTVAL value, PMC* dest) {
        VTABLE_set_number_native(INTERP, dest,
            PMC_num_val(SELF) - (FLOATVAL)value
        );
    }

/*

=item C<void subtract_bignum(BIGNUM *value, PMC *dest)>

Unimplemented. Does nothing.

=cut

*/

    void subtract_bignum (BIGNUM* value, PMC* dest) {
    }

/*

=item C<void subtract_float(FLOATVAL value, PMC *dest)>

Subtracts C<value> from the number and returns the result in C<*dest>.

=cut

*/

    void subtract_float (FLOATVAL value, PMC* dest) {
        VTABLE_set_number_native(INTERP, dest,
            PMC_num_val(SELF) - value);
    }

/*

=item C<void multiply(PMC *value, PMC *dest)>

Multiplies the number by C<*value> and returns the result in C<*dest>.

=cut

*/

    void multiply (PMC* value, PMC* dest) {
        VTABLE_set_number_native(INTERP, dest,
            PMC_num_val(SELF) *
            VTABLE_get_number(INTERP, value)
        );
    }

/*

=item C<void multiply_int(INTVAL value, PMC *dest)>

Multiplies the number by C<value> and returns the result in C<*dest>.

=cut

*/

    void multiply_int (INTVAL value, PMC* dest) {
        VTABLE_set_number_native(INTERP, dest,
            PMC_num_val(SELF) * value
        );
    }

/*

=item C<void multiply_bignum(BIGNUM *value, PMC *dest)>

Unimplemented. Does nothing.

=cut

*/

    void multiply_bignum (BIGNUM* value, PMC* dest) {
    }

/*

=item C<void multiply_float(FLOATVAL value, PMC *dest)>

Multiplies the number by C<value> and returns the result in C<*dest>.

=cut

*/

    void multiply_float (FLOATVAL value, PMC* dest) {
        VTABLE_set_number_native(INTERP, dest,
            PMC_num_val(SELF) * value);
    }

/*

=item C<void divide(PMC *value, PMC *dest)>

Divides the number by C<*value> and returns the result in C<*dest>.

=cut

*/

    void divide (PMC* value, PMC* dest) {
        VTABLE_set_number_native(INTERP, dest,
            PMC_num_val(SELF) /
            VTABLE_get_number(INTERP, value)
        );
    }

/*

=item C<void divide_int(INTVAL value, PMC *dest)>

=cut

*/

    void divide_int (INTVAL value, PMC* dest) {
        VTABLE_set_number_native(INTERP, dest,
            PMC_num_val(SELF) / value
        );
    }

/*

=item C<void divide_float(FLOATVAL value, PMC *dest)>

Divides the number by C<value> and returns the result in C<*dest>.

=cut

*/

    void divide_float (FLOATVAL value, PMC* dest) {
        VTABLE_set_number_native(INTERP, dest,
            PMC_num_val(SELF) / value
        );
    }

/*

=item C<void cmodulus(PMC *value, PMC *dest)>

Calculates the value of the number C-style C<mod> C<*value> and returns
the result in C<*dest>.

=cut

*/

    void cmodulus (PMC* value, PMC* dest) {
        FLOATVAL f = VTABLE_get_number(INTERP, value);
        VTABLE_set_number_native(INTERP, dest,
            fmod(PMC_num_val(SELF), f));
    }

/*

=item C<void cmodulus_float(FLOATVAL value, PMC *dest)>

=cut

*/

    void cmodulus_float (FLOATVAL value, PMC* dest) {
        VTABLE_set_number_native(INTERP, dest,
            fmod(PMC_num_val(SELF), value));
    }

/*

=item C<void cmodulus_int(INTVAL value, PMC *dest)>

Calculates the value of the number C-style C<mod> C<value> and returns
the result in C<*dest>.

=cut

*/

    void cmodulus_int (INTVAL value, PMC* dest) {
        VTABLE_set_number_native(INTERP, dest,
            fmod(PMC_num_val(SELF), value));
    }

/*

=item C<void modulus(PMC *value, PMC *dest)>

Calculates the value of the number C<mod> C<*value> and returns the
result in C<*dest>.

=cut

*/

    void modulus (PMC* value, PMC* dest) {
        FLOATVAL f = VTABLE_get_number(INTERP, value);
        VTABLE_set_number_native(INTERP, dest,
            floatval_mod(PMC_num_val(SELF), f));
    }

/*

=item C<void modulus_float(FLOATVAL value, PMC *dest)>

=cut

*/

    void modulus_float (FLOATVAL value, PMC* dest) {
        VTABLE_set_number_native(INTERP, dest,
            floatval_mod(PMC_num_val(SELF), value));
    }

/*

=item C<void modulus_int(INTVAL value, PMC *dest)>

Calculates the value of the number C<mod> C<value> and returns the
result in C<*dest>.

=cut

*/

    void modulus_int (INTVAL value, PMC* dest) {
        VTABLE_set_number_native(INTERP, dest,
            floatval_mod(PMC_num_val(SELF), value));
    }

/*

=item C<void neg(PMC *dest)>

If C<dest> is true, then the negation of the number is returned in
C<*dest>. Otherwise the number itself is negated.

=cut

*/

    void neg (PMC * dest) {
        if (!dest)
            PMC_num_val(SELF) = -PMC_num_val(SELF);
        else
            VTABLE_set_number_native(INTERP, dest, -PMC_num_val(SELF));
    }

/*

=item C<INTVAL is_equal(PMC* value)>

The C<==> operation.

=cut

*/

    INTVAL is_equal (PMC* value) {
        return (INTVAL)(PMC_num_val(SELF) == VTABLE_get_number(INTERP, value));
    }

/*

=item C<INTVAL cmp(PMC* value)>



=cut

*/

    INTVAL cmp(PMC* value) {
        FLOATVAL diff;
        diff = PMC_num_val(SELF) - VTABLE_get_number(INTERP, value);
        return diff > 0 ? 1 : diff < 0 ? -1 : 0;
    }

/*

=item C<INTVAL cmp_num(PMC *value)>

Returns the result of comparing the number with C<*value>.

=cut

*/

    INTVAL cmp_num(PMC* value) {
        FLOATVAL diff;
        diff = PMC_num_val(SELF) - VTABLE_get_number(INTERP, value);
        return diff > 0 ? 1 : diff < 0 ? -1 : 0;
    }

/*

=item C<void repeat(PMC *value, PMC *dest)>

=cut

*/

    void repeat (PMC* value, PMC* dest) {
        internal_exception(INVALID_OPERATION,
            "repeat() not implemented in class 'PerlNum'\n");
    }

/*

=item C<void repeat_int(INTVAL value, PMC *dest)>

These two methods raise an "invalid operation" exception.

=cut

*/

    void repeat_int (INTVAL value, PMC* dest) {
        internal_exception(INVALID_OPERATION,
            "repeat() not implemented in class 'PerlNum'\n");
    }

/*

=item C<void increment()>

Increments the number.

=cut

*/

    void increment () {
        PMC_num_val(SELF) ++;
    }

/*

=item C<void decrement()>

Decrements the number.

=cut

*/

    void decrement () {
        PMC_num_val(SELF) --;
    }

/*

=item C<void freeze(visit_info *info)>

Used to archive the number.

=cut

*/
    void freeze(visit_info *info) {
        IMAGE_IO *io = info->image_io;
        SUPER(info);
        io->vtable->push_float(INTERP, io, PMC_num_val(SELF));
    }

/*

=item C<void thaw(visit_info *info)>

Used to unarchive the number.

=cut

*/
    void thaw(visit_info *info) {
        IMAGE_IO *io = info->image_io;
        SUPER(info);
        if (info->extra_flags == EXTRA_IS_NULL)
            PMC_num_val(SELF) = io->vtable->shift_float(INTERP, io);
    }

}

/*

=back

=cut

*/

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
 * vim: expandtab shiftwidth=4:
*/

