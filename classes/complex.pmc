/*
Copyright: 2004 The Perl Foundation.  All Rights Reserved.
$Id$

=head1 NAME

classes/complex.pmc - Complex Numbers PMC Class

=head1 DESCRIPTION

C<Complex> provides a representation of complex numbers. It handles
string parsing/generating and basic mathematical operations.

=head2 Functions

=over 4

=cut

*/

#include "parrot/parrot.h"


#define RE(obj) (((FLOATVAL*)PMC_struct_val(obj))[0])
#define IM(obj) (((FLOATVAL*)PMC_struct_val(obj))[1])


/*

=item C<static void
complex_parse_string(Interp* interpreter,
        FLOATVAL *re, FLOATVAL *im, STRING *value)>

Parses the string in C<value> to produce a complex number, represented
by the real (C<*re>) and imaginary (C<*im>) parts. Raises an exception
if it cannot understand the string.  The string should be of the form
C<a+bi> with optional spaces around C<+> and before C<i>. You can also
use C<j> instead of C<i>.

=cut

*/

static void
complex_parse_string(Interp* interpreter,
        FLOATVAL *re, FLOATVAL *im, STRING *value) {
    char *str;
    INTVAL first_num_length, second_num_length;
    INTVAL first_num_minus, second_num_minus, i;
    char *first_num_offset, *second_num_offset = NULL, *t;
    STRING *S;

    t = str = string_to_cstring(interpreter, value);
    i = 0;
    first_num_offset = str;
    first_num_minus = second_num_minus = 0;

    /* walk the string and identify the real and imaginary parts */

    if(*t == '-') {
        /* first number is negative */
        t++;
        first_num_minus = 1;
        if(*t == ' ') t++; /* allow for an optional space */
        first_num_offset = t;
    }
    while(*t >= '0' && *t <= '9') t++; /* skip digits */
    if(*t == '.') {
        /* this number has a decimal point */
        t++;
        while(*t >= '0' && *t <= '9') t++; /* skip digits */
    }
    /* save the length of the real part */
    first_num_length = t - first_num_offset;

    if(*t == 0) {
        /* end of string; we only have a real part */
        second_num_length = 0;
    }
    else if( (*t == 'i' || *t == 'j') && *(t+1) == 0 ) {
        /* there is only an imaginary part, so the first number was
            actually the imaginary part */
        second_num_length = first_num_length;
        first_num_length = 0;
        second_num_offset = first_num_offset;
        second_num_minus = first_num_minus;
        /* this is useful if there is no number for
            the imaginary part, like in "-i" */
        i = 1;
    }
    else {
        if(*t == ' ') t++; /* skip an optional space */
        /* expect "+" or "-" and the imaginary part */
        if(*t == '+' || *t == '-') {
            second_num_minus = (*t == '-'); /* save the sign */
            t++;
            if(*t == ' ') t++; /* skip another optional space */

            /* save the beginning of the imaginary part */
            second_num_offset = t;
            while(*t >= '0' && *t <= '9') t++; /* skip digits */
            if(*t == '.') {
                /* this number has a decimal point */
                t++;
                while(*t >= '0' && *t <= '9') t++; /* skip digits */
            }
            /* save the length of the imaginary part */
            second_num_length = t - second_num_offset;

            if(*t == ' ') t++; /* allow for one more optional space */

            /* verify that the string ends properly */
            if( (*t != 'i' && *t != 'j') || (*(t+1) != 0) ) {
                /* imaginary part does not end in 'i' or 'j' */
                internal_exception(INVALID_STRING_REPRESENTATION,
                    "Complex: malformed string");
                first_num_length = second_num_length = 0;
            }
            /* this is useful if there is no number for the
                imaginary part, like in "2+i" */
            i = 1;

            /* all is OK, save the number */
        }
        else {
            /* "+" or "-" not found: error */
            internal_exception(INVALID_STRING_REPRESENTATION,
                "Complex: malformed string");
            first_num_length = second_num_length = 0;
        }
    }

    /* now we have the offsets and the lengths;
        we turn them into float values */

    if(first_num_length) {
        /* there is a real part, interpret it */
        S = string_from_cstring(interpreter,
                first_num_offset, first_num_length);
        *re = string_to_num(interpreter, S);
    }
    else {
        /* consider the real part 0.0 */
        *re = 0.0;
    }

    if(second_num_length) {
        /* there is an imaginary part, interpret it */
        S = string_from_cstring(interpreter,
                second_num_offset, second_num_length);
        *im = string_to_num(interpreter, S);
    }
    else {
        /* consider the imaginary part 0.0 */
        if(i) /* the string was something like "1+i" */
            *im = 1.0;
        else
            *im = 0.0;
    }
    if(first_num_minus) *re = - *re;
    if(second_num_minus) *im = - *im;

    string_cstring_free(str);
}

/*

=item C<static FLOATVAL*
complex_locate_keyed_num(Interp* interpreter, PMC* self, STRING *key)>

Interpret the string C<key>; valid keys are C<real> and C<imag>,
representing the real and imaginary parts of the complex number.

=cut

*/

static FLOATVAL*
complex_locate_keyed_num(Interp* interpreter, PMC* self, STRING *key) {
    /* do imag first since real can be read much faster anyway */
    STRING *imag = string_from_cstring(interpreter, "imag", 4);
    STRING *real;

    if(0 == string_equal(interpreter, key, imag))
        return &IM(self);
    real = string_from_cstring(interpreter, "real", 4);
    if(0 == string_equal(interpreter, key, real))
        return &RE(self);
    internal_exception(KEY_NOT_FOUND,
        "Complex: key is neither 'real' or 'imag'");
    return NULL;
}

pmclass Complex {

/*

=item C<PMC* instantiate()>

Create a new complex PMC with passed arguments according to pdd03.

=cut

*/

    PMC* instantiate() {
        PMC *res = pmc_new(INTERP, enum_class_Complex);
        FLOATVAL re = 0.0, im = 0.0;
        int argcI = REG_INT(1);
        int argcS = REG_INT(2);
        int argcP = REG_INT(3);
        int argcN = REG_INT(4);
        /*
         * we can only allow 0..2 arguments of one kind. For
         * mixed (e.g. N,P) args the order of arguments isn't fixed
         */
        if (argcP) {
            re = VTABLE_get_number(INTERP, REG_PMC(5));
            if (argcP == 2)
                im = VTABLE_get_number(INTERP, REG_PMC(6));
            /*
             * TODO throw exception if argument mismatch
             */
        }
        else if (argcN) {
            re = REG_NUM(5);
            if (argcN == 2)
                im = REG_NUM(6);
        }
        else if (argcI) {
            re = REG_INT(5);
            if (argcI == 2)
                im = REG_INT(6);
        }
        else if (argcS == 1) {
            complex_parse_string(INTERP, &RE(res), &IM(res), REG_STR(5));
            return res;
        }
        RE(res) = re;
        IM(res) = im;
        return res;
    }

/*

=item C<void* invoke(void* next)>

Pythonic object constructor. SELF is a Complex Class object. Return a new
C<complex> object according to 2.1. Built-in Functions.

=cut

*/
    void* invoke(void* next) {
        int argcP = REG_INT(3);
        PMC *res = pmc_new(INTERP, enum_class_Complex);
        if (argcP == 1) {
            PMC *arg = REG_PMC(5);
            if (arg->vtable->base_type == enum_class_PerlString) {
                VTABLE_set_string_native(INTERP, res, PMC_str_val(arg));
            }
            else
                RE(res) = VTABLE_get_number(INTERP, arg);
        }
        else if (argcP == 2) {
            RE(res) = VTABLE_get_number(INTERP, REG_PMC(5));
            IM(res) = VTABLE_get_number(INTERP, REG_PMC(6));
        }
        REG_PMC(5) = res;
        return next;
    }

/*

=back

=head2 Methods

=over 4

=item C<void init()>

Initializes the complex number with the value 0+0i.

=item C<void init_pmc (PMC* initializer)>

Initializes the complex number with the specified values.
(not implemented)

=item C<void destroy ()>

Cleans up.

=item C<PMC* clone ()>

Creates an identical copy of the complex number.

=cut

*/

    void init () {
        /* XXX should check if mem_sys_allocate failed */
        FLOATVAL* data = (FLOATVAL*)mem_sys_allocate(2 * sizeof(FLOATVAL));
        PMC_struct_val(SELF) = data;
        PObj_active_destroy_SET(SELF);
        RE(SELF) = IM(SELF) = 0.0;
    }

    void init_pmc (PMC* initializer) {
        /* XXX not implemented */
        DYNSELF.init();
    }

    void destroy () {
        mem_sys_free(PMC_struct_val(SELF));
        PMC_struct_val(SELF) = NULL;
    }

    void morph (INTVAL type) {
        if (SELF->vtable->base_type == type)
            return;
        SUPER(type);
    }

    PMC* clone () {
        PMC* dest = pmc_new_noinit(INTERP, SELF->vtable->base_type);
        FLOATVAL* data = (FLOATVAL*)mem_sys_allocate(2 * sizeof(FLOATVAL));
        PMC_struct_val(dest) = data;
        PObj_active_destroy_SET(dest);
        RE(dest) = RE(SELF);
        IM(dest) = IM(SELF);
        return dest;
    }

/*

=item C<INTVAL get_integer ()>

Returns the modulus of the complex number as an integer.

=item C<FLOATVAL get_number ()>

Returns the modulus of the complex number.

=item C<STRING* get_string ()>

Returns the complex number as a string in the form C<a+bi>.

=item C<INTVAL get_bool ()>

Returns true if the complex number is non-zero.

=cut

*/

    INTVAL get_integer () {
        return (INTVAL)(DYNSELF.get_number());
    }

    FLOATVAL get_number () {
        return sqrt(RE(SELF)*RE(SELF) + IM(SELF)*IM(SELF));
    }

    STRING* get_string () {
        STRING *s;
        if (IM(SELF) >= 0)
            s = Parrot_sprintf_c(INTERP,
                    "%vg+%vgi", RE(SELF), IM(SELF));
        else
            s = Parrot_sprintf_c(INTERP,
                    "%vg-%vgi", RE(SELF), -IM(SELF));
        return s;
    }

    INTVAL get_bool () {
        return (INTVAL)(RE(SELF) != 0.0 || IM(SELF) != 0.0);
    }

/*

=item C<INTVAL get_integer_keyed (PMC* key)>

=item C<INTVAL get_integer_keyed_str (STRING* key)>

=item C<FLOATVAL get_number_keyed (PMC* key)>

=item C<FLOATVAL get_number_keyed_str (STRING* key)>

=item C<PMC* get_pmc_keyed (PMC* key)>

=item C<PMC* get_pmc_keyed_str (STRING* key)>

Returns the requested number (real part for C<real> and imaginary for C<imag>).

=cut

*/

    INTVAL get_integer_keyed (PMC* key) {
        STRING* s = VTABLE_get_string(INTERP, key);
        return DYNSELF.get_integer_keyed_str(s);
    }

    INTVAL get_integer_keyed_str (STRING* key) {
        return (INTVAL)(DYNSELF.get_number_keyed_str(key));
    }

    FLOATVAL get_number_keyed (PMC* key) {
        STRING* s = VTABLE_get_string(INTERP, key);
        return DYNSELF.get_number_keyed_str(s);
    }

    FLOATVAL get_number_keyed_str (STRING* key) {
        FLOATVAL *num = complex_locate_keyed_num(INTERP, SELF, key);
        if(num)
            return *num;
        return 0.0;
    }

    PMC* get_pmc_keyed (PMC* key) {
        STRING* s = VTABLE_get_string(INTERP, key);
        return DYNSELF.get_pmc_keyed_str(s);
    }

    PMC* get_pmc_keyed_str (STRING* key) {
        PMC *ret;
        FLOATVAL val;

        ret = pmc_new(INTERP, enum_class_Float);
        val = DYNSELF.get_number_keyed_str(key);
        VTABLE_set_number_native(INTERP, ret, val);
        return ret;
    }

/*

=item C<FLOATVAL get_number_keyed_int(INTVAL key)>

Quick hack to emulate get_real() and get_imag():

  key = 0 ... get real part
  key = 1 ... get imag part

=item C<void set_number_keyed_int(INTVAL key, FLOATVAL v)>

Set real or imag depending on key

*/

    FLOATVAL get_number_keyed_int(INTVAL key) {
        switch (key) {
            case 0:
                return RE(SELF);
            case 1:
                return IM(SELF);
            default:
                internal_exception(1, "Complex: key must be 0 or 1");
        }
        return 0.0;
    }

    void set_number_keyed_int(INTVAL key, FLOATVAL v) {
        switch (key) {
            case 0:
                RE(SELF) = v;
                break;
            case 1:
                IM(SELF) = v;
                break;
            default:
                internal_exception(1, "Complex: key must be 0 or 1");
        }
    }
/*

=item C<void set_string_native (STRING* value)>

Parses the string C<value> into a complex number; raises an exception on failure.

=item C<void set_pmc (PMC* value)>

if C<value> is a Complex PMC then the complex number is set to its value; otherwise
C<value>'s string representation is parsed with C<set_string_native()>.

=item C<void set_integer_native (INTVAL value)>

=item C<void set_number_native (FLOATVAL value)>

Sets the real part of the complex number to C<value> and the imaginary
part to C<0.0>

=cut

*/

    void set_string_native (STRING* value) {
        complex_parse_string(INTERP, &RE(SELF), &IM(SELF), value);
    }

    void set_pmc (PMC* value) {
        if(value->vtable->base_type == enum_class_Complex) {
            RE(SELF) = RE(value);
            IM(SELF) = IM(value);
        }
        else {
            DYNSELF.set_string_native(VTABLE_get_string(INTERP, value));
        }
    }

    void set_integer_native (INTVAL value) {
        DYNSELF.set_number_native(value);
    }

    void set_number_native (FLOATVAL value) {
        RE(SELF) = value;
        IM(SELF) = 0.0;
    }

/*

=item C<void set_integer_keyed (PMC* key, INTVAL value)>

=item C<void set_integer_keyed_str (STRING* key, INTVAL value)>

=item C<void set_number_keyed (PMC* key, FLOATVAL value)>

=item C<void set_number_keyed_str (STRING* key, FLOATVAL value)>

=item C<void set_pmc_keyed (PMC* key, PMC* value)>

=item C<void set_pmc_keyed_str (STRING* key, PMC* value)>

Sets the requested number (real part for C<real> and imaginary for C<imag>)
to C<value>.

=cut

*/

    void set_integer_keyed (PMC* key, INTVAL value) {
        DYNSELF.set_number_keyed(key, value);
    }

    void set_integer_keyed_str (STRING* key, INTVAL value) {
        DYNSELF.set_number_keyed_str(key, value);
    }

    void set_number_keyed (PMC* key, FLOATVAL value) {
        STRING* s = VTABLE_get_string(INTERP, key);
        DYNSELF.set_number_keyed_str(s, value);
    }

    void set_number_keyed_str (STRING* key, FLOATVAL value) {
        FLOATVAL *num = complex_locate_keyed_num(INTERP, SELF, key);
        if(num)
            *num = value;
    }

    void set_pmc_keyed (PMC* key, PMC* value) {
        FLOATVAL f = VTABLE_get_number(INTERP, value);
        DYNSELF.set_number_keyed(key, f);
    }

    void set_pmc_keyed_str (STRING* key, PMC* value) {
        FLOATVAL f = VTABLE_get_number(INTERP, value);
        DYNSELF.set_number_keyed_str(key, f);
    }

/*

=item C<PMC* add (PMC* value, PMC* dest)>

=item C<PMC* add_int (INTVAL value, PMC* dest)>

=item C<PMC* add_float (FLOATVAL value, PMC* dest)>

Adds C<value> to the complex number, placing the result in C<dest>.

=cut

*/

    PMC* add (PMC* value, PMC* dest) {
MMD_Complex: {
            if (dest)
                VTABLE_morph(INTERP, dest, SELF->vtable->base_type);
            else {
                dest = pmc_new(INTERP, SELF->vtable->base_type);
            }
            RE(dest) = RE(SELF) + RE(value);
            IM(dest) = IM(SELF) + IM(value);
            return dest;
        }
MMD_DEFAULT: {
            if (dest)
                VTABLE_morph(INTERP, dest, SELF->vtable->base_type);
            else {
                dest = pmc_new(INTERP, SELF->vtable->base_type);
            }
            RE(dest) = RE(SELF) + VTABLE_get_number(INTERP, value);
            IM(dest) = IM(SELF);
            return dest;
        }
    }

    PMC* add_int (INTVAL value, PMC* dest) {
        if (dest)
            VTABLE_morph(INTERP, dest, SELF->vtable->base_type);
        else {
            dest = pmc_new(INTERP, SELF->vtable->base_type);
        }
        RE(dest) = RE(SELF) + value;
        IM(dest) = IM(SELF);
        return dest;
    }

    PMC* add_float (FLOATVAL value, PMC* dest) {
        if (dest)
            VTABLE_morph(INTERP, dest, SELF->vtable->base_type);
        else {
            dest = pmc_new(INTERP, SELF->vtable->base_type);
        }
        VTABLE_morph(INTERP, dest, SELF->vtable->base_type);
        RE(dest) = RE(SELF) + value;
        IM(dest) = IM(SELF);
        return dest;
    }

    void i_add (PMC* value) {
MMD_Complex: {
            RE(SELF) += RE(value);
            IM(SELF) += IM(value);
        }
MMD_DEFAULT: {
            RE(SELF) += VTABLE_get_number(INTERP, value);
        }
    }

    void i_add_int (INTVAL value) {
        RE(SELF) += (FLOATVAL)value;
    }
    void i_add_float (FLOATVAL value) {
        RE(SELF) += value;
    }

/*

=item C<PMC* subtract (PMC* value, PMC* dest)>

=item C<PMC* subtract_int (INTVAL value, PMC* dest)>

=item C<PMC* subtract_float (FLOATVAL value, PMC* dest)>

Subtracts C<value> from the complex number, placing the result in C<dest>.

=cut

*/

    PMC* subtract (PMC* value, PMC* dest) {
MMD_Complex: {
            if (dest)
                VTABLE_morph(INTERP, dest, SELF->vtable->base_type);
            else {
                dest = pmc_new(INTERP, SELF->vtable->base_type);
            }
            RE(dest) = RE(SELF) - RE(value);
            IM(dest) = IM(SELF) - IM(value);
            return dest;
        }
MMD_DEFAULT: {
            if (dest)
                VTABLE_morph(INTERP, dest, SELF->vtable->base_type);
            else {
                dest = pmc_new(INTERP, SELF->vtable->base_type);
            }
            RE(dest) = RE(SELF) - VTABLE_get_number(INTERP, value);
            IM(dest) = IM(SELF);
            return dest;
        }
    }

    PMC* subtract_int (INTVAL value, PMC* dest) {
        if (dest)
            VTABLE_morph(INTERP, dest, SELF->vtable->base_type);
        else {
            dest = pmc_new(INTERP, SELF->vtable->base_type);
        }
        RE(dest) = RE(SELF) - value;
        IM(dest) = IM(SELF);
        return dest;
    }

    PMC* subtract_float (FLOATVAL value, PMC* dest) {
        if (dest)
            VTABLE_morph(INTERP, dest, SELF->vtable->base_type);
        else {
            dest = pmc_new(INTERP, SELF->vtable->base_type);
        }
        RE(dest) = RE(SELF) - value;
        IM(dest) = IM(SELF);
        return dest;
    }

    void i_subtract (PMC* value) {
MMD_Complex: {
            RE(SELF) -= RE(value);
            IM(SELF) -= IM(value);
        }
MMD_DEFAULT: {
            RE(SELF) -= VTABLE_get_number(INTERP, value);
        }
    }

    void i_subtract_int (INTVAL value) {
        RE(SELF) -= (FLOATVAL)value;
    }
    void i_subtract_float (FLOATVAL value) {
        RE(SELF) -= value;
    }
/*

=item C<PMC* multiply (PMC* value, PMC* dest)>

=item C<PMC* multiply_int (INTVAL value, PMC* dest)>

=item C<PMC* multiply_float (FLOATVAL value, PMC* dest)>

Multiplies the complex number with C<value>, placing the result in C<dest>.

=item C<void i_multiply (PMC* value)>

=item C<void i_multiply_int (INTVAL value)>

=item C<void i_multiply_float (FLOATVAL value)>

Multiplies the complex number SELF inplace with C<value>.

=cut

*/

/*

  TODO for better precision:

  (a+ib)(c+id)=(ac-bd)+i((a+b)(c+d)-ac-bd).

*/
    PMC* multiply (PMC* value, PMC* dest) {
MMD_Complex: {
            FLOATVAL re = RE(SELF) * RE(value) - IM(SELF) * IM(value);
            FLOATVAL im = IM(SELF) * RE(value) + RE(SELF) * IM(value);
            if (dest)
                VTABLE_morph(INTERP, dest, SELF->vtable->base_type);
            else {
                dest = pmc_new(INTERP, SELF->vtable->base_type);
            }
            RE(dest) = re;
            IM(dest) = im;
            return dest;
        }
MMD_DEFAULT: {
            FLOATVAL re = RE(SELF) * VTABLE_get_number(INTERP, value);
            FLOATVAL im = IM(SELF) * VTABLE_get_number(INTERP, value);
            if (dest)
                VTABLE_morph(INTERP, dest, SELF->vtable->base_type);
            else {
                dest = pmc_new(INTERP, SELF->vtable->base_type);
            }
            RE(dest) = re;
            IM(dest) = im;
            return dest;
        }
    }

    PMC* multiply_int (INTVAL value, PMC* dest) {
        if (dest)
            VTABLE_morph(INTERP, dest, SELF->vtable->base_type);
        else {
            dest = pmc_new(INTERP, SELF->vtable->base_type);
        }
        RE(dest) = RE(SELF) * value;
        IM(dest) = IM(SELF) * value;
        return dest;
    }

    PMC* multiply_float (FLOATVAL value, PMC* dest) {
        if (dest)
            VTABLE_morph(INTERP, dest, SELF->vtable->base_type);
        else {
            dest = pmc_new(INTERP, SELF->vtable->base_type);
        }
        RE(dest) = RE(SELF) * value;
        IM(dest) = IM(SELF) * value;
        return dest;
    }

    void i_multiply (PMC* value) {
MMD_Complex: {
            FLOATVAL re = RE(SELF) * RE(value) - IM(SELF) * IM(value);
            FLOATVAL im = IM(SELF) * RE(value) + RE(SELF) * IM(value);
            RE(SELF) = re;
            IM(SELF) = im;
        }
MMD_DEFAULT: {
            RE(SELF) *= VTABLE_get_number(INTERP, value);
            IM(SELF) *= VTABLE_get_number(INTERP, value);
        }
    }

    void i_multiply_int (INTVAL value) {
        RE(SELF) *= value;
        IM(SELF) *= value;
    }

    void i_multiply_float (FLOATVAL value) {
        RE(SELF) *= value;
        IM(SELF) *= value;
    }

/*

=item C<PMC* divide (PMC* value, PMC* dest)>

=item C<PMC* divide_int (INTVAL value, PMC* dest)>

=item C<PMC* divide_float (FLOATVAL value, PMC* dest)>

Divide the complex number by C<value>, placing the result in C<dest>.

=item C<void i_divide (PMC* value, PMC* dest)>

=item C<void i_divide_int (INTVAL value, PMC* dest)>

=item C<void i_divide_float (FLOATVAL value, PMC* dest)>

Divide the complex number C<SELF> by C<value> inplace.

TODO divide by zero exception

=cut

*/

    PMC* divide (PMC* value, PMC* dest) {
MMD_Complex: {
            FLOATVAL mod, re, im;

            if (dest)
                VTABLE_morph(INTERP, dest, SELF->vtable->base_type);
            else {
                dest = pmc_new(INTERP, SELF->vtable->base_type);
            }
            /* a little speed optimisation: cache an intermediate number;
                I'm not sure the compiler does this */
            mod = (RE(value) * RE(value) + IM(value) * IM(value));
            re = (RE(SELF) * RE(value) + IM(SELF) * IM(value)) / mod;
            im = (IM(SELF) * RE(value) - RE(SELF) * IM(value)) / mod;
            RE(dest) = re;
            IM(dest) = im;
            return dest;
        }
MMD_DEFAULT: {
            FLOATVAL d = VTABLE_get_number(INTERP, value);
            if (dest)
                VTABLE_morph(INTERP, dest, SELF->vtable->base_type);
            else {
                dest = pmc_new(INTERP, SELF->vtable->base_type);
            }
            RE(dest) = RE(SELF) / d;
            IM(dest) = IM(SELF) / d;
            return dest;
        }
    }

    PMC* divide_int (INTVAL value, PMC* dest) {
        if (dest)
            VTABLE_morph(INTERP, dest, SELF->vtable->base_type);
        else {
            dest = pmc_new(INTERP, SELF->vtable->base_type);
        }
        RE(dest) = RE(SELF) / value;
        IM(dest) = IM(SELF) / value;
        return dest;
    }

    PMC* divide_float (FLOATVAL value, PMC* dest) {
        if (dest)
            VTABLE_morph(INTERP, dest, SELF->vtable->base_type);
        else {
            dest = pmc_new(INTERP, SELF->vtable->base_type);
        }
        RE(dest) = RE(SELF) / value;
        IM(dest) = IM(SELF) / value;
        return dest;
    }

    void i_divide (PMC* value) {
MMD_Complex: {
            FLOATVAL mod, re, im;

            /* a little speed optimisation: cache an intermediate number;
                I'm not sure the compiler does this */
            mod = (RE(value) * RE(value) + IM(value) * IM(value));
            re = (RE(SELF) * RE(value) + IM(SELF) * IM(value)) / mod;
            im = (IM(SELF) * RE(value) - RE(SELF) * IM(value)) / mod;
            RE(SELF) = re;
            IM(SELF) = im;
        }
MMD_DEFAULT: {
            FLOATVAL d = VTABLE_get_number(INTERP, value);
            RE(SELF) /= d;
            IM(SELF) /= d;
        }
    }

    void i_divide_int (INTVAL value) {
        RE(SELF) /= value;
        IM(SELF) /= value;
    }

    void i_divide_float (FLOATVAL value) {
        RE(SELF) /= value;
        IM(SELF) /= value;
    }


/*

=item C<PMC* neg(PMC *dest)>

=item C<void neg()>

Set C<dest> to the negated value of C<SELF>.

=cut

*/

    PMC* neg (PMC* dest) {
        if (!dest)
            dest = pmc_new(INTERP, SELF->vtable->base_type);
        else
            VTABLE_morph(INTERP, dest, SELF->vtable->base_type);
        RE(dest) = - RE(SELF);
        IM(dest) = - IM(SELF);
        return dest;
    }

    void i_neg () {
        RE(SELF) = - RE(SELF);
        IM(SELF) = - IM(SELF);
    }

/*

=item C<INTVAL is_equal (PMC* value)>

Compares the complex number with C<value> and returns true if they are equal.

=cut

*/

    INTVAL is_equal (PMC* value) {
MMD_Complex: {
            return (INTVAL)(
                    RE(SELF) == RE(value) &&
                    IM(SELF) == IM(value)
                );
        }
MMD_Float: {
/*
        XXX: the above really should be MMD_DEFAULT, but that causes
             t/dynclass/pycomplex.t to fail.
*/
            if(IM(SELF) != 0.0)
                return (INTVAL)0;
            return (RE(SELF) == VTABLE_get_number(INTERP, value));
        }
    }

/*

=item C<PMC* absolute(PMC* dest)>

=item C<void i_absolute()>

Sets C<dest> to the absolute value of SELF that is the distance from (0.0).

=cut

*/

/*

  TODO for better precision: hinted by vaxman according to "Numerical Recipes
  in Fortran 77", 2nd edition, Press, Vetterling, Teukolsky, Flannery,
  Cambridge University Press, 2001, pp. 171ff:


|a+ib|=|a|*sqrt(1+(b/a)**2), if |a|>=|b|,
       |b|*sqrt(1+(a/b)**2)  else.

*/

    PMC* absolute(PMC *dest) {
        FLOATVAL d = sqrt(RE(SELF)*RE(SELF) + IM(SELF)*IM(SELF));
        if (!dest)
            dest = pmc_new(INTERP, enum_class_Float);   /* XXX */
        VTABLE_set_number_native(INTERP, dest, d);
        return dest;
    }

    void i_absolute() {
        FLOATVAL d = sqrt(RE(SELF)*RE(SELF) + IM(SELF)*IM(SELF));
        VTABLE_morph(INTERP, SELF, enum_class_Float);   /* XXX */
        VTABLE_set_number_native(INTERP, SELF, d);
    }
}

/*

=back

=cut

*/

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
 * vim: expandtab shiftwidth=4:
*/
