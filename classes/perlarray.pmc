/*
Copyright: 2001-2003 The Perl Foundation.  All Rights Reserved.
$Id$

=head1 NAME

classes/perlarray.pmc - Perl Array

=head1 DESCRIPTION

These are the vtable functions for the PerlArray base class

=head2 Functions

=over 4

=cut

*/

#include "parrot/parrot.h"

/*

=item C<static PMC *undef(Interp *interpreter)>

Returns the C<PerlUndef> PMC.

=cut

*/

static PMC* undef(Interp* interpreter)
{
    return pmc_new(interpreter, enum_class_PerlUndef);
}

/*

=item C<static PMC *
Parrot_PerlArray_set_pmc_ptr(Interp *interp, List *list, INTVAL key)>

Returns the PMC pointer for the element at index C<key>.

=cut

*/

static PMC *
Parrot_PerlArray_set_pmc_ptr(Interp *interp, List *list, INTVAL key)
{
    void * ret = list_get(interp, list, key, enum_type_PMC);
    PMC *value;

    /* assign into a sparse or past end */
    if (ret == 0 || ret == (void*) -1 || *(PMC**)ret == 0) {
        value = undef(interp);
        list_assign(interp, list, key, value, enum_type_PMC);
    }
    else
        value = *(PMC**) ret;
    return value;
}

pmclass PerlArray extends Array need_ext does array {
    void class_init () {
        /* this should be autmatically done - probably */
        if (pass) {
            enter_nci_method(INTERP, enum_class_PerlArray,
                    F2DPTR(Parrot_PerlArray_get_string),
                    "__repr__", "SIO");
        }
    }

/*

=back

=head2 Methods

=over 4

=item C<void set_integer_keyed_int(INTVAL key, INTVAL value)>

Converts C<value> to a C<PerlInt> and assigns it to the array at index
C<key>.

=cut

*/

    void set_integer_keyed_int (INTVAL key, INTVAL value) {
        PMC *src = pmc_new_noinit(INTERP, enum_class_PerlInt);
        PMC_int_val(src) = value;
        list_assign(INTERP, (List *) PMC_data(SELF), key, src, enum_type_PMC);
    }

/*

=item C<void set_integer_keyed(PMC *key, INTVAL value)>

Assigns C<value> to the array at index C<*key>.

=cut

*/

    void set_integer_keyed (PMC* key, INTVAL value) {
        INTVAL ix;

        ix = key_integer(INTERP, key);
        if (ix >= DYNSELF.elements() || ix < -DYNSELF.elements())
        list_set_length(INTERP, (List *) PMC_data(SELF), ix+1);
        SUPER(key, value);
    }

/*

=item C<void set_number_keyed_int(INTVAL key, FLOATVAL value)>

Assigns C<value> to the array at index C<key>.

=cut

*/

    void set_number_keyed_int (INTVAL key, FLOATVAL value) {
        PMC * ptr = Parrot_PerlArray_set_pmc_ptr(INTERP,
            (List *) PMC_data(SELF), key);
        VTABLE_set_number_native(INTERP, ptr, value);
    }

/*

=item C<void set_number_keyed(PMC *key, FLOATVAL value)>

Assigns C<value> to the array at index C<*key>.

=cut

*/

    void set_number_keyed (PMC* key, FLOATVAL value) {
        INTVAL ix;

        ix = key_integer(INTERP, key);
        if (ix >= DYNSELF.elements() || ix < -DYNSELF.elements())
        list_set_length(INTERP, (List *) PMC_data(SELF), ix+1);
        SUPER(key, value);
    }

/*

=item C<void set_string_keyed_int(INTVAL key, STRING *value)>

Assigns C<*value> to the array at index C<key>.

=cut

*/

    void set_string_keyed_int (INTVAL key, STRING* value) {
        PMC * ptr = Parrot_PerlArray_set_pmc_ptr(INTERP,
            (List *) PMC_data(SELF), key);
        VTABLE_set_string_native(INTERP, ptr, value);
    }

/*

=item C<void set_string_keyed (PMC *key, STRING *value)>

Assigns C<*value> to the array at index C<*key>.

=cut

*/

    void set_string_keyed (PMC* key, STRING* value) {
        INTVAL ix;

        ix = key_integer(INTERP, key);
        if (ix >= DYNSELF.elements() || ix < -DYNSELF.elements())
        list_set_length(INTERP, (List *) PMC_data(SELF), ix+1);
        SUPER(key, value);
    }

/*

=item C<void set_pmc_keyed_int(INTVAL key, PMC *src)>

Assigns C<*src> to the array at index C<key>.

=cut

*/

    void set_pmc_keyed_int (INTVAL key, PMC* src) {
        list_assign(INTERP, (List *) PMC_data(SELF), key, src, enum_type_PMC);
    }

/*

=item C<void set_pmc_keyed (PMC *key, PMC *value)>

Assigns C<*value> to the array at index C<*key>.

=cut

*/

    void set_pmc_keyed (PMC* key, PMC* value) {
        INTVAL ix;

        ix = key_integer(INTERP, key);
        if (ix >= DYNSELF.elements() || ix < -DYNSELF.elements())
        list_set_length(INTERP, (List *) PMC_data(SELF), ix+1);
        SUPER(key, value);
    }

/*

=item C<INTVAL get_integer_keyed_int(INTVAL key)>

Returns the integer value of the element at index C<key>.

=cut

*/

    INTVAL get_integer_keyed_int (INTVAL key) {
        if (key >= DYNSELF.elements() || key < -DYNSELF.elements()) {
            if (PARROT_WARNINGS_test(interpreter,
                                     PARROT_WARNINGS_UNDEF_FLAG)) {
                Parrot_warn(INTERP, PARROT_WARNINGS_UNDEF_FLAG,
                            "Use of uninitialized value");
            }
            return 0;
        }
        else
            return SUPER(key);
    }

/*

=item C<FLOATVAL get_number_keyed_int(INTVAL key)>

Returns the floating-point value of the element at index C<key>.

=cut

*/

    FLOATVAL get_number_keyed_int (INTVAL key) {
        if (key >= DYNSELF.elements() || key < -DYNSELF.elements()) {
            if (PARROT_WARNINGS_test(interpreter,
                                     PARROT_WARNINGS_UNDEF_FLAG)) {
                Parrot_warn(INTERP, PARROT_WARNINGS_UNDEF_FLAG,
                            "Use of uninitialized value");
            }
            return 0.0;
        }
        else
            return SUPER(key);
    }

/*

=item C<STRING *get_string()>

Returns the number of elements in the array as a Parrot string.

For Python returns its repr.

=cut

*/

    STRING* get_string () {
        if (Interp_flags_TEST(interpreter, PARROT_PYTHON_MODE)) {
            STRING *res, *s;
            INTVAL j, n;
            PMC *val;

            res = string_from_cstring(INTERP, "[", 0);
            n = VTABLE_elements(INTERP, SELF);
            for (j = 0; j < n; ++j) {
                val = SELF.get_pmc_keyed_int(j);
                res = string_append(INTERP, res,
                        VTABLE_get_repr(INTERP, val), 0);
                if (j < n - 1)
                    res = string_append(INTERP, res,
                            const_string(INTERP, ", "), 0);
            }
            res = string_append(INTERP, res,
                        const_string(INTERP, "]"), 0);
            return res;
        }

        return string_from_int(INTERP, DYNSELF.elements());
    }

/*

=item C<STRING *get_string_keyed_int(INTVAL key)>

Returns the Parrot string value of the element at index C<key>.

=cut

*/

    STRING* get_string_keyed_int (INTVAL key) {
        if (key >= DYNSELF.elements() || key < -DYNSELF.elements()) {
            if (PARROT_WARNINGS_test(interpreter,
                                     PARROT_WARNINGS_UNDEF_FLAG)) {
                Parrot_warn(INTERP, PARROT_WARNINGS_UNDEF_FLAG,
                            "Use of uninitialized value");
            }
            return string_make_empty(interpreter,  enum_stringrep_one, 0);
        }
        else
            return SUPER(key);
    }

/*

=item C<PMC *get_pmc_keyed_int(INTVAL key)>

Returns the PMC value of the element at index C<key>.

=cut

*/

    PMC* get_pmc_keyed_int (INTVAL key) {
        if (key >= DYNSELF.elements() || key < -DYNSELF.elements()) {
            if (PARROT_WARNINGS_test(interpreter,
                                     PARROT_WARNINGS_UNDEF_FLAG)) {
                Parrot_warn(INTERP, PARROT_WARNINGS_UNDEF_FLAG,
                            "Use of uninitialized value");
            }
            return undef(INTERP);
        }
        else
            return SUPER(key);
    }

}

/*

=back

=head1 TODO

Fix the arithmetic ops (right now they just corrupt the array length and
possibly seg fault).

=cut

*/

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
 * vim: expandtab shiftwidth=4:
*/
