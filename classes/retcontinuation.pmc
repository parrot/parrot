/*
Copyright: 2001-2003 The Perl Foundation.  All Rights Reserved.
$Id$

=head1 NAME

classes/retcontinuation.pmc - Return Continuation

=head1 DESCRIPTION

C<RetContinuation> extends C<Continuation>.

A return continuation doesn't make COWed copies of the context, it just
has pointers to the context, that are restored on invoke.

=head2 Methods

=over 4

=cut

*/

#include "parrot/parrot.h"
#include "parrot/method_util.h"

/* XXX s. objects.c */
void add_to_retc_free_list(Parrot_Interp, PMC*);

pmclass RetContinuation extends Continuation {

/*

=item C<void init()>

Initializes the continuation.

=cut

*/

    void init () {
        PMC_sub(SELF) = new_ret_continuation(INTERP);
        PMC_struct_val(SELF) = NULL;
        PObj_custom_mark_destroy_SETALL(SELF);
        PObj_get_FLAGS(SELF) &= ~PObj_private2_FLAG;
    }

    void mark () {
        struct Parrot_Sub * cc = (struct Parrot_Sub*)PMC_sub(SELF);
       /*
        * s. imcc/t/syn/pcc_16 and t/op/gc_12
        *
        * marking a RetContinuation context segfaults in these tests
        * the coroutine has a reference to the return continuation,
        * which is recreated in main by invokecc. When now this
        * retcontinuation is marked its context isn't pointing to
        * the interpreter context anymore - its garbage.
        *
        * But if the continuation is a real continuation, we have to
        * mark its context. s. t/op/gc_13
        *
        * -leo
        */
        if (!(PObj_get_FLAGS(SELF) & PObj_private2_FLAG))
            mark_context(INTERP, &cc->ctx);
    }

    void* invoke (void* next) {
        struct Parrot_Sub * cc = (struct Parrot_Sub*)PMC_sub(SELF);
        restore_context(interpreter, &cc->ctx);
        if (interpreter->code->cur_cs != cc->seg) {
            Parrot_switch_to_cs(interpreter, cc->seg, 1);
        }
        next = PMC_struct_val(SELF);
        add_to_retc_free_list(interpreter, SELF);
        return next;
    }
/*

=item C<PMC *clone()>

Creates and returns a clone of the continuation.

=cut

*/

    PMC* clone() {
        struct Parrot_Sub * sub;
        PMC* ret = pmc_new_noinit(INTERP, SELF->vtable->base_type);
        PObj_custom_mark_destroy_SETALL(ret);
        sub = PMC_sub(ret) = mem_sys_allocate(sizeof(struct Parrot_Sub));
        memcpy(sub, PMC_sub(SELF), sizeof(struct Parrot_Sub));
        PMC_struct_val(ret) = PMC_struct_val(SELF);
        mark_stack_not_reusable(INTERP, &sub->ctx);
        return ret;
    }
}

/*

=back

=head1 HISTORY

Initial revision by sean 2002/08/04.

=cut

*/

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
 * vim: expandtab shiftwidth=4:
*/
