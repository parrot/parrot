/*
Copyright: 2001-2003 The Perl Foundation.  All Rights Reserved.
$Id$

=head1 NAME

classes/eval.pmc - Dynamic code evaluation

=head1 DESCRIPTION

C<Eval> extends C<Closure> to provide C<eval>-like dynamic code
evaluation and execution.

=head2 Methods

=over 4

=cut

*/

#include "parrot/parrot.h"

static void
clear_fixups(Interp* interpreter, PMC* self)
{
    opcode_t i, ci;
    struct PackFile_ByteCode *seg;
    struct PackFile_FixupTable *ft;
    struct PackFile_ConstTable *ct;
    PMC *sub;

    seg = PMC_sub(self)->seg;
    if (!seg)
        return;
    ft = seg->fixups;
    if (!ft)
        return;
    ct = seg->const_table;
    if (!ct)
        return;
    for (i = 0; i < ft->fixup_count; i++) {
        switch (ft->fixups[i]->type) {
            case enum_fixup_sub:
                ci = ft->fixups[i]->offset;
                sub = ct->constants[ci]->u.key;
                VTABLE_destroy(interpreter, sub);
                ct->constants[ci]->u.key = NULL;
                ft->fixups[i]->type = 0;
        }
    }
}

pmclass Eval extends Closure need_ext {

    void init() {
        parrot_sub_t sub_data;
        SUPER();
        sub_data = PMC_sub(SELF);
        PObj_custom_mark_destroy_SETALL(SELF);
        sub_data->seg = NULL;
    }

    void destroy() {
        /*
         * If the compiled code contained any .sub (or .pcc.sub)
         * subroutines, these subs got installed in the globals
         * during compiling this bytecode segment.
         *
         * These globals still exist, calling them will segfault
         * as the segment is destroyed now.
         *
         * TODO walk the fixups for this segment, locate globals
         *      and nullify the Sub PMC.
         * This probably needs a pointer into the globals.
         */
        parrot_sub_t sub_data;
        struct PackFile_Segment *seg;
        struct PackFile_ByteCode *cur_cs;

        clear_fixups(INTERP, SELF);
        sub_data = PMC_sub(SELF);

        if (!sub_data)
            return;
        cur_cs = sub_data->seg;
        if (!cur_cs)
            return;

        if (cur_cs->const_table)
            PackFile_ConstTable_clear(INTERP, cur_cs->const_table);
        cur_cs->const_table = NULL;
        seg = (struct PackFile_Segment *)cur_cs->debugs;
        if (seg)
            PackFile_Segment_destroy(INTERP, seg);
        cur_cs->debugs = NULL;
        if (cur_cs->fixups)
            PackFile_FixupTable_clear(INTERP, cur_cs->fixups);
        cur_cs->fixups = NULL;
        seg = (struct PackFile_Segment *)cur_cs;
        PackFile_Segment_destroy(INTERP, seg);
        sub_data->seg = NULL;
        PMC_sub(SELF) = NULL;
    }

/*

=item C<STRING* get_string>

Get a STRING representing the bytecode for this code segment, suitable
for writing to disc and later loading via C<load_bytecode>.

=cut

*/

    STRING* get_string() {
        STRING *res;
        struct PackFile *pf;
        size_t size;
        opcode_t *packed;
        struct PackFile_ByteCode *seg;

        pf = PackFile_new(INTERP, 0);
        seg = PMC_sub(SELF)->seg;
        PackFile_add_segment(INTERP, &pf->directory,
                (struct PackFile_Segment *)seg);
        if (seg->const_table)
            PackFile_add_segment(INTERP, &pf->directory,
                    (struct PackFile_Segment *)seg->const_table);
        if (seg->debugs)
            PackFile_add_segment(INTERP, &pf->directory,
                    (struct PackFile_Segment *)seg->debugs);
        if (seg->fixups)
            PackFile_add_segment(INTERP, &pf->directory,
                    (struct PackFile_Segment *)seg->fixups);
        size = PackFile_pack_size(INTERP, pf) * sizeof(opcode_t);
        res = string_make_empty(INTERP, enum_stringrep_one, size);
        res->strlen = res->bufused = size;
        PackFile_pack(INTERP, pf, res->strstart);
        /* XXX leak the pf */
        return res;
    }

}

/*

=back

=head1 HISTORY

Initial version by leo 2003/01/16.

=cut

*/

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
 * vim: expandtab shiftwidth=4:
*/
