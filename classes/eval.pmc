/*
Copyright: 2001-2003 The Perl Foundation.  All Rights Reserved.
$Id$

=head1 NAME

classes/eval.pmc - Dynamic code evaluation

=head1 DESCRIPTION

C<Eval> extends C<Closure> to provide C<eval>-like dynamic code
evaluation and execution.

=head2 Methods

=over 4

=cut

*/

#include "parrot/parrot.h"

static void
clear_fixups(Interp* interpreter, PMC* self)
{
    opcode_t i, ci;
    struct PackFile_ByteCode *seg;
    struct PackFile_FixupTable *ft;
    struct PackFile_ConstTable *ct;
    PMC *sub;

    seg = PMC_sub(self)->seg;
    if (!seg)
        return;
    ft = seg->fixups;
    if (!ft)
        return;
    ct = seg->const_table;
    if (!ct)
        return;
    for (i = 0; i < ft->fixup_count; i++) {
        switch (ft->fixups[i]->type) {
            case enum_fixup_sub:
                ci = ft->fixups[i]->offset;
                sub = ct->constants[ci]->u.key;
                VTABLE_destroy(interpreter, sub);
                ct->constants[ci]->u.key = NULL;
                ft->fixups[i]->type = 0;
        }
    }
}

static PMC*
get_sub(Interp* interpreter, PMC* self, int idx)
{
    opcode_t i, n, ci;
    struct PackFile_ByteCode *seg;
    struct PackFile_FixupTable *ft;
    struct PackFile_ConstTable *ct;
    PMC *sub;

    seg = PMC_sub(self)->seg;
    if (!seg)
        return PMCNULL;
    ft = seg->fixups;
    if (!ft)
        return PMCNULL;
    ct = seg->const_table;
    if (!ct)
        return PMCNULL;
    for (i = n = 0; i < ft->fixup_count; i++) {
        switch (ft->fixups[i]->type) {
            case enum_fixup_sub:
                if (n++ != idx)
                    continue;
                ci = ft->fixups[i]->offset;
                sub = ct->constants[ci]->u.key;
                return sub;
        }
    }
    return PMCNULL;
}

static void
mark_subs(Interp* interpreter, PMC* self)
{
    opcode_t i, ci;
    struct PackFile_ByteCode *seg;
    struct PackFile_FixupTable *ft;
    struct PackFile_ConstTable *ct;
    PMC *sub;

    seg = PMC_sub(self)->seg;
    if (!seg)
        return;
    ft = seg->fixups;
    if (!ft)
        return;
    ct = seg->const_table;
    if (!ct)
        return;
    for (i = 0; i < ft->fixup_count; i++) {
        switch (ft->fixups[i]->type) {
            case enum_fixup_sub:
                ci = ft->fixups[i]->offset;
                sub = ct->constants[ci]->u.key;
                pobject_lives(interpreter, (PObj*)sub);
        }
    }
}

pmclass Eval extends Closure need_ext {

    void init() {
        parrot_sub_t sub_data;
        SUPER();
        sub_data = PMC_sub(SELF);
        PObj_custom_mark_destroy_SETALL(SELF);
        sub_data->seg = NULL;
    }

    void destroy() {
        /*
         * If the compiled code contained any .sub (or .pcc.sub)
         * subroutines, these subs got installed in the globals
         * during compiling this bytecode segment.
         *
         * These globals still exist, calling them will segfault
         * as the segment is destroyed now.
         *
         * TODO walk the fixups for this segment, locate globals
         *      and nullify the Sub PMC.
         * This probably needs a pointer into the globals.
         */
        parrot_sub_t sub_data;
        struct PackFile_Segment *seg;
        struct PackFile_ByteCode *cur_cs;

        clear_fixups(INTERP, SELF);
        sub_data = PMC_sub(SELF);

        if (!sub_data)
            return;
        cur_cs = sub_data->seg;
        if (!cur_cs)
            return;

        if (cur_cs->const_table)
            PackFile_ConstTable_clear(INTERP, cur_cs->const_table);
        cur_cs->const_table = NULL;
        seg = (struct PackFile_Segment *)cur_cs->debugs;
        if (seg)
            PackFile_Segment_destroy(INTERP, seg);
        cur_cs->debugs = NULL;
        if (cur_cs->fixups)
            PackFile_FixupTable_clear(INTERP, cur_cs->fixups);
        cur_cs->fixups = NULL;
        seg = (struct PackFile_Segment *)cur_cs;
        PackFile_Segment_destroy(INTERP, seg);
        sub_data->seg = NULL;
        PMC_sub_ASSIGN(SELF, NULL);
    }

    void mark() {
        mark_subs(INTERP, SELF);
    }

/*

=item C<STRING* get_string>

Get a STRING representing the bytecode for this code segment, suitable
for writing to disc and later loading via C<load_bytecode>.

=cut

*/

    STRING* get_string() {
        STRING *res;
        struct PackFile *pf;
        size_t size, aligned_size;
        opcode_t *packed;
        struct PackFile_ByteCode *seg;

        pf = PackFile_new(INTERP, 0);
        seg = PMC_sub(SELF)->seg;
        PackFile_add_segment(INTERP, &pf->directory,
                (struct PackFile_Segment *)seg);
        if (seg->const_table)
            PackFile_add_segment(INTERP, &pf->directory,
                    (struct PackFile_Segment *)seg->const_table);
        if (seg->debugs)
            PackFile_add_segment(INTERP, &pf->directory,
                    (struct PackFile_Segment *)seg->debugs);
        if (seg->fixups)
            PackFile_add_segment(INTERP, &pf->directory,
                    (struct PackFile_Segment *)seg->fixups);
        if (seg->pic_index)
            PackFile_add_segment(INTERP, &pf->directory,
                    (struct PackFile_Segment *)seg->pic_index);
        size = PackFile_pack_size(INTERP, pf) * sizeof(opcode_t);
        /*
         * work around packfile bug:
         * as far as I have checked it the story is:
         * - PackFile_pack_size() assumes 16 byte alignment but doesn't
         *   have the actual start of the code (packed)
         * - PackFile_pack() uses 16 bye alignment relative to the start
         *   of the code, which isn't really the same
         * Therefore align code at 16, which should give the desired
         * effect
         */    
        aligned_size = size + 15;
        res = string_make_empty(INTERP, enum_stringrep_one, aligned_size);
        res->strlen = res->bufused = size;
        if ((size_t)res->strstart & 0xf) {
            LVALUE_CAST(char*,res->strstart) += 
                16 - ((size_t)res->strstart & 0xf);
        }
        PackFile_pack(INTERP, pf, res->strstart);
        /* now remove all segments from directory again and destroy
         * the packfile
         */
        pf->directory.num_segments = 0;
        PackFile_destroy(INTERP, pf);
        return res;
    }

/*

=item C<PMC *get_pmc_keyed_int(INTVAL key)>

Returns the Sub PMC of the element at index C<key> or PMCNULL. 

=cut

*/

    PMC* get_pmc_keyed_int (INTVAL key) {
        return get_sub(INTERP, SELF, key);
    }

/*

=item C<void freeze(visit_info *info)>

Archives the evaled code

=item C<void thaw(visit_info *info)>

Unarchives the code.

=item C<void thawfinish(visit_info *info)>

Final code fixup after thawing.

=cut

*/

    void freeze(visit_info *info) {
        IMAGE_IO *io = info->image_io;
        STRING *packed = SELF.get_string();
        io->vtable->push_string(INTERP, io, packed);
        SUPER(info);
    }

    void thaw(visit_info *info) {
        IMAGE_IO *io = info->image_io;
        struct PackFile *pf;
        STRING *packed;
        size_t i;
        struct PackFile_Segment *seg;
        struct Parrot_sub * sub;

        packed = io->vtable->shift_string(INTERP, io);
        SUPER(info);
        sub = PMC_sub(SELF);
        pf = PackFile_new(INTERP, 0);
        if (!PackFile_unpack(INTERP, pf, packed->strstart, packed->strlen))
            real_exception(INTERP, NULL, E_IOError,
                    "couldn't unpack packfile");
        fixup_subs(INTERP, pf->cur_cs, PBC_PBC, SELF);
        for (i = 0; i < pf->directory.num_segments; ++i) {
            seg = pf->directory.segments[i];
            if (seg->type == PF_BYTEC_SEG) {
                PMC_sub(SELF)->seg = (struct PackFile_ByteCode *)seg;
                break;
            }
        }
        pf->directory.num_segments = 0;
        PackFile_destroy(INTERP, pf);
    }

    void thawfinish(visit_info *info) {
        struct Parrot_sub * sub = PMC_sub(SELF);
        struct PackFile_ByteCode *seg = sub->seg;
        /* XXX why - maybe somewhere interp->code is
         * used instead of pf->cur_cs
         */
        sub->address = seg->base.data;
        sub->end = sub->address + seg->base.size;
    }

}

/*

=back

=head1 HISTORY

Initial version by leo 2003/01/16.

=cut

*/

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
 * vim: expandtab shiftwidth=4:
*/
