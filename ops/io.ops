/*
** io.ops
*/

VERSION = PARROT_VERSION;

=head1 NAME

io.ops

=cut

=head1 DESCRIPTION

Parrot's IO API

=cut


###############################################################################

=head2 Parrot IO API Operations


=over 4

=cut


########################################

=item B<close>(in PMC)

Close IO object $1

=cut

inline op close(in PMC) :base_io {
  PIO_close(interpreter, $1);
  goto NEXT();
}

########################################

=item B<fdopen>(out PMC, in INT, in STR)

Create ParrotIO object in $1 as a copy of file descriptor $2.

XXX: integral file descriptors may not exist outside of the UNIX
     platform.  This op needs work.

=cut

inline op fdopen(out PMC, in INT, in STR) :filesys_open {
  /* These char * need to go away soon */
  const char * mode;
  mode = string_to_cstring(interpreter, $3);

  $1 = PIO_fdopen(interpreter, NULL, (PIOHANDLE)$2, mode);
  if (!$1) {
    $1 = pmc_new(interpreter, enum_class_PerlUndef);
  }
  /* string_cstring_free(mode); */
  /* TODO all results from string_to_cstring() need freeing
     but this generates ugly warnings WRT discarding the const
     qualifier -lt
   */
  goto NEXT();
}

=item B<getfd>(out INT, in PMC)

Get the file descriptor out of the ParrotIO object $2 and store it in $1

XXX: integral file descriptors may not exist outside of the UNIX
     platform.

=cut

inline op getfd(out INT, in PMC) :advanced_io {
  $1 = (INTVAL)PIO_getfd(interpreter, $2);
  goto NEXT();
}

=item B<getstdin>(out PMC)

Create a new ParrotIO object for the stdin file descriptor and
store it in $1

=item B<getstdout>(out PMC)

Create a new ParrotIO object for the stdout file descriptor and
store it in $1

=item B<getstderr>(out PMC)

Create a new ParrotIO object for the stderr file descriptor and
store it in $1

=cut

inline op getstdin(out PMC) :base_io {
  $1 = PIO_STDIN(interpreter);
  goto NEXT();
}

inline op getstdout(out PMC) :base_io {
  $1 = PIO_STDOUT(interpreter);
  goto NEXT();
}

inline op getstderr(out PMC) :base_io {
  $1 = PIO_STDERR(interpreter);
  goto NEXT();
}

#########################################

=item B<pioctl>(out INT, in PMC, in INT, in INT)

Perform an operation an an IO object. This is a general purpose
hook for setting various flags, modes, etc.
Examples: setting the record seperator or setting the buffering

=cut

inline op pioctl(out INT, in PMC, in INT, in INT) :advanced_io {
  $1 = PIO_pioctl(interpreter, $2, $3, $4);
  goto NEXT();
}


#########################################

=item B<open>(out PMC, in STR, in STR)

Open URL (file, address, database, in core image) named $2 with
Perl style mode string in $3 and create an IO object in $1.

=item B<open>(out PMC, in STR)

Open URL (file, address, database, in core image) named $2 with
read/write mode and create an IO object in $1.

=cut

inline op open(out PMC, in STR, in STR) :filesys_open {
  /* These char * need to go away soon */
  const char * path, * mode;

  path = string_to_cstring(interpreter, $2);
  mode = string_to_cstring(interpreter, $3);

  $1 = PIO_open(interpreter, NULL, path, mode);
  /* string_cstring_free(mode); */
  /* string_cstring_free(path); */
  if(!$1 || !PMC_struct_val($1)) {
    $1 = pmc_new(interpreter, enum_class_PerlUndef);
  }
  goto NEXT();
}

inline op open(out PMC, in STR) :filesys_open {
  /* These char * need to go away soon */
  const char * path;

  path = string_to_cstring(interpreter, $2);

  $1 = PIO_open(interpreter, NULL, path, "+<");
  /* string_cstring_free(path); */
  if(!$1) {
    $1 = pmc_new(interpreter, enum_class_PerlUndef);
  }
  goto NEXT();
}

########################################

=item B<print>(in INT)

=item B<print>(in NUM)

=item B<print>(in PMC)

=item B<print>(in STR)

Print $1 to standard output.

=cut

inline op print(in INT) :base_io {
  PIO_printf(interpreter, INTVAL_FMT, (INTVAL)$1);
  goto NEXT();
}

inline op print(in NUM) :base_io {
  PIO_printf(interpreter, "%f", (double)$1);
  goto NEXT();
}

op print(in STR) :base_io {
  STRING *s = $1;
  if (s && string_length(interpreter, s)) {
    PIO_putps(interpreter, PIO_STDOUT(interpreter), s);
  }
  goto NEXT();
}

op print(in PMC) :base_io {
  PMC *p = $1;
  STRING *s = (VTABLE_get_string(interpreter, p));
  if (s) {
    PIO_putps(interpreter, PIO_STDOUT(interpreter), s);
  }
  goto NEXT();
}

op write(in PMC) :base_io {
  PMC *p = $1;
  STRING *s = (VTABLE_get_string(interpreter, p));
  if (s) {
    PIO_write(interpreter, PIO_STDOUT(interpreter), s->strstart, s->bufused);
  }
  goto NEXT();
}
##########################################

=item B<printerr>(in INT)

=item B<printerr>(in NUM)

=item B<printerr>(in STR)

=item B<printerr>(in PMC)

Print $1 to standard error.

=cut

op printerr(in INT) :base_io {
  PIO_eprintf(interpreter, INTVAL_FMT, $1);
  goto NEXT();
}

op printerr(in NUM) :base_io {
  PIO_eprintf(interpreter, "%f", (double)$1);
  goto NEXT();
}

op printerr(in STR) :base_io {
  STRING *s = $1;
  if (s && string_length(interpreter, s)) {
    PIO_putps(interpreter, PIO_STDERR(interpreter), s);
  }
  goto NEXT();
}

op printerr(in PMC) :base_io {
  PMC *p = $1;
  STRING *s = (VTABLE_get_string(interpreter, p));
  if (s) {
    PIO_putps(interpreter, PIO_STDOUT(interpreter), s);
  }
  goto NEXT();
}

##########################################

=item B<print>(in PMC, in INT)

=item B<print>(in PMC, in NUM)

=item B<print>(in PMC, in STR)

=item B<print>(in PMC, in PMC)

Print $2 on the IO stream object $1.

=cut

op print(in PMC, in INT) :base_io {
  if ($1) {
    STRING *s = Parrot_sprintf_c(interpreter, INTVAL_FMT, $2);
    PIO_putps(interpreter, $1, s);
  }
  else {
    /* Handle error here */
  }
  goto NEXT();
}

op print(in PMC, in NUM) :base_io {
  if ($1) {
    STRING *s = Parrot_sprintf_c(interpreter, "%f", (double)$2);
    PIO_putps(interpreter, $1, s);
  }
  else {
    /* Handle error here */
  }
  goto NEXT();
}

op print(in PMC, in STR) :base_io {
  if ($2 && $1) {
    PIO_putps(interpreter, $1, $2);
  }
  else {
    /* Handle error here */
  }
  goto NEXT();
}

op print(in PMC, in PMC) :base_io {
  if ($2 && $1) {
    STRING *s = VTABLE_get_string(interpreter, $2);
    PIO_putps(interpreter, $1, s);
  }
  else {
    /* Handle error here */
  }
  goto NEXT();
}

##########################################

=item B<read>(out STR, in INT)

Read up to N bytes from standard input stream
If stream is linebuffered, will return at EOL, for
files it will read MIN(MAX(avail, N), 65535) bytes.
Warning: This is a quick hack.

=item B<read>(out STR, in PMC, in INT)

Read up to N bytes from IO PMC stream.
If stream is linebuffered, will return at EOL, for
files it will read MIN(MAX(avail, N), 65535) bytes.
Warning: This is a quick hack.

=cut

op read(out STR, in INT) :base_io {
  UINTVAL n;
  $1 = PIO_reads(interpreter, PIO_STDIN(interpreter), (size_t)$2);
  goto NEXT();
}

op read(out STR, in PMC, in INT) :base_io {
  $1 = PIO_reads(interpreter, $2, (size_t)$3);
  goto NEXT();
}

=item B<readline>(out STR, in PMC)

Read a line up to EOL from filehandle $2.
This switches the filehandle to linebuffer-mode.

If for some reason the line's longer than 64K you get only 64K

=cut

inline op readline(out STR, in PMC) :base_io {
  size_t len = 0;
  opcode_t * resume = expr NEXT();
  /* experimental error handling, mainly for t/pmc/io_5.pasm */
  int ok = VTABLE_get_bool(interpreter, $2);
  $1 = NULL;
  if (!ok)
      real_exception(interpreter, resume, PIO_ERROR,
          "File not found");

  if ($2) {
    PIO_setlinebuf(interpreter, $2);
    $1 = PIO_reads(interpreter, $2, 0);
  }
  goto NEXT();
}

##########################################

=item B<peek>(out STR)

Returns the next byte from standard input, but does not
remove it from the stream.

=item B<peek>(out STR, in PMC)

Reads the next byte from an IO PMC, but does not
remove it from the stream.

=cut

op peek(out STR) :base_io {
  STRING **s = &$1;

  *s = NULL;
  PIO_peek(interpreter, PIO_STDIN(interpreter), s);
  goto NEXT();
}

op peek(out STR, in PMC) :base_io {
  STRING **s = &$1;

  *s = NULL;
  PIO_peek(interpreter, $2, s);
  goto NEXT();
}

##########################################

=item B<stat>(out INT, in STR, in INT)

Stat the file. Return stat element $3 for file $2 into $1. The queryable
items currently are:

 EXISTS     0
 FILESIZE   1
 ISDIR      2
 ISDEV      3
 CREATETIME 4 (Time file was created)
 ACCESSTIME 5 (Time file was last accessed)
 MODIFYTIME 6 (Time file data was changed)
 CHANGETIME 7 (Time file metadata was changed)
 BACKUPTIME 8 (Time of last backup)
 UID        9
 GID        10


=cut

op stat(out INT, in STR, in INT) {
  $1 = Parrot_stat_info_intval(interpreter, $2, $3);
  goto NEXT();
}


##########################################

=item B<seek>(in PMC, in INT, in INT)

seek:
Set file position to offset $2 on IO stream $1. 'whence' is
indicated by the value in $3.

=item B<seek>(in PMC, in INT, in INT, in INT)

64bit seek:
Set file position to offset ($2 << 32 | $3) on IO stream $1. 'whence' is
indicated by the value in $4. This allows 64-bit seeks with only 32-bit
INTVALS.

=cut

op seek(in PMC, in INT, in INT) :base_io {
  if ($1) {
    if (PIO_seek(interpreter, $1, PIO_make_offset($2), $3) < 0) {
      /* XXX: seek error */
    }
  }
  goto NEXT();
}

op seek(in PMC, in INT, in INT, in INT) :base_io {
  if ($1) {
    if (PIO_seek(interpreter, $1, PIO_make_offset32($2, $3), $4) < 0) {
      /* XXX: seek error */
    }
  }
  goto NEXT();
}

=item B<tell>(out INT, in PMC)

tell:
Get the current file position of stream $2 and store it in $1.
On systems where INTVAL is 32bit the result will be truncated if the
position is beyond 2 GiB

=item B<tell>(out INT, out INT, in PMC)

64bit tell:
Get the current file positon of stream $3 in two parts of 32-bit each
($1 = pos >> 32, $2 = pos & 0xffffffff).

=cut

op tell(out INT, in PMC) :base_io {
  if ($2) {
    $1 = (INTVAL)PIO_tell(interpreter, $2);
  }
  goto NEXT();
}

op tell(out INT, out INT, in PMC) :base_io {
  if ($3) {
    PIOOFF_T pos;
    pos = PIO_tell(interpreter, $3);
    $1 = (INTVAL)(pos >> 32);
    $2 = (INTVAL)(pos & 0xffffffff);
  }
  goto NEXT();
}

########################################

=item B<socket>(out PMC, in INT, in INT, in INT)

=item B<sockaddr>(out STR, in INT, in STR)

=item B<connect>(out INT, in PMC, in STR)

=item B<recv>(out INT, in PMC, in STR)

=item B<send>(out INT, in PMC, in STR)

=item B<poll>(out INT, in PMC, in INT, in INT, in INT)

=cut

op socket(out PMC, in INT, in INT, in INT) :base_network {
  $1 = PIO_socket(interpreter, $2, $3, $4);
  if(!$1) {
    $1 = pmc_new(interpreter, enum_class_PerlUndef);
  }
  goto NEXT();
}

op sockaddr(out STR, in INT, in STR) :base_network {
    $1 = PIO_sockaddr_in(interpreter, (unsigned short)$2, $3);
    goto NEXT();
}

op connect(out INT, in PMC, in STR) :base_network {
    $1 = (INTVAL)PIO_connect(interpreter, $2, $3);
    goto NEXT();
}

op recv(out INT, in PMC, in STR) :base_network {
    $1 = (INTVAL)PIO_recv(interpreter, $2, &($3));
    goto NEXT();
}

op send(out INT, in PMC, in STR) :base_network {
    $1 = (INTVAL)PIO_send(interpreter, $2, $3);
    goto NEXT();
}

op poll(out INT, in PMC, in INT, in INT, in INT) :base_network {
    $1 = (INTVAL)PIO_poll(interpreter, $2, $3, $4, $5);
    goto NEXT();
}

########################################

=back

=cut


###############################################################################

=head1 COPYRIGHT

Copyright (C) 2001-2004 The Perl Foundation.  All rights reserved.

=head1 LICENSE

This program is free software. It is subject to the same license
as the Parrot interpreter itself.

=cut

