{"version":1,"ops":[{"type":3,"author":{"id":"aef4977f5ea786238d7c9581a2f192f4adc3f39d"},"timestamp":1290488970,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDI0NjU=","github-url":"https://github.com/parrot/parrot/issues/244#issuecomment-3502465"},"message":"\u003cp\u003e\nI set this ticket up as a task for GCI 2010. I'm hoping some intrepid young student can come up with a good list of information and recommendations for us to follow. If we can't make some kind of decision after that, we need to close this old ticket.\n\u003c/p\u003e","files":null},{"type":3,"author":{"id":"aef4977f5ea786238d7c9581a2f192f4adc3f39d"},"timestamp":1291433302,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDI0NjY=","github-url":"https://github.com/parrot/parrot/issues/244#issuecomment-3502466"},"message":"From GCI student Atanas:\n- LIBHASHISH - \u003ca href=\"http://libhashish.sourceforge.net/\"\u003ehttp://libhashish.sourceforge.net/\u003c/a\u003e\n- CMPH - \u003ca href=\"http://cmph.sourceforge.net/\"\u003ehttp://cmph.sourceforge.net/\u003c/a\u003e\n- Mhash - \u003ca href=\"http://mhash.sourceforge.net/\"\u003ehttp://mhash.sourceforge.net/\u003c/a\u003e\n- LSHKIT - \u003ca href=\"http://lshkit.sourceforge.net/\"\u003ehttp://lshkit.sourceforge.net/\u003c/a\u003e\n\n\u003e I checked some hashing libraries and I chose the following:\n\u003e LIBHASHISH\n\u003e - Build-in key support for char arrays (strings) and uint_{8,16,32} types and support for own (possible complex) key data types\n\u003e - Support rbtree's as collision strategy instead of bucked lists (avoid worst case O(n) scenario)\n\u003e - Dynamic or manual adjustable table size (reordering if proportion entries/table_size is unfavorable)\n\u003e - Build as an static or dynamic library (.a and .so)\n\u003e - Iterator support (equivalent to ruby's hash.each() method)\n\u003e - Thread clean - fine-grained lock mechanisms (mutex locks, reader writer locks, ...)\n\u003e - Bloom filter implementation\n\u003e - Many built-in hash algorithms (from trivial algorithms till cryptographic ones)\n\u003e - Architecture clean - runs on 32bit machines as well as 64bit machines\n\u003e - As lightweight as possible - no bloated code\n\u003e - Makefile test target plus benchmark applications for comparing the different hashing algorithm\n\u003e - Dual licensed under the GNU General Public and BSD License\n\u003e   Website is \u003ca   href=\"http://libhashish.sourceforge.net/\"\u003ehttp://libhashish.sourceforge.net/\u003c/a\u003e. I think this is the best hashing library for your project.\n\nSo there's that input. I'm going to reassign this RFC to cotto while we figure out if we want to move to a new hashing library and, if so, which one.\n\n(Fixing formatting -benabik)","files":null},{"type":3,"author":{"id":"18879c4084549ff2c7022dc058bcf4940fadd0f2"},"timestamp":1296703678,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDI0Njc=","github-url":"https://github.com/parrot/parrot/issues/244#issuecomment-3502467"},"message":"\u003cp\u003e\nLSHKIT is for locality sensitive hashing, CMPH for minimal perfect hashing and Mhash for cryptographic hash functions. That's not what we need.\n\u003c/p\u003e\n\n\u003cp\u003e\nlibghthash \u003ca   href=\"http://www.ipd.bth.se/ska/sim_home/libghthash.html\"\u003e\u003cspan class=\"icon\"\u003eÂ \u003c/span\u003ehttp://www.ipd.bth.se/ska/sim_home/libghthash.html\u003c/a\u003e would be an example for a useful hash table library.\n\u003c/p\u003e\n\n\u003cp\u003e\nBut I don't think we could gain much by using an external library. If we want to optimize our current implementation, I'd suggest a dead simple hash table with open addressing and linear probing. That would give us at most one dcache miss for practically all reads if we make sure that the fill factor stays low enough by rehashing.\n\u003c/p\u003e\n\n\u003cp\u003e\nSuch a hash table would only require 2 words per entry vs. 4 words per entry for our current chained implementation. So even if we limit the fill factor to 50%, we wouldn't need more memory than now.\n\u003c/p\u003e\n\n\u003cp\u003e\nWe'd need two additional bits to mark occupied and deleted entries. For pointer keys or values we could store them in the low bits of the pointers. For integer keys and values, we'd need an additional array for those flags.\n\u003c/p\u003e","files":null},{"type":3,"author":{"id":"646f0669ead6eaf64196bebf3884a5eff162357a"},"timestamp":1327515435,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM2NTU3OTc=","github-url":"https://github.com/parrot/parrot/issues/244#issuecomment-3655797"},"message":"I was poking around for information on hash libraries and came across this comparison page: http://attractivechaos.wordpress.com/2008/08/28/comparison-of-hash-table-libraries/\n\nOf particular interest to me is the \"[khash (C)](http://attractivechaos.awardspace.com/khash.h.html)\" line in the table, which is his one include file hash library that allows for type specific hashes in C (via preprocessor fun).  It seems to perform very well in both space and time.  It's MIT licensed, so I don't know if that would be a problem to include in parrot.","files":null},{"type":3,"author":{"id":"aef4977f5ea786238d7c9581a2f192f4adc3f39d"},"timestamp":1336523651,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDU1OTAyNTM=","github-url":"https://github.com/parrot/parrot/issues/244#issuecomment-5590253"},"message":"This task is too open-ended and vague to be actionable. We've clearly looked through several hashing libraries and listed the results of those inquiries above and in other places. The questions to be pursued now are: Do we want to use a hashing library internally instead of our hand-rolled variants, and what exactly are the use-cases we want it for? I'm closing this ticket since the \"discovery phase\" is over now. We can pursue more concrete issues later as necessary.","files":null},{"type":4,"author":{"id":"aef4977f5ea786238d7c9581a2f192f4adc3f39d"},"timestamp":1336523651,"metadata":{"github-id":"MDExOkNsb3NlZEV2ZW50MTUwNDYzNzI="},"status":2}]}