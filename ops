{"version":1,"ops":[{"type":3,"author":{"id":"86141a663c2eb7543d1a51ec6253a1d54de912fd"},"timestamp":1235063709,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDMwMTA=","github-url":"https://github.com/parrot/parrot/issues/401#issuecomment-3503010"},"message":"\u003cp\u003e\nreported by leto in irc: \u003ca   href=\"http://irclog.perlgeek.de/parrot/2009-02-18#i_920220\"\u003e\u003cspan class=\"icon\"\u003e \u003c/span\u003ehttp://irclog.perlgeek.de/parrot/2009-02-18#i_920220\u003c/a\u003e\n\u003c/p\u003e","files":null},{"type":3,"author":{"id":"86141a663c2eb7543d1a51ec6253a1d54de912fd"},"timestamp":1235083428,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDMwMTE=","github-url":"https://github.com/parrot/parrot/issues/401#issuecomment-3503011"},"message":"\u003cp\u003e\nCurrent situation:\n\u003c/p\u003e\n\n\u003cpre class=\"wiki\"\u003e  $P1=new [\"Complex\"]\n  $P2=new [\"Complex\"]\n  $P1=\"NaN\"\n  $P2=\"i\"\n  $P2 = mul $P1, $P2\n  say $P2\n\u003c/pre\u003e\u003cp\u003e\nThe result is \"NaNi\", because both parts are treated individually and the plus is dropped from i in the printout.\n\u003c/p\u003e\n\n\u003cp\u003e\nNaN in the real part will not harm the calculation if the\nimaginary part in non-NaN: NaN+i * 1-2i = NaN-2i\n\u003c/p\u003e\n\n\u003cp\u003e\nThe string representation of a complex is sprintf(\"%vg%+vgi\", re, im)\nSo NaN-2i is \"NaN-2i\" and NaN+i is printed as \"NaNi\"\n\u003c/p\u003e\n\n\u003cp\u003e\nSo NaN * 1i = NaNi\n\u003c/p\u003e\n\n\u003cp\u003e\nThe proposed is the represent a complex with either the real\nor imaginary part of NaN as \"NaN\", and do not seperate them.\n\u003c/p\u003e","files":null},{"type":3,"author":{"id":"86141a663c2eb7543d1a51ec6253a1d54de912fd"},"timestamp":1235301262,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDMwMTI=","github-url":"https://github.com/parrot/parrot/issues/401#issuecomment-3503012"},"message":"10370 byte attachment from rurban\nat http://trac.parrot.org/parrot/raw-attachment/ticket/358/tt358-complex-nan.patch\n\n# ```Index: parrot-svn/src/pmc/complex.pmc\n\n--- parrot-svn.orig/src/pmc/complex.pmc\n+++ parrot-svn/src/pmc/complex.pmc\n@@ -77,6 +77,12 @@ complex_parse_string(PARROT_INTERP, FLOA\n         while (*t \u003e= '0' \u0026\u0026 *t \u003c= '9')\n             t++;\n     }\n-    /\\* handle real NaN */\n-    if (*t == 'N' \u0026\u0026 *(t+1) == 'a' \u0026\u0026 *(t+2) == 'N') {\n-        t++;\n-        t++;\n-        t++;\n-    }\n  \n   /\\* save the length of the real part _/\n   first_num_length = t - first_num_offset;\n  @@ -128,6 +134,12 @@ complex_parse_string(PARROT_INTERP, FLOA\n               while (_t \u003e= '0' \u0026\u0026 *t \u003c= '9')\n                   t++;\n           }\n-            /\\* handle imag NaN */\n-            if (*t == 'N' \u0026\u0026 *(t+1) == 'a' \u0026\u0026 *(t+2) == 'N') {\n-                t++;\n-                t++;\n-                t++;\n- ```\n         }\n  \n       /* save the length of the imaginary part */\n       second_num_length = t - second_num_offset;\n  ```\n  \n  @@ -436,7 +448,11 @@ Returns true if the complex number is no\n       FLOATVAL re, im;\n       GET_ATTR_re(INTERP, SELF, re);\n       GET_ATTR_im(INTERP, SELF, im);\n-        return Parrot_sprintf_c(INTERP, \"%vg%+vgi\", re, im);\n-        /\\* TT #358 NaN+i =\u003e NaN (not NaNi), 1+NaNi =\u003e NaN (not 1+NaNi) */\n-        if (isnan(im) || isnan(re))\n-            return Parrot_sprintf_c(INTERP, \"NaN\");\n-        else\n- ```\n         return Parrot_sprintf_c(INTERP, \"%vg%+vgi\", re, im);\n  ```\n  \n   }\n  \n   VTABLE INTVAL get_bool() {\n  @@ -727,6 +743,7 @@ Adds C\u003cvalue\u003e to the complex number, pla\n  \n  ```\n   GET_ATTR_re(INTERP, SELF, re);\n   GET_ATTR_im(INTERP, SELF, im);\n  ```\n  \n  +\n       SET_ATTR_re(INTERP, dest, re + VTABLE_get_number(INTERP, value));\n       SET_ATTR_im(INTERP, dest, im);\n\n@@ -743,6 +760,7 @@ Adds C\u003cvalue\u003e to the complex number, pla\n\n```\n     GET_ATTR_re(INTERP, SELF, re);\n     GET_ATTR_im(INTERP, SELF, im);\n```\n\n+\n         SET_ATTR_re(INTERP, dest, re + value);\n         SET_ATTR_im(INTERP, dest, im);\n\n@@ -816,6 +834,7 @@ Subtracts C\u003cvalue\u003e from the complex numb\n\n```\n     GET_ATTR_re(INTERP, SELF, re);\n     GET_ATTR_im(INTERP, SELF, im);\n```\n\n+\n         SET_ATTR_re(INTERP, dest, re - VTABLE_get_number(INTERP, value));\n         SET_ATTR_im(INTERP, dest, im);\n\n@@ -832,6 +851,7 @@ Subtracts C\u003cvalue\u003e from the complex numb\n\n```\n     GET_ATTR_re(INTERP, SELF, re);\n     GET_ATTR_im(INTERP, SELF, im);\n```\n\n+\n         SET_ATTR_re(INTERP, dest, re - value);\n         SET_ATTR_im(INTERP, dest, im);\n\n@@ -999,7 +1019,7 @@ Throws divide by zero exception if divis\n\n =cut\n\n-TODO: for better fp precision\n+For better fp precision:\n http://docs.sun.com/source/806-3568/ncg_goldberg.html\n (a+ib)/(c+id) =\n     (a + b(d/c)) / (c + d(d/c)) + i(b - a(d/c)) / (c + d(d/c)) if |d|\u003c|c|\n@@ -1008,7 +1028,7 @@ http://docs.sun.com/source/806-3568/ncg_\n */\n\n```\n MULTI PMC *divide(Complex value, PMC *dest) {\n```\n-        FLOATVAL mod, re, im;\n- ```\n     FLOATVAL re, im;\n   FLOATVAL self_re, self_im, val_re, val_im;\n  \n   complex_check_divide_zero(INTERP, value);\n  ```\n  \n  @@ -1019,17 +1039,28 @@ http://docs.sun.com/source/806-3568/ncg_\n       GET_ATTR_re(INTERP, value, val_re);\n       GET_ATTR_im(INTERP, value, val_im);\n- ```\n     /* a little speed optimisation: cache an intermediate number;\n  ```\n\n## \\-            I'm not sure the compiler does this */\n\n```\n     if (self_im == 0.0 \u0026\u0026 val_im == 0.0) {\n         re = self_re / val_re;\n         im = 0.0;\n     }\n```\n-        else if (abs(val_im) \u003c abs(val_re)) {\n-            /\\* a: self_re, b: self_im, c: val_re, d: val_im */\n-            /\\* (a + b(d/c)) / (c + d(d/c)) + i(b - a(d/c)) / (c + d(d/c)) if |d|\u003c|c| */\n-            FLOATVAL mod;\n-            /\\* A little speed optimisation: cache intermediate numbers;\n-               I'm not sure the compiler does this */\n-            FLOATVAL d_c = val_im / val_re;\n-            mod = val_re + val_im \\* d_c;\n-            re  = (self_re + self_im \\* d_c) / mod;\n-            im  = (self_im - self_re \\* d_c) / mod;\n-        }\n       else {\n-            mod = (val_re \\* val_re + val_im \\* val_im);\n-            re  = (self_re \\* val_re + self_im \\* val_im) / mod;\n-            im  = (self_im \\* val_re - self_re \\* val_im) / mod;\n-            /\\* (b + a(c/d)) / (d + c(c/d)) + i(-a + b(c/d)) / (d + c(c/d)) if |d|\u003e=|c| */\n-            FLOATVAL mod;\n-            FLOATVAL c_d = val_re / val_im;\n-            mod = val_im + val_re \\* c_d;\n-            re  = (self_im + self_re \\* c_d) / mod;\n- ```\n         im  = (-self_re + self_im * c_d) / mod;\n   }\n  \n   SET_ATTR_re(INTERP, dest, re);\n  ```\n  \n  @@ -1096,12 +1127,21 @@ http://docs.sun.com/source/806-3568/ncg_\n           re = self_re / val_re;\n           im = 0.0;\n       }\n-        /\\* For better fp precision: */\n-        /\\* http://docs.sun.com/source/806-3568/ncg_goldberg.html */\n-        else if (abs(val_im) \u003c abs(val_re)) {\n-            FLOATVAL mod;\n-            FLOATVAL d_c = val_im / val_re;\n-            mod = val_re + val_im \\* d_c;\n-            re  = (self_re + self_im \\* d_c) / mod;\n-            im  = (self_im - self_re \\* d_c) / mod;\n-        }\n       else {\n-            /\\* a little speed optimisation: cache an intermediate number;\n-               I'm not sure the compiler does this */\n-            mod = (val_re \\* val_re + val_im \\* val_im);\n-            re  = (self_re \\* val_re + self_im \\* val_im) / mod;\n-            im  = (self_im \\* val_re - self_re \\* val_im) / mod;\n-            FLOATVAL mod;\n-            FLOATVAL c_d = val_re / val_im;\n-            mod = val_im + val_re \\* c_d;\n-            re  = (self_im + self_re \\* c_d) / mod;\n- ```\n         im  = (-self_re + self_im * c_d) / mod;\n   }\n  \n   SET_ATTR_re(INTERP, SELF, re);\n  ```\n  \n  @@ -1219,11 +1259,12 @@ Sets C\u003cdest\u003e to the absolute value of SE\n  */\n  \n  /*\n  +Straightforward:\n-  d = sqrt(re_re + im_im);\n-  TODO for better precision: hinted by vaxman according to \"Numerical Recipes\n-  in Fortran 77\", 2nd edition, Press, Vetterling, Teukolsky, Flannery,\n\n## \\-  Cambridge University Press, 2001, pp. 171ff:\n\n+For better precision: hinted by vaxman according to \"Numerical Recipes\n+in Fortran 77\", 2nd edition, Press, Vetterling, Teukolsky, Flannery,\n+Cambridge University Press, 2001, pp. 171ff:\n\n |a+ib|=|a|_sqrt(1+(b/a)__2), if |a|\u003e=|b|,\n        |b|_sqrt(1+(a/b)**2)  else.\n@@ -1234,7 +1275,14 @@ Sets C\u003cdest\u003e to the absolute value of SE\n         FLOATVAL re, im, d;\n         GET_ATTR_re(INTERP, SELF, re);\n         GET_ATTR_im(INTERP, SELF, im);\n-        d = sqrt(re_re + im_im);\n-        if (abs(re) \u003e= abs(im)) {\n-            FLOATVAL b_a = im/re;\n-            d = abs(re)_sqrt(1+b_a_b_a);\n-        }\n-        else {\n-            FLOATVAL a_b = re/im;\n-            d = abs(im)_sqrt(1+a_b_a_b);\n- ```\n     }\n  \n   dest = pmc_new(INTERP,\n       Parrot_get_ctx_HLL_type(INTERP, enum_class_Float));\n  ```\n  \n  @@ -1247,7 +1295,14 @@ Sets C\u003cdest\u003e to the absolute value of SE\n       FLOATVAL re, im, d;\n       GET_ATTR_re(INTERP, SELF, re);\n       GET_ATTR_im(INTERP, SELF, im);\n-        d = sqrt(re_re + im_im);\n-        if (abs(re) \u003e= abs(im)) {\n-            FLOATVAL b_a = im/re;\n-            d = abs(re)_sqrt(1+b_a_b_a);\n-        }\n-        else {\n-            FLOATVAL a_b = re/im;\n-            d = abs(im)_sqrt(1+a_b_a_b);\n- ```\n     }\n   pmc_reuse(INTERP, SELF, enum_class_Float, 0);\n   VTABLE_set_number_native(INTERP, SELF, d);\n  ```\n  \n   }\n  \n  # Index: parrot-svn/t/pmc/complex.t\n  \n  --- parrot-svn.orig/t/pmc/complex.t\n  +++ parrot-svn/t/pmc/complex.t\n  @@ -21,7 +21,7 @@ Tests the Complex PMC.\n   .include 'fp_equality.pasm'\n   .include \"iglobals.pasm\"\n-    plan(467)\n-    plan(483)\n  \n   string_parsing()\n   exception_malformed_string__real_part()\n  @@ -77,6 +77,7 @@ Tests the Complex PMC.\n   sech_of_complex_numbers()\n   csch_of_complex_numbers()\n   add_using_subclass_of_complex_bug_59630()\n-    test_nan()\n  \n   # END_OF_TESTS\n\n@@ -730,15 +731,17 @@ handler:\n\n```\n #XXX: can't do $P1.'$S2'()\n $P2 = $P1. $S2()\n```\n-    $S3 = sprintf \"%f%+fi\", $P2\n-    $S4 = sprintf \"%f%+fi\", $P2\n  \n   concat $S5, $S2, \" of \"\n   concat $S5, $S5, $S4\n-    concat $S5, $S5, \" \"\n-    concat $S5, $S5, $S3\n-    $I0 = cmp_str $S1, $S3\n-    $I0 = cmp_str $S1, $S4\n   $I0 = not $I0\n-    todo( $I0, $S4 )\n-    todo( $I0, $S5 )\n  .endm\n  \n  .sub ln_of_complex_numbers\n  @@ -1173,6 +1176,73 @@ todo:\n   .complex_op_is(\"-2-3i\", \"0.272549+0.040301i\", 'csch' )\n  .end\n\n+.macro op_float_test_is(op, c_arg, f_arg, result)\n-    c  = .c_arg\n-    f  = .f_arg\n-    set $S2, .op\n-    c2 = c. $S2(f, $P1)\n-    $S0 = sprintf \"%f%+fi\", c2\n-    $S1 = .result\n  +\n-    #is( $S0, $S1, $S1 )\n-    concat $S3, $S2, \" of \"\n-    concat $S3, $S3, $S0\n-    concat $S3, $S3, \" TT #358\"\n  +\n-    $I0 = cmp_str $S1, $S0\n-    $I0 = not $I0\n  +\n-    todo( $I0, $S3 )\n  +.endm\n  +\n  +.macro op_c_test_is(op, arg1, arg2, result)\n-    c  = .arg1\n-    c1 = .arg2\n-    set $S2, .op\n-    c2 = c. $S2(c1, $P1)\n-    $S0 = sprintf \"%f%+fi\", c2\n-    $S1 = .result\n-    #is( $S0, $S1, $S1 )\n-    concat $S3, $S2, \" of \"\n-    concat $S3, $S3, $S0\n-    concat $S3, $S3, \" TT #358\"\n  +\n-    $I0 = cmp_str $S1, $S0\n-    $I0 = not $I0\n  +\n-    todo( $I0, $S3 )\n  +.endm\n  +\n  +# TT #358\n  +.sub test_nan\n-    .local pmc c, c1, c2, f\n-    c  = new ['Complex']\n-    c1 = new ['Complex']\n-    c2 = new ['Complex']\n-    f = new ['Float']\n-    set c, \"NaN + i\"\n-    is(c, 'NaN', \"parse NaN + i\")\n-    set c2, \"1.0-NaNi\"\n-    is(c2, 'NaN', \"parse 1.0-NaNi\")\n-    c2 = c.'multiply'($N1, 1.0)\n-    is(c2, 'NaN', \"mul NaN+i, 1.0\")\n  +\n-    .op_float_test_is( \"multiply\", \"NaN\", 1.0,   \"NaN\" )\n-    .op_float_test_is( \"multiply\", \"NaN+i\", \"NaN\", \"NaN\" )\n-    .op_float_test_is( \"multiply\", \"NaNi\",  1.0,   \"NaN\" )\n-    .op_c_test_is( \"multiply\", \"NaN+i\", \"0+NaNi\",   \"NaN\" )\n-    .op_c_test_is( \"add\", \"0+NaNi\", \"i\", \"NaN\" )\n-    .op_c_test_is( \"add\", \"i\", \"0+NaNi\", \"NaN\" )\n-    .op_c_test_is( \"subtract\", \"NaN\", \"i\", \"NaN\" )\n-    .op_c_test_is( \"subtract\", \"i\", \"NaN\", \"NaN\" )\n-    .op_c_test_is( \"pow\", \"NaN\", \"i\", \"NaN\" )\n-    .op_c_test_is( \"pow\", \"i\", \"NaN\", \"NaN\" )\n  +\n-    .complex_op_todo(\"NaN\", \"NaN\", 'ln',   \"TT #358\" )\n-    .complex_op_todo(\"NaN\", \"NaN\", 'sin',  \"TT #358\" )\n-    .complex_op_todo(\"NaN\", \"NaN\", 'csch', \"TT #358\" )\n  +.end\n  +\n  .sub add_using_subclass_of_complex_bug_59630\n     skip( 3, 'add using subclass of Complex - RT #59630' )\n     .return()\n\n```\n```","files":null},{"type":3,"author":{"id":"86141a663c2eb7543d1a51ec6253a1d54de912fd"},"timestamp":1235322862,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDMwMTM=","github-url":"https://github.com/parrot/parrot/issues/401#issuecomment-3503013"},"message":"\u003cp\u003e\nunfinished\n\u003c/p\u003e","files":null},{"type":3,"author":{"id":"2da6485217cbb88ff96be8f3dcc7f9ae44cf6bf0"},"timestamp":1250846118,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDMwMTQ=","github-url":"https://github.com/parrot/parrot/issues/401#issuecomment-3503014"},"message":"\u003cp\u003e\nThe code snippet\n\u003c/p\u003e\n\n\u003cpre class=\"wiki\"\u003e    $P1=new [\"Complex\"]\n    $P1=\"NaN\"\n\u003c/pre\u003e\u003cp\u003e\nnow gives the error\n\u003c/p\u003e\n\u003cpre class=\"wiki\"\u003eComplex: malformed string\ncurrent instr.: 'test_complex_nan' pc 21447 (t/pmc/complex.t:1170)\n\u003c/pre\u003e","files":null},{"type":3,"author":{"id":"2da6485217cbb88ff96be8f3dcc7f9ae44cf6bf0"},"timestamp":1250846805,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDMwMTU=","github-url":"https://github.com/parrot/parrot/issues/401#issuecomment-3503015"},"message":"\u003cpre class=\"wiki\"\u003e    $P1 = new [\"Complex\"]\n    $N0 = 'NaN'\n    set $P1, \"1 + i\"\n    $P1 += $N0\n    say $P1\n\u003c/pre\u003e\u003cp\u003e\nprints\n\u003c/p\u003e\n\u003cpre class=\"wiki\"\u003eNaN+1i\n\u003c/pre\u003e","files":null},{"type":3,"author":{"id":"0782f66a529ccd24e18226f5eebab20a90bea166"},"timestamp":1250848882,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDMwMTY=","github-url":"https://github.com/parrot/parrot/issues/401#issuecomment-3503016"},"message":"\u003cpre class=\"wiki\"\u003eOn Thu, Aug 20, 2009 at 10:26 PM, Parrot\u0026lt;parrot-tickets@lists.parrot.org\u0026gt; wrote:\n\u0026gt; #358: complex NaN\n\u0026gt; --------------------+-------------------------------------------------------\n\u0026gt;  Reporter:  rurban  |       Owner:  dukeleto\n\u0026gt;     Type:  bug     |      Status:  assigned\n\u0026gt;  Priority:  normal  |   Milestone:\n\u0026gt; Component:  core    |     Version:\n\u0026gt;  Severity:  medium  |    Keywords:\n\u0026gt;     Lang:          |       Patch:\n\u0026gt;  Platform:          |\n\u0026gt; --------------------+-------------------------------------------------------\n\u0026gt;\n\u0026gt; Comment(by dukeleto):\n\u0026gt;\n\u0026gt;  {{{\n\u0026gt;     $P1 = new [\"Complex\"]\n\u0026gt;     $N0 = 'NaN'\n\u0026gt;     set $P1, \"1 + i\"\n\u0026gt;     $P1 += $N0\n\u0026gt;     say $P1\n\u0026gt;  }}}\n\u0026gt;  prints\n\u0026gt;  {{{\n\u0026gt;  NaN+1i\n\u0026gt;  }}}\n\u0026gt;\nShould it print Nan+1i or just NaN? (How infectious /is/ Nan?)\n--\nWill \"Coke\" Coleda\n\u003c/pre\u003e","files":null},{"type":3,"author":{"id":"2da6485217cbb88ff96be8f3dcc7f9ae44cf6bf0"},"timestamp":1250869356,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDMwMTc=","github-url":"https://github.com/parrot/parrot/issues/401#issuecomment-3503017"},"message":"\u003cp\u003e\nI am going on the assumption that there \"can be only one\" NaN. The entity 'NaN' is for encoding the idea that we should represent an invalid arithmetic operation as something special. There is no \"real\" NaN and \"complex\" NaN. *All* arithmetic operations, no matter they be real or complex, that contain a NaN should simplify to NaN. The partial patch that was added to this ticket adds some support for parsing complex numbers of the form \"NaN+2*i\" and such, but there are still all kinds of other ways that you can make either the real or imaginary part of the resulting number NaN that does not require parsing a string, and these are the cases where we still have bugs.\n\u003c/p\u003e\n\n\u003cp\u003e\nAlso, the patch attached is quite old and the tests no longer compile, but it is a good start.\n\u003c/p\u003e","files":null},{"type":3,"author":{"id":"d9b4aee65ce8c18d4a43eced1eecb0d154e1eebb"},"timestamp":1301219556,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDMwMTg=","github-url":"https://github.com/parrot/parrot/issues/401#issuecomment-3503018"},"message":"\u003cp\u003e\nplobsing,\n\u003c/p\u003e\n\n\u003cp\u003e\nAs with TT \u003ca class=\"closed ticket\" href=\"http://trac.parrot.org/parrot/ticket/954\" title=\"RFC: Inf/NaN from ieee754-2008 (closed: wontfix)\"\u003e#954\u003c/a\u003e, based on your work around infnan, can you evaluate the issues discussed in this ticket?\n\u003c/p\u003e\n\n\u003cp\u003e\nThank you very much.\n\u003c/p\u003e\n\n\u003cp\u003e\nkid51\n\u003c/p\u003e","files":null},{"type":3,"author":{"id":"2da6485217cbb88ff96be8f3dcc7f9ae44cf6bf0"},"timestamp":1319070861,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDMwMTk=","github-url":"https://github.com/parrot/parrot/issues/401#issuecomment-3503019"},"message":"\u003cp\u003e\nWe need a branch that has tests for this bug. It is still present.\n\u003c/p\u003e","files":null}]}