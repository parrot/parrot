{"version":1,"ops":[{"type":3,"author":{"id":"aeaa659130ab92a2084a11638a6eb1a6beb03360"},"timestamp":1295405994,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDM2NDY=","github-url":"https://github.com/parrot/parrot/issues/581#issuecomment-3503646"},"message":"\u003cp\u003e\nThis is fixed, but I've added a reference to the fix in 248434ef in case anyone wants to diagnose this further.  NotFound came up with the fix, but said that he doesn't entirely understand why it works.\n\u003c/p\u003e","files":null},{"type":3,"author":{"id":"6d59fc378929d99368e023bcfc49aacae1e68aad"},"timestamp":1295412824,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDM2NDc=","github-url":"https://github.com/parrot/parrot/issues/581#issuecomment-3503647"},"message":"\u003cp\u003e\nI think the test is wrong.  It does, in essence, the following:\n\u003c/p\u003e\n\n\u003cpre class=\"wiki\"\u003e    $P1 = new ['Float']\n    $P1 = 123.45\n    $P2 = new ['String']\n    $P2 = \"123.45\"\n    $I0 = cmp_num $P1, $P2\n    is($I0, 0, 'comparison ops: cmp_p_p: equality')\n\u003c/pre\u003e\u003cp\u003e\nI gather that the intent is to check whether the conversion of the string \"123.45\" to a Float is the same, whether that string comes in as literal text in the PIR file, or as a \"String\" that gets converted to a number.\n\u003c/p\u003e\n\n\u003cp\u003e\nComparing those two code paths is sensible, but the problem is the choice of number.  Since 123.45 can't be represented exactly in binary, the precise representation depends on how many bits are used.  On the x86 family of processors using the x87 math coprocessor, that might be 80 bits.  Using 'volatile' forces the compiler to reload the contents from memory.  Without the volatile keyword, the compiler is free to use a copy that might be in a register.  In the general case, we don't want to force the compiler to always refetch floating point numbers from memory.  The compiler ought to be able to use registers.\n\u003c/p\u003e\n\n\u003cp\u003e\nI think this fix should be reverted, and the test should be changed to pick a number that can be represented exactly in binary.\n\u003c/p\u003e","files":null},{"type":3,"author":{"id":"aef4977f5ea786238d7c9581a2f192f4adc3f39d"},"timestamp":1295413218,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDM2NDg=","github-url":"https://github.com/parrot/parrot/issues/581#issuecomment-3503648"},"message":"\u003cp\u003e\nBetter yet, Parrot should have a better and more robust way to compare floats using a delta or some other algorithm. Directly comparing floating-point representations in memory is fraught with danger no matter what values we pick.\n\u003c/p\u003e\n\n\u003cp\u003e\nI suggest we either modify cmp_num to take a third argument for a delta value, or we simply build in a much more robust algorithm into cmp_num.\n\u003c/p\u003e","files":null},{"type":3,"author":{"id":"6d59fc378929d99368e023bcfc49aacae1e68aad"},"timestamp":1295413920,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDM2NDk=","github-url":"https://github.com/parrot/parrot/issues/581#issuecomment-3503649"},"message":"\u003cp\u003e\nI don't think that picking a number that pass the tests solves anything. If the exact equality isn't supported we should use an epsilon instead.\n\u003c/p\u003e\n\n\u003cp\u003e\nAnd if we don't support exact equality we'll get that comparing $P1 and $P2 gives a result different than converting them to number registers and comparing. This may be confusing.\n\u003c/p\u003e","files":null},{"type":3,"author":{"id":"6d59fc378929d99368e023bcfc49aacae1e68aad"},"timestamp":1295414218,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDM2NTA=","github-url":"https://github.com/parrot/parrot/issues/581#issuecomment-3503650"},"message":"\u003cp\u003e\nExact equality is needed sometimes. If cmp_num says they are equal but the difference is zero, or the contrary, will not be good. If someone wants comparison within a margin he should ask for that.\n\u003c/p\u003e","files":null},{"type":3,"author":{"id":"6d59fc378929d99368e023bcfc49aacae1e68aad"},"timestamp":1295416273,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDM2NTE=","github-url":"https://github.com/parrot/parrot/issues/581#issuecomment-3503651"},"message":"\u003cp\u003e\nAgreed, floating point is complicated.  How \"close\" is \"close enough\" is strongly dependent on context.  There is no single universal answer.  It all depends on context.  The context here is test 102 of t/pmc/float.t, not a generic discussion of floating point equality.\n\u003c/p\u003e\n\n\u003cp\u003e\nIn this particular case, we have to ask what, precisely, we wish to test.  I indicated above what I thought this test was testing.  Assuming that is correct, then for this specific test, I think picking a number that can be represented exactly is sensible.\n\u003c/p\u003e\n\n\u003cp\u003e\nOf course, perhaps that test was intended to test something else.  In that case, depending on what that \"something else\" is, it might be that the test is simply wrong and should be deleted.  Without knowing what that \"something else\" is, I have no opinion.\n\u003c/p\u003e\n\n\u003cp\u003e\nIn either case, I think forcing the compiler to fetch a fresh value from memory is suboptimal and should be reverted.\n\u003c/p\u003e","files":null},{"type":3,"author":{"id":"6d59fc378929d99368e023bcfc49aacae1e68aad"},"timestamp":1295418090,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDM2NTI=","github-url":"https://github.com/parrot/parrot/issues/581#issuecomment-3503652"},"message":"\u003cp\u003e\nNote that the cmp_num vtable is used in a lot of places, so the impact of changing its meaning is unpredictable. I don't think we should risk that because of an optimization that no one is going to be able to measure.\n\u003c/p\u003e\n\n\u003cp\u003e\nAbout what the test does: I think that ff we want to improve it we should check for a variety of values the result of cpm_num with the PMCs is the same as the comparison of the number values obtained from them. Given that the implementation of the vtable cmp_num in several PMCs uses the vtable get_number, looks like the appropriate behavior to me.\n\u003c/p\u003e","files":null},{"type":3,"author":{"id":"96fb2e2e33b59677e3a85ec74746c085275c50d1"},"timestamp":1295425693,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDM2NTM=","github-url":"https://github.com/parrot/parrot/issues/581#issuecomment-3503653"},"message":"\u003cp\u003e\nI agree with most of the comments related to floating point testing for equality - it is a very hazardous activity.\n\u003c/p\u003e\n\n\u003cp\u003e\nHowever, one of the main points of this ticket, was that we had a situation where the optimizing g++ compiler on a 32 bit platform, generated a different result, from the  non-optimizing g++ compiler and from both the optimizing and non-optimizing gcc compiler and that an earlier version of that compiler did not, and furthermore, the problem did not occur on a 64 bit platform.\n\u003c/p\u003e\n\n\u003cp\u003e\nIs this a compiler bug, a parrot bug in which the later g++ compilers have more efficient optimizers, and where can this effect us in future.\n\u003c/p\u003e\n\n\u003cp\u003e\nCheers, Michael (mikehh)\n\u003c/p\u003e","files":null},{"type":3,"author":{"id":"099af60226e2576bd4ff0f5c2614b710c745cab6"},"timestamp":1295426343,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDM2NTQ=","github-url":"https://github.com/parrot/parrot/issues/581#issuecomment-3503654"},"message":"\u003cp\u003e\nHello.\n\u003c/p\u003e\n\n\u003cp\u003e\nJust my $0.02. We should at least start with something like this - change 0.0 equality test to use epsilon value.\n\u003c/p\u003e\n\n\u003cpre class=\"wiki\"\u003ediff --git a/include/parrot/misc.h b/include/parrot/misc.h\nindex e81ff80..488739b 100644\n--- a/include/parrot/misc.h\n+++ b/include/parrot/misc.h\n@@ -20,7 +20,8 @@\n #include \"parrot/parrot.h\"\n-#define FLOAT_IS_ZERO(f) ((f) == 0.0)\n+#include \u0026lt;float.h\u0026gt;\n+#define FLOAT_IS_ZERO(f) (((f) \u0026lt;= DBL_EPSILON) \u0026amp;\u0026amp; (f) \u0026gt;= -DBL_EPSILON )\n #ifndef PARROT_HAS_C99_SNPRINTF\n #  define snprintf Parrot_secret_snprintf\ndiff --git a/src/pmc/float.pmc b/src/pmc/float.pmc\nindex 55708a3..f265dd8 100644\n--- a/src/pmc/float.pmc\n+++ b/src/pmc/float.pmc\n@@ -260,13 +260,13 @@ The C\u0026lt;cmp\u0026gt; operation.\n     MULTI INTVAL cmp(Float value) {\n         const FLOATVAL diff = SELF.get_number() - VTABLE_get_number(INTERP, value);\n-        return diff \u0026gt; 0 ? 1 : diff \u0026lt; 0 ? -1 : 0;\n-        return FLOAT_IS_ZERO(diff) ? 0 : diff \u0026lt; 0 ? -1 : 1;\n   }\n   MULTI INTVAL cmp(DEFAULT value) {\n       const FLOATVAL diff =\n               SELF.get_number() - VTABLE_get_number(INTERP, value);\n-        return diff \u0026gt; 0 ? 1 : diff \u0026lt; 0 ? -1 : 0;\n-        return FLOAT_IS_ZERO(diff) ? 0 : diff \u0026lt; 0 ? -1 : 1;\n   }\n  /*\n  @@ -281,7 +281,7 @@ Returns the result of comparing the number with C\u0026lt;*value\u0026gt;.\n   MULTI INTVAL cmp_num(Float value) {\n       const FLOATVAL diff = SELF.get_number() - VTABLE_get_number(INTERP, value);\n-        return diff \u0026gt; 0 ? 1 : diff \u0026lt; 0 ? -1 : 0;\n-        return FLOAT_IS_ZERO(diff) ? 0 : diff \u0026lt; 0 ? -1 : 1;\n   }\n   MULTI INTVAL cmp_num(DEFAULT value) {\n  @@ -291,7 +291,7 @@ Returns the result of comparing the number with C\u0026lt;*value\u0026gt;.\n       volatile FLOATVAL n1 = SELF.get_number();\n       volatile FLOATVAL n2 = VTABLE_get_number(INTERP, value);\n       const FLOATVAL diff = n1 - n2;\n-        return diff \u0026gt; 0 ? 1 : diff \u0026lt; 0 ? -1 : 0;\n-        return FLOAT_IS_ZERO(diff) ? 0 : diff \u0026lt; 0 ? -1 : 1;\n   }\n  /*\n  \u003c/pre\u003e\u003cp\u003e\n  --\n  Bacek\n  \u003c/p\u003e","files":null},{"type":3,"author":{"id":"6d59fc378929d99368e023bcfc49aacae1e68aad"},"timestamp":1295429885,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDM2NTU=","github-url":"https://github.com/parrot/parrot/issues/581#issuecomment-3503655"},"message":"\u003cp\u003e\nReplying to \u003ca href=\"http://trac.parrot.org/parrot/ticket/1978#comment:8\" title=\"Comment 8 for Ticket #1978\"\u003emikehh\u003c/a\u003e:\n\u003c/p\u003e\n\n\u003cblockquote class=\"citation\"\u003e\n\u003cp\u003e\n I agree with most of the comments related to floating point testing for equality - it is a very hazardous activity.\n\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e\nSimilarly, defining what parrot will and will not guarantee is also a very tricky  activity.\n\u003c/p\u003e\n\n\u003cblockquote class=\"citation\"\u003e\n\u003cp\u003e\n However, one of the main points of this ticket, was that we had a situation where the optimizing g++ compiler on a 32 bit platform, generated a different result, from the  non-optimizing g++ compiler and from both the optimizing and non-optimizing gcc compiler and that an earlier version of that compiler did not, and furthermore, the problem did not occur on a 64 bit platform.\n Is this a compiler bug, a parrot bug in which the later g++ compilers have more efficient optimizers, and where can this effect us in future.\n\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e\nI don't think it's a compiler bug.  It's easy to imagine different versions of the compiler deciding to keep different items in registers.  On x86 systems using the x87 coprocessor with the extended 80-bit precision, this can lead to the sort of problem you encountered.  This does not affect x86_64 systems (nor SPARC nor PPC), since they don't use 80-bit extended precision registers for floating point.\n\u003c/p\u003e\n\n\u003cp\u003e\nI think it's an area where parrot's desired behavior hasn't been explicitly defined, so it's unclear whether the test, the pmc code, or both are in error.\n\u003c/p\u003e\n\n\u003cp\u003e\nEither choice can lead to surprises.  For example, allowing the 80-bit registers led to the problem here.  Not allowing 80-bit registers at all (gcc offers several ways to do this) might cause problems with external libraries that expect to use the 80-bit registers.  (As just one example, a parrot-based program and an \"equivalent\" C program might no longer get the same answer.  Perl 5 certainly has received a number of bug reports of just this sort.)\n\u003c/p\u003e\n\n\u003cp\u003e\nAs a virtual machine that hopes to interact both with higher level languages and with external libraries, both choices are reasonable, but neither is ideal.\n\u003c/p\u003e\n\n\u003cp\u003e\nMy personal bias is that the original test was in error -- parrot shouldn't make such promises of equality -- but it's also reasonable to take the opposite point of view.\n\u003c/p\u003e","files":null},{"type":3,"author":{"id":"18879c4084549ff2c7022dc058bcf4940fadd0f2"},"timestamp":1295510537,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDM2NTY=","github-url":"https://github.com/parrot/parrot/issues/581#issuecomment-3503656"},"message":"\u003cp\u003e\nYes, this is a well-known issue with excess precision on x87, see \u003ca   href=\"http://gcc.gnu.org/bugzilla/show_bug.cgi?id=323\"\u003e\u003cspan class=\"icon\"\u003e \u003c/span\u003ehttp://gcc.gnu.org/bugzilla/show_bug.cgi?id=323\u003c/a\u003e for example.\n\u003c/p\u003e\n\n\u003cp\u003e\nUsing SSE instead of x87 with \"-msse2 -mfpmath=sse\" should also do the trick.\n\u003c/p\u003e","files":null},{"type":3,"author":{"id":"d9b4aee65ce8c18d4a43eced1eecb0d154e1eebb"},"timestamp":1295816531,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDM2NTc=","github-url":"https://github.com/parrot/parrot/issues/581#issuecomment-3503657"},"message":"\u003cp\u003e\nIs the issue reported in TT \u003ca class=\"new ticket\" href=\"http://trac.parrot.org/parrot/ticket/1930\" title=\"bug: t/op/number.t: one test fails under --optimize on Darwin/PPC (new)\"\u003e#1930\u003c/a\u003e (a test failure on Darwin/PPC in \u003ci\u003et/op/number.t\u003c/i\u003e that appears only with \u003ctt\u003e--optimize\u003c/tt\u003e) fundamentally the same as this one?\n\u003c/p\u003e","files":null},{"type":3,"author":{"id":"18879c4084549ff2c7022dc058bcf4940fadd0f2"},"timestamp":1302678439,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDM2NTg=","github-url":"https://github.com/parrot/parrot/issues/581#issuecomment-3503658"},"message":"\u003cp\u003e\nFWIW, I added the -fexcess-precision=standard option supported by GCC \u0026gt;= 4.5 in d0fd13f.\n\u003c/p\u003e","files":null},{"type":3,"author":{"id":"2da6485217cbb88ff96be8f3dcc7f9ae44cf6bf0"},"timestamp":1303993195,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDM2NTk=","github-url":"https://github.com/parrot/parrot/issues/581#issuecomment-3503659"},"message":"\u003cp\u003e\nWhat needs to happen to close this ticket? Do we have a consensus?\n\u003c/p\u003e","files":null},{"type":3,"author":{"id":"86141a663c2eb7543d1a51ec6253a1d54de912fd"},"timestamp":1394049998,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM2Nzg3MTgz","github-url":"https://github.com/parrot/parrot/issues/581#issuecomment-36787183"},"message":"I fixed TT #1930 (ppc t/op/number.t 50) with d66d188a810f41fcfc871a27611b4eaf8b15fade.\nt/pmc/float.t is also fixed, no known optimizer issues left","files":null},{"type":4,"author":{"id":"86141a663c2eb7543d1a51ec6253a1d54de912fd"},"timestamp":1394049998,"metadata":{"github-id":"MDExOkNsb3NlZEV2ZW50OTkyNDAxNTI="},"status":2}]}