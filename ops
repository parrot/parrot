{"version":1,"ops":[{"type":3,"author":{"id":"646f0669ead6eaf64196bebf3884a5eff162357a"},"timestamp":1383423270,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDI3NjMxNDU1","github-url":"https://github.com/parrot/parrot/issues/1026#issuecomment-27631455"},"message":"I think PMC morphing is largely considered a design wart at this point.  Value types should likely refuse to do assignment from other types or perform an implicit conversion.","files":null},{"type":3,"author":{"id":"86141a663c2eb7543d1a51ec6253a1d54de912fd"},"timestamp":1394315090,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM3MTEwODk4","github-url":"https://github.com/parrot/parrot/issues/1026#issuecomment-37110898"},"message":"Yes, I agree and I explain the consistency:\n- assignment has it's use cases for native types (I,N,S) with automatic type casting,\n- and assignment between different PMC is done via assign_p_p (assign_pmc vtable), \n  which calls the set_pmc vtable method, which may call the morph vtable methods (i.e. cast).\n- any PMC can specify a morph vtable method to allow custom type casting.\n\nCurrent parrot's morph works only for classes, not objects. This is of course not enough.\n\nregarding cast vs coercion:\nmorph or assign_pmc only supports type casting from the content of the source to the type of the target.\nunmodifiable targets need to throw errors in assign_pmc. \nmorph returns a copy and assign_pmc assigns this copy. pmc_reuse already does these readonly checks.\n\ncore just does not define all possible and doable morph methods currently, and can \nonly morph from classes, but this is merely a lack of implementations or usefulness.\n\nI totally disagree with benabik that morph is undesirable at all. \nIt is one of the most basic OO principles to be able to define how to coerce to one type \nor override from another type.\nWithout this extendability and inheritance of pmc's is limited to set_pmc only.\n\nmorph needs to set the new value also, not just change the vtable of the object.\nA user class has no other possibility to set the new values than by specifying \nmorph coercion rules, which are class specific. i.e. *Array =\u003e Integer: elements =\u003e get_integer\n\nrunning morph behinds the scenes of `P1 = P2` is like doing an implicit cast. \nThis makes only sense for primitive types. \nWe require explicit casting via `morph P1, P2` for non-primitive types..\n\nmorph is broken btw, see GH #372 for the branch which fixes and extends it","files":null},{"type":5,"author":{"id":"86141a663c2eb7543d1a51ec6253a1d54de912fd"},"timestamp":1394552535,"metadata":{"github-id":"MDEyOkxhYmVsZWRFdmVudDEwMDkxMjA4Mg=="},"added":["Sev-medium"],"removed":[]},{"type":5,"author":{"id":"86141a663c2eb7543d1a51ec6253a1d54de912fd"},"timestamp":1394552537,"metadata":{"github-id":"MDE0OlVubGFiZWxlZEV2ZW50MTAwOTEyMDkz"},"added":[],"removed":["Sev-low"]}]}