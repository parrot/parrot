{"version":1,"ops":[{"type":3,"author":{"id":"0c9c62332064205b2d799407019fa3e7e2f43862"},"timestamp":1245891302,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDI3MTI=","github-url":"https://github.com/parrot/parrot/issues/306#issuecomment-3502712"},"message":"\u003cp\u003e\nI agree that Parrot needs some additional support for lvalues -- I've remarked on this in previous #parrot and #parrotsketch conversations but we've never come down to making changes.\n\u003c/p\u003e\n\n\u003cp\u003e\nSo, I agree that what Parrot provides is currently insufficient.\n\u003c/p\u003e\n\n\u003cp\u003e\nHowever, part of the problem is that from an HLL perspective Parrot really confuses the notions of \"binding\" and \"assignment\", and this specific approach to resolving the problem seems to perpetuate that confusion even further.  We should hold some more (non-Trac) discussions about the issues, either on #parrot or the mailing list.\n\u003c/p\u003e\n\n\u003cp\u003e\nPm\n\u003c/p\u003e","files":null},{"type":3,"author":{"id":"0c1ee4af33970ee80260d659da672a9306b51181"},"timestamp":1246526918,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDI3MTM=","github-url":"https://github.com/parrot/parrot/issues/306#issuecomment-3502713"},"message":"\u003cp\u003e\nParrot doesn't need to have a vtable entry for every HLL operation. This one unpacks pretty cleanly to a series of opcodes (fetch the element/slice, assign to it, store it back). This ticket rejected, but agreed that we need to have a more general conversation about lvalue support, assignment, and binding.\n\u003c/p\u003e","files":null},{"type":3,"author":{"id":"0c9c62332064205b2d799407019fa3e7e2f43862"},"timestamp":1256335761,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDI3MTQ=","github-url":"https://github.com/parrot/parrot/issues/306#issuecomment-3502714"},"message":"\u003cp\u003e\nSee my proposal for \"fetch\" and \"vivify\" opcodes at TT \u003ca class=\"closed ticket\" href=\"http://trac.parrot.org/parrot/ticket/1138\" title=\"todo: Create a 'vivify' opcode (closed: fixed)\"\u003e#1138\u003c/a\u003e.\n\u003c/p\u003e\n\n\u003cp\u003e\nPm\n\u003c/p\u003e","files":null},{"type":3,"author":{"id":"0c9c62332064205b2d799407019fa3e7e2f43862"},"timestamp":1256336004,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDI3MTU=","github-url":"https://github.com/parrot/parrot/issues/306#issuecomment-3502715"},"message":"\u003cp\u003e\nReplying to \u003ca href=\"http://trac.parrot.org/parrot/ticket/787#comment:3\" title=\"Comment 3 for Ticket #787\"\u003eallison\u003c/a\u003e:\n\u003c/p\u003e\n\n\u003cblockquote class=\"citation\"\u003e\n\u003cp\u003e\n Parrot doesn't need to have a vtable entry for every HLL operation. This one unpacks\n pretty cleanly to a series of opcodes (fetch the element/slice, assign to it, store it back).\n\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e\nThis response is at the least very misleading, so I'll try to clarify things a bit here.\n\u003c/p\u003e\n\n\u003cp\u003e\nTo assign to an element of an aggregate, the basic sequence is \"fetch the element PMC, assign to it\".  There's no \"store it back\" operation -- the PMC element retrieved by the fetch is still bound in the aggregate, so assigning a new value to that PMC effectively changes it in the aggregate.  In code, the basic sequence would be:\n\u003c/p\u003e\n\n\u003cpre class=\"wiki\"\u003e    $P0 = aggregate[key]\n    assign $P0, value\n\u003c/pre\u003e\u003cp\u003e\nThe tricky part is when someone wants to assign to an element of an aggregate that doesn't already exist.  In this case, \"fetch the element\" returns NULL, so a new PMC has to be created and bound into the aggregate (i.e., vivified):\n\u003c/p\u003e\n\u003cpre class=\"wiki\"\u003e    ##  HLL: @aggregate[$key] = $value\n    $P0 = aggregate[key]\n    unless null $P0 goto vivified\n    $P0 = new ['Undef']\n    aggregate[key] = $P0\n  vivified:\n    assign $P0, value\n\u003c/pre\u003e\u003cp\u003e\nFor a non-vivifying fetch of an element, we still want to avoid the NULL that comes back from the aggregate but we don't want to make it permanent, so we get:\n\u003c/p\u003e\n\u003cpre class=\"wiki\"\u003e    ##  HLL:  say @aggregate[$key]\n    $P0 = aggregate[key]\n    unless null $P0 goto vivified\n    $P0 = new ['Undef']\n  vivified:\n    say $P0\n\u003c/pre\u003e\u003cp\u003e\nI think this is what the original posting was getting at -- there are vivifying (lvalue) and non-vivifying (rvalue) forms of \"fetch an element\", and Parrot's opcodes, vtables, and built-in types don't really support the distinction well.  We can potentially improve things with specialized opcodes, proxy elements in aggregates, and/or references (Rakudo ends up doing all three of these) -- the question is whether any of them belong in \"core Parrot\" to provide a common interface that can be shared by all HLLs.\n\u003c/p\u003e\n\n\u003cp\u003e\nTT \u003ca class=\"closed ticket\" href=\"http://trac.parrot.org/parrot/ticket/1138\" title=\"todo: Create a 'vivify' opcode (closed: fixed)\"\u003e#1138\u003c/a\u003e posits the creation of a \"vivify\" opcode to address the \"rvalue fetch\" problem, but it doesn't address the issue of \"lvalue fetch\".\n\u003c/p\u003e\n\n\u003cp\u003e\nPm\n\u003c/p\u003e\n\n\u003cp\u003e\n[update:  I've since proposed separate \u0026#34;fetch\u0026#34; and \u0026#34;vivify\u0026#34; opcodes for generic rvalue and lvalue fetch -- see TT #1138.]\n\u003c/p\u003e","files":null}]}