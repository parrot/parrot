{"version":1,"ops":[{"type":3,"author":{"id":"2da6485217cbb88ff96be8f3dcc7f9ae44cf6bf0"},"timestamp":1254300123,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDI0ODY=","github-url":"https://github.com/parrot/parrot/issues/248#issuecomment-3502486"},"message":"340 byte attachment from leto\nat http://trac.parrot.org/parrot/raw-attachment/ticket/1078/never_ending_exception.pir\n\n```\n# Copyright (C) 2006-2009, Parrot Foundation.\n# $Id$\n\n.sub 'main' :main\n    .include 'test_more.pir'\n    $P0 = new 'ExceptionHandler'\n    set_addr $P0, _handler\n    push_eh $P0\n    throw $P0\n_handler:\n    getattribute $P5, $P0, 'foo'\n.end\n\n# Local Variables:\n#   mode: pir\n#   fill-column: 100\n# End:\n# vim: expandtab shiftwidth=4 ft=pir:\n```","files":null},{"type":3,"author":{"id":"2da6485217cbb88ff96be8f3dcc7f9ae44cf6bf0"},"timestamp":1254317979,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDI0ODc=","github-url":"https://github.com/parrot/parrot/issues/248#issuecomment-3502487"},"message":"\u003cp\u003e\nOn darwin x86, this code pegs a CPU. If I kill the code while running it under gdb I get this backtrace:\n\u003c/p\u003e\n\n\u003cpre class=\"wiki\"\u003e(gdb) bt\n#0  0x0037928f in Parrot_sprintf_format ()\n#1  0x00338772 in Parrot_vsprintf_c ()\n#2  0x0031add2 in Parrot_ex_throw_from_c_args ()\n#3  0x003ec058 in Parrot_default_get_attr_str ()\n#4  0x002d6d7a in Parrot_getattribute_p_p_sc ()\n#5  0x00375ae1 in runops_slow_core ()\n#6  0x00375078 in runops_int ()\n#7  0x0033101e in runops ()\n#8  0x0033118c in runops_args ()\n#9  0x00331772 in Parrot_runops_fromc_args ()\n#10 0x0031747a in Parrot_runcode ()\n#11 0x004c32d2 in imcc_run ()\n#12 0x000024fe in main ()\n\u003c/pre\u003e\u003cp\u003e\nAnother backtrace is:\n\u003c/p\u003e\n\u003cpre class=\"wiki\"\u003e(gdb) bt\n#0  0x91e6a5c1 in _sigunaltstack ()\n#1  0x91e382c0 in longjmp ()\n#2  0x0031ae5a in Parrot_ex_throw_from_c_args ()\n#3  0x003ec058 in Parrot_default_get_attr_str ()\n#4  0x002d6d7a in Parrot_getattribute_p_p_sc ()\n#5  0x00375ae1 in runops_slow_core ()\n#6  0x00375078 in runops_int ()\n#7  0x0033101e in runops ()\n#8  0x0033118c in runops_args ()\n#9  0x00331772 in Parrot_runops_fromc_args ()\n#10 0x0031747a in Parrot_runcode ()\n#11 0x004c32d2 in imcc_run ()\n#12 0x000024fe in main ()\n\u003c/pre\u003e","files":null},{"type":3,"author":{"id":"2da6485217cbb88ff96be8f3dcc7f9ae44cf6bf0"},"timestamp":1254318058,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDI0ODg=","github-url":"https://github.com/parrot/parrot/issues/248#issuecomment-3502488"},"message":"Yet another is :\n\n```\n(gdb) bt\n#0  0x0037771e in Parrot_cx_find_handler_local ()\n#1  0x0031a54d in Parrot_ex_throw_from_c ()\n#2  0x0031ae5a in Parrot_ex_throw_from_c_args ()\n#3  0x003ec058 in Parrot_default_get_attr_str ()\n#4  0x002d6d7a in Parrot_getattribute_p_p_sc ()\n#5  0x00375ae1 in runops_slow_core ()\n#6  0x00375078 in runops_int ()\n#7  0x0033101e in runops ()\n#8  0x0033118c in runops_args ()\n#9  0x00331772 in Parrot_runops_fromc_args ()\n#10 0x0031747a in Parrot_runcode ()\n#11 0x004c32d2 in imcc_run ()\n#12 0x000024fe in main ()\n```\n\nAre these useful?","files":null},{"type":3,"author":{"id":"2da6485217cbb88ff96be8f3dcc7f9ae44cf6bf0"},"timestamp":1254318123,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDI0ODk=","github-url":"https://github.com/parrot/parrot/issues/248#issuecomment-3502489"},"message":"\u003cp\u003e\nCode that puts parrot into an infinite loop\n\u003c/p\u003e","files":null},{"type":3,"author":{"id":"6d59fc378929d99368e023bcfc49aacae1e68aad"},"timestamp":1257621225,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDI0OTA=","github-url":"https://github.com/parrot/parrot/issues/248#issuecomment-3502490"},"message":"2387 byte attachment from notfound\nat http://trac.parrot.org/parrot/raw-attachment/ticket/1078/never_ending_exception.patch\n\n```\nIndex: src/pmc/exceptionhandler.pmc\n===================================================================\n--- src/pmc/exceptionhandler.pmc    (revision 42318)\n+++ src/pmc/exceptionhandler.pmc    (working copy)\n@@ -22,12 +22,16 @@\n\n #include \"parrot/oplib/ops.h\"\n\n+/* Arbitrarily choosen value */\n+#define HANDLING_COUNTER_LIMIT 512\n+\n pmclass ExceptionHandler extends Continuation auto_attrs {\n\n     ATTR PMC    *handled_types;\n     ATTR PMC    *handled_types_except;\n     ATTR INTVAL min_severity;\n     ATTR INTVAL max_severity;\n+    ATTR INTVAL handling_counter;\n\n /*\n\n@@ -120,6 +124,10 @@\n\n     VTABLE opcode_t *invoke(void *next) {\n         opcode_t    * const pc = PARROT_CONTINUATION(SELF)-\u003eaddress;\n+        INTVAL counter;\n+        GET_ATTR_handling_counter(INTERP, SELF, counter);\n+        ++counter;\n+        SET_ATTR_handling_counter(INTERP, SELF, counter);\n\n         Parrot_continuation_check(interp, SELF);\n         Parrot_continuation_rewind_environment(interp, SELF);\n@@ -158,8 +166,18 @@\n         STRING * const sev    = CONST_STRING(interp, \"severity\");\n         STRING * const ex_str = CONST_STRING(interp, \"Exception\");\n\n-        INTVAL severity = VTABLE_get_integer_keyed_str(interp, exception, sev);\n+        const INTVAL severity = VTABLE_get_integer_keyed_str(interp, exception, sev);\n+        const INTVAL type  = VTABLE_get_integer_keyed_str(interp, exception, CONST_STRING(interp, \"type\"));\n\n+        /* Declare that it can't handle any exception after reaching the limit,\n+         * giving opportunity to other handler to take control.\n+         * Avoid control exceptions, that are supposed to be less error prone\n+         * and might need longer usages. */\n+        INTVAL counter;\n+        GET_ATTR_handling_counter(INTERP, SELF, counter);\n+        if (type \u003c CONTROL_RETURN \u0026\u0026 counter \u003e= HANDLING_COUNTER_LIMIT)\n+            RETURN(INTVAL 0);\n+\n         if (exception-\u003evtable-\u003ebase_type == enum_class_Exception\n         ||  VTABLE_isa(INTERP, exception, ex_str)) {\n             PMC *handled_types;\n@@ -178,7 +196,6 @@\n             }\n             if (! PMC_IS_NULL(handled_types)) {\n                 const INTVAL elems = VTABLE_elements(interp, handled_types);\n-                const INTVAL type  = VTABLE_get_integer_keyed_str(interp, exception, CONST_STRING(interp, \"type\"));\n                 INTVAL i;\n\n                 for (i = 0; i \u003c elems; i++) {\n```","files":null},{"type":3,"author":{"id":"6d59fc378929d99368e023bcfc49aacae1e68aad"},"timestamp":1257642825,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDI0OTE=","github-url":"https://github.com/parrot/parrot/issues/248#issuecomment-3502491"},"message":"\u003cp\u003e\npatch that limits the number of invocations of an exception handler\n\u003c/p\u003e","files":null},{"type":3,"author":{"id":"6d59fc378929d99368e023bcfc49aacae1e68aad"},"timestamp":1257643177,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDI0OTI=","github-url":"https://github.com/parrot/parrot/issues/248#issuecomment-3502492"},"message":"\u003cp\u003e\nThe problem, in this and other cases, is that an exception handler is, by design, allowed to catch the exceptions thrown by himself.\n\u003c/p\u003e\n\n\u003cp\u003e\nThe attached patch tries a possible approach: set a limit for the number of times the exception handler can be invoked, except for exceptions of CONTROL_... types. When that limit is reached, can_handle return false, allowing the next handler in the chain to take control.\n\u003c/p\u003e\n\n\u003cp\u003e\nThe value for the limit has been chosen arbitrarily and must be fine tuned later, if the proposal is accepted.\n\u003c/p\u003e","files":null},{"type":3,"author":{"id":"0c9c62332064205b2d799407019fa3e7e2f43862"},"timestamp":1257653900,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDI0OTM=","github-url":"https://github.com/parrot/parrot/issues/248#issuecomment-3502493"},"message":"\u003cp\u003e\nNote that the original code itself has a bug -- after catching the exception, it doesn't remove the exception handler with pop_eh.  Thus the fetch for the non-existent attribute re-triggers the top exception handler.\n\u003c/p\u003e\n\n\u003cp\u003e\nI would personally prefer that we find a way to treat this the same as other \"recursion limit\" code.  I'm opposed to keeping a counter in the exception handler itself, because a single handler really ought to be able to handle an infinite number of (non-recursive) exceptions thrown to it.\n\u003c/p\u003e\n\n\u003cp\u003e\n(Summary: I vote against the patch and hope for something better.)\n\u003c/p\u003e\n\n\u003cp\u003e\nPm\n\u003c/p\u003e","files":null}]}