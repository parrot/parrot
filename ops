{"version":1,"ops":[{"type":3,"author":{"id":"6d59fc378929d99368e023bcfc49aacae1e68aad"},"timestamp":1259625341,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDI4NTE=","github-url":"https://github.com/parrot/parrot/issues/363#issuecomment-3502851"},"message":"Trac commenter: heidnes\n\n\u003cp\u003e\nHmm, this may have to do with the \"clone library\" functionality, which appears to create two copies of a shared library, which however share the dlhandle(), ref. the clone() function.  Things go wrong when the second instance is destroy()ed.  This happens in code which comes from src/pmc/parrotlibrary.pmc's destroy() and clone() functions, I suspect.\n\u003c/p\u003e","files":null},{"type":3,"author":{"id":"6d59fc378929d99368e023bcfc49aacae1e68aad"},"timestamp":1259682822,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDI4NTI=","github-url":"https://github.com/parrot/parrot/issues/363#issuecomment-3502852"},"message":"2046 byte attachment from heidnes\nat http://trac.parrot.org/parrot/raw-attachment/ticket/1340/diff\n\n# ```Index: config/gen/platform/generic/dl.c\n\n--- config/gen/platform/generic/dl.c    (revision 42823)\n+++ config/gen/platform/generic/dl.c    (working copy)\n@@ -22,11 +22,69 @@\n */\n\n #ifdef PARROT_HAS_HEADER_DLFCN\n+#  include \u003cstddef.h\u003e\n+#  include \u003cstdlib.h\u003e\n #  include \u003cdlfcn.h\u003e\n #endif\n\n #define PARROT_DLOPEN_FLAGS RTLD_LAZY\n\n+#ifdef PARROT_HAS_HEADER_DLFCN\n+\n+struct handle_entry {\n-    void *handle;\n-    struct handle_entry *next;\n  +};\n  +\n  +struct handle_entry *handle_list = NULL;\n  +\n  +static void\n  +push_handle_entry(void *handle)\n  +{\n-    struct handle_entry *e;\n  +\n-    e = malloc(sizeof(struct handle_entry));\n-    if (!e) { return; }\n-    e-\u003ehandle = handle;\n-    e-\u003enext = handle_list;\n-    handle_list = e;\n  +}\n  +\n  +static void *\n  +find_handle_entry(void *handle)\n  +{\n-    struct handle_entry *e;\n  +\n-    for(e = handle_list; e; e = e-\u003enext) {\n-   if (e-\u003ehandle == handle)\n-       return handle;\n-    }\n-    return NULL;\n  +}\n  +\n  +static void\n  +remove_handle_entry(void *handle)\n  +{\n-    struct handle_entry *cur, *prev, *p;\n  +\n-    if (handle_list) {\n-   if (handle_list-\u003ehandle == handle) {\n-       p = handle_list;\n-       handle_list = p-\u003enext;\n-       free(p);\n-   } else {\n-       for (cur = handle_list; cur; prev = cur, cur = cur-\u003enext) {\n-       if (cur-\u003ehandle == handle) {\n-           prev-\u003enext = cur-\u003enext;\n-           free(cur);\n-       }\n-       }\n-   }\n-    }\n  +}\n  +#endif /\\* PARROT_HAS_HEADER_DLFCN _/\n  +\n  +\n  /_\n  \n  =item C\u003cvoid * Parrot_dlopen(const char *filename)\u003e\n  @@ -39,7 +97,11 @@\n  Parrot_dlopen(const char *filename)\n  {\n  #ifdef PARROT_HAS_HEADER_DLFCN\n-    return dlopen(filename, PARROT_DLOPEN_FLAGS);\n-    void *h;\n  +\n-    h = dlopen(filename, PARROT_DLOPEN_FLAGS);\n-    push_handle_entry(h);\n-    return h;\n  #else\n     return 0;\n  #endif\n  @@ -93,7 +155,13 @@\n  Parrot_dlclose(void *handle)\n  {\n  #ifdef PARROT_HAS_HEADER_DLFCN\n-    return dlclose(handle);\n-    int rv;\n  +\n-    if (find_handle_entry(handle)) {\n-   remove_handle_entry(handle);\n-   rv = dlclose(handle);\n-   return rv;\n-    }\n  #else\n     return -1;\n  #endif\n\n```\n```","files":null},{"type":3,"author":{"id":"6d59fc378929d99368e023bcfc49aacae1e68aad"},"timestamp":1259704422,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDI4NTM=","github-url":"https://github.com/parrot/parrot/issues/363#issuecomment-3502853"},"message":"Trac commenter: heidnes\n\n```\n    \u003cp\u003e\n```\n\nNew version of diff, ensuring to include required headers, and omit helper functions if we don't need them.\n\u003c/p\u003e","files":null},{"type":3,"author":{"id":"6d59fc378929d99368e023bcfc49aacae1e68aad"},"timestamp":1259705483,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDI4NTQ=","github-url":"https://github.com/parrot/parrot/issues/363#issuecomment-3502854"},"message":"\u003cp\u003e\nReplying to \u003ca href=\"http://trac.parrot.org/parrot/ticket/1340#comment:1\" title=\"Comment 1 for Ticket #1340\"\u003eheidnes\u003c/a\u003e:\n\u003c/p\u003e\n\n\u003cblockquote class=\"citation\"\u003e\n\u003cp\u003e\n Hmm, this may have to do with the \"clone library\" functionality, which appears to create two copies of a shared library, which however share the dlhandle(), ref. the clone() function.  Things go wrong when the second instance is destroy()ed.  This happens in code which comes from src/pmc/parrotlibrary.pmc's destroy() and clone() functions, I suspect.\n\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e\nIt is permissible to call dlclose() twice on the same handle, if the shared object has been dlopen()-ed twice.  The two calls to dlopen() will both return the same handle.\n\u003c/p\u003e\n\n\u003cp\u003e\nI don't know what, exactly, parrot means by \"clone\" on a shared object, but if the clone method simply called dlopen() again, the multiple calls to dlclose() would probably work as intended.\n\u003c/p\u003e","files":null},{"type":3,"author":{"id":"6d59fc378929d99368e023bcfc49aacae1e68aad"},"timestamp":1259705994,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDI4NTU=","github-url":"https://github.com/parrot/parrot/issues/363#issuecomment-3502855"},"message":"Trac commenter: heidnes\n\n\u003cp\u003e\nReplying to \u003ca href=\"http://trac.parrot.org/parrot/ticket/1340#comment:2\" title=\"Comment 2 for Ticket #1340\"\u003edoughera\u003c/a\u003e:\n\u003c/p\u003e\n\n\u003cblockquote class=\"citation\"\u003e\n\u003cp\u003e\n It is permissible to call dlclose() twice on the same handle, if the shared object has been dlopen()-ed twice.  The two calls to dlopen() will both return the same handle.\n\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e\nMaybe.  I've not checked if there is a standard defining that part.\n\u003c/p\u003e\n\n\u003cblockquote class=\"citation\"\u003e\n\u003cp\u003e\n I don't know what, exactly, parrot means by \"clone\" on a shared object, but if the clone method simply called dlopen() again, the multiple calls to dlclose() would probably work as intended.\n\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e\nThe clone operation looks like this (from src/pmc/parrotlibrary.pmc):\n\u003c/p\u003e\n\n\u003cpre class=\"wiki\"\u003e    VTABLE PMC *clone() {\n        PMC \\* const dest     = pmc_new(INTERP, SELF-\u0026gt;vtable-\u0026gt;base_type);\n        PMC_oplib_init(dest) = PMC_oplib_init(SELF);\n        PMC_dlhandle(dest)   = PMC_dlhandle(SELF);\n        if (PMC_metadata(SELF))\n            PMC_metadata(dest) = VTABLE_clone(INTERP, PMC_metadata(SELF));\n        return dest;\n    }\n\u003c/pre\u003e\u003cp\u003e\ni.e. it just copies the handle returned by dlopen(), it does not dlopen() a second time.\nWhen it comes time to clean up after each of the library instances, dlclose() gets called\ntwice with the same handle value, returned from a single dlopen() call.  I suspect that is\nan error.\n\u003c/p\u003e\n\n\u003cp\u003e\nThe patch I created prevents this from happening.\n\u003c/p\u003e","files":null},{"type":3,"author":{"id":"646f0669ead6eaf64196bebf3884a5eff162357a"},"timestamp":1331215516,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDQzOTE2ODg=","github-url":"https://github.com/parrot/parrot/issues/363#issuecomment-4391688"},"message":"This is apparently still an issue on NetBSD (see #732).  Does anyone have NetBSD to try this?  Has anyone made sure the patch works on not-BSD?","files":null},{"type":3,"author":{"id":"2da6485217cbb88ff96be8f3dcc7f9ae44cf6bf0"},"timestamp":1331225539,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDQzOTUyNzM=","github-url":"https://github.com/parrot/parrot/issues/363#issuecomment-4395273"},"message":"We have access to a NetBSD machine on the GCC Compile Farm:\n\nname   port disk   CPU        Notes\ngcc70       160G   2x3.2 GHz  Intel Xeon 3.2E (Irwindale) / 3 GB RAM / Dell Poweredge SC1425 / NetBSD 5.1 amd64\n\nhttp://gcc.gnu.org/wiki/CompileFarm\n\nThis kind of patch definitely needs to be tested on all our supported platforms before being merged.","files":null},{"type":3,"author":{"id":"2da6485217cbb88ff96be8f3dcc7f9ae44cf6bf0"},"timestamp":1331410343,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDQ0MzM5Mzc=","github-url":"https://github.com/parrot/parrot/issues/363#issuecomment-4433937"},"message":"@he32 @Benabik it looks like the updated diff was mangled in the conversion from Trac to Github, can you resubmit the diff as a pull request against Parrot 4.1.0 or the master branch?","files":null},{"type":3,"author":{"id":"2da6485217cbb88ff96be8f3dcc7f9ae44cf6bf0"},"timestamp":1331410432,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDQ0MzM5NDc=","github-url":"https://github.com/parrot/parrot/issues/363#issuecomment-4433947"},"message":"Ah, I was mistaken. The updated diff is at http://trac.parrot.org/parrot/raw-attachment/ticket/1340/diff","files":null},{"type":3,"author":{"id":"2da6485217cbb88ff96be8f3dcc7f9ae44cf6bf0"},"timestamp":1331410615,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDQ0MzM5NzQ=","github-url":"https://github.com/parrot/parrot/issues/363#issuecomment-4433974"},"message":"The patch no longer applies, but I am working on a manual merge now.","files":null},{"type":3,"author":{"id":"2da6485217cbb88ff96be8f3dcc7f9ae44cf6bf0"},"timestamp":1331413523,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDQ0MzQzNTQ=","github-url":"https://github.com/parrot/parrot/issues/363#issuecomment-4434354"},"message":"With the commit above, on the gh363/dlclose branch, \"make test\" passes for me on g++. If anybody can test that branch on other platforms, that would be spiffy.","files":null}]}