{"version":1,"ops":[{"type":3,"author":{"id":"aef4977f5ea786238d7c9581a2f192f4adc3f39d"},"timestamp":1253218151,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDM1NzQ=","github-url":"https://github.com/parrot/parrot/issues/558#issuecomment-3503574"},"message":"\u003cp\u003e\nclone_p_p is pretty naive, so it doesn't surprise me that there is a problem like this to be found in it. Actually, I'm surprised we haven't seen an issue like this sooner.\n\u003c/p\u003e\n\n\u003cp\u003e\nI suggest that what we should do when cloning an aggregate is keep a cache of already-cloned PMCs, and when we reach a PMC reference that exists in the cache we can swap it out with the already-cloned PMC reference from the cache.\n\u003c/p\u003e\n\n\u003cp\u003e\nLooking at an example:\n\u003c/p\u003e\n\n\u003cpre class=\"wiki\"\u003e$P0 = new 'Integer'\n$P1 = new 'ResizablePMCArray'\n$P1[0] = $P0\n$P1[1] = $P0\n\u003c/pre\u003e\u003cp\u003e\nIn this case, the array contains two references to a single object, and we would expect that changing the value of the PMC in $P1[0] will also have an effect on the value in $P1[1]. A clone should follow these same semantics, I think.\n\u003c/p\u003e\n\n\u003cp\u003e\nThis kind of solution would also allow us to avoid cycles: When we find a nested reference to something we've already cloned, we just swap references with the clone and the new datastructure is properly self-referential too.\n\u003c/p\u003e\n\n\u003cp\u003e\nI would like to hear some feedback before attempting to implement this fix.\n\u003c/p\u003e","files":null},{"type":3,"author":{"id":"6d59fc378929d99368e023bcfc49aacae1e68aad"},"timestamp":1253223279,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDM1NzU=","github-url":"https://github.com/parrot/parrot/issues/558#issuecomment-3503575"},"message":"Trac commenter: Austin_Hastings\n\n\u003cpre class=\"wiki\"\u003eOn Thu, Sep 17, 2009 at 01:09:12PM -0000, Parrot wrote:\n\u0026gt;  I suggest that what we should do when cloning an aggregate is keep a cache\n\u0026gt;  of already-cloned PMCs, and when we reach a PMC reference that exists in\n\u0026gt;  the cache we can swap it out with the already-cloned PMC reference from\n\u0026gt;  the cache.\n\u0026gt;\n\u0026gt;  Looking at an example:\n\u0026gt;\n\u0026gt;  {{{\n\u0026gt;  $P0 = new 'Integer'\n\u0026gt;  $P1 = new 'ResizablePMCArray'\n\u0026gt;  $P1[0] = $P0\n\u0026gt;  $P1[1] = $P0\n\u0026gt;  }}}\n\u0026gt;\n\u0026gt;  In this case, the array contains two references to a single object, and we\n\u0026gt;  would expect that changing the value of the PMC in $P1[0] will also have\n\u0026gt;  an effect on the value in $P1[1]. A clone should follow these same\n\u0026gt;  semantics, I think.\n\u0026gt;\n\u0026gt;  This kind of solution would also allow us to avoid cycles: When we find a\n\u0026gt;  nested reference to something we've already cloned, we just swap\n\u0026gt;  references with the clone and the new datastructure is properly self-\n\u0026gt;  referential too.\n\u0026gt;\n\u0026gt;  I would like to hear some feedback before attempting to implement this\n\u0026gt;  fix.\nThis is certainly what Perl 5's Storable module does to detect things like\nthis, and I think what most of the dumper and cloner modules do.\nIn Perl 5 land, if we use a regular perl hash as the \"seen\" hash, it requires\nroughly the same amount of memory for itself as the structure being copied.\nIt's more efficient to use some sort of smaller structure, that is specialised\nto hash fixed length keys and fixed length values (void* and void*\nrespectively), but that could mean more code.\nHowever, I think that there is code (at least was, back in 2005) in Parrot\nto do this, used by the GC to track the set of externally rooted PMCs. So\nit might not be much more code - if what it has is custom hashing, key is\naddress, value is integer seen count, then the value becomes a union of seen\ncount (for the GC) and pointer (for this).\nNicholas Clark\n\u003c/pre\u003e","files":null},{"type":3,"author":{"id":"aa8915ba52969f979af836ca4704fd27e613004f"},"timestamp":1253325401,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDM1NzY=","github-url":"https://github.com/parrot/parrot/issues/558#issuecomment-3503576"},"message":"\u003cp\u003e\nGiven that this is being implemented in core, we can probably just add a temporary pointer in the PMC header to do the job. (return clone_ptr ? clone_ptr : (clone_ptr = do_clone(self)); )\n\u003c/p\u003e","files":null},{"type":3,"author":{"id":"aef4977f5ea786238d7c9581a2f192f4adc3f39d"},"timestamp":1253330442,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDM1Nzc=","github-url":"https://github.com/parrot/parrot/issues/558#issuecomment-3503577"},"message":"9995 byte attachment from Whiteknight\nat http://trac.parrot.org/parrot/raw-attachment/ticket/1015/clone.patch\n\n# ```Index: src/pmc.c\n\n--- src/pmc.c   (revision 41346)\n+++ src/pmc.c   (working copy)\n@@ -42,7 +42,32 @@\n     UINTVAL flags)\n         **attribute__nonnull**(1);\n\n+static void Parrot_pmc_free_clone_node(PARROT_INTERP,\n-    ARGMOD(PMC_clone_node *root))\n-        **attribute__nonnull**(1)\n-        **attribute__nonnull**(2)\n-        FUNC_MODIFIES(*root);\n  +\n  PARROT_CANNOT_RETURN_NULL\n  +static PMC_clone_node \\* Parrot_pmc_insert_clone_node(PARROT_INTERP,\n-    ARGMOD(PMC_clone_node \\* node),\n-    ARGIN(PMC \\* data),\n-    ARGIN(PMC *clone))\n-        **attribute__nonnull**(1)\n-        **attribute__nonnull**(2)\n-        **attribute__nonnull**(3)\n-        **attribute__nonnull**(4)\n-        FUNC_MODIFIES(\\* node);\n  +\n  +PARROT_CANNOT_RETURN_NULL\n  +static PMC_clone_node \\* Parrot_pmc_new_clone_node(PARROT_INTERP,\n-    ARGIN(PMC *self),\n-    ARGIN(PMC *clone))\n-        **attribute__nonnull**(1)\n-        **attribute__nonnull**(2)\n-        **attribute__nonnull**(3);\n  +\n  +PARROT_CANNOT_RETURN_NULL\n  static PMC\\* pmc_reuse_no_init(PARROT_INTERP,\n     ARGIN(PMC *pmc),\n     INTVAL new_type,\n  @@ -56,6 +81,18 @@\n      PARROT_ASSERT_ARG(interp)\n  #define ASSERT_ARGS_get_new_pmc_header **attribute__unused** int _ASSERT_ARGS_CHECK = \\\n        PARROT_ASSERT_ARG(interp)\n  +#define ASSERT_ARGS_Parrot_pmc_free_clone_node __attribute__unused__ int _ASSERT_ARGS_CHECK = \\\n-       PARROT_ASSERT_ARG(interp) \\\n-    || PARROT_ASSERT_ARG(root)\n  +#define ASSERT_ARGS_Parrot_pmc_insert_clone_node **attribute__unused** int _ASSERT_ARGS_CHECK = \\\n-       PARROT_ASSERT_ARG(interp) \\\n-    || PARROT_ASSERT_ARG(node) \\\n-    || PARROT_ASSERT_ARG(data) \\\n-    || PARROT_ASSERT_ARG(clone)\n  +#define ASSERT_ARGS_Parrot_pmc_new_clone_node **attribute__unused** int _ASSERT_ARGS_CHECK = \\\n-       PARROT_ASSERT_ARG(interp) \\\n-    || PARROT_ASSERT_ARG(self) \\\n-    || PARROT_ASSERT_ARG(clone)\n  #define ASSERT_ARGS_pmc_reuse_no_init **attribute__unused** int _ASSERT_ARGS_CHECK = \\\n        PARROT_ASSERT_ARG(interp) \\\n     || PARROT_ASSERT_ARG(pmc)\n  @@ -938,6 +975,109 @@\n  \n  /*\n\n+=item C\u003cINTVAL Parrot_pmc_start_clone_registry(PARROT_INTERP, PMC *self, PMC *clone)\u003e\n+\n+=item C\u003cvoid Parrot_pmc_clear_clone_registry(PARROT_INTERP)\u003e\n+\n+\n+*/\n+\n+PARROT_CAN_RETURN_NULL\n+PMC_clone_node *\n+Parrot_pmc_create_clone_registry(PARROT_INTERP, ARGIN(PMC *self))\n+{\n-    ASSERT_ARGS(Parrot_pmc_create_clone_registry)\n  +\n-    if(interp-\u003eclone_registry)\n-        return NULL;\n-    else {\n-        PMC_clone_node \\* const root =\n-            (PMC_clone_node *)Parrot_gc_allocate_fixed_size_storage(interp, sizeof (PMC_clone_node));\n-        root-\u003eold = self;\n-        root-\u003ebigger = NULL;\n-        root-\u003esmaller = NULL;\n-        interp-\u003eclone_registry = root;\n-        return root;\n-    }\n  +}\n  +\n  +void\n  +Parrot_pmc_set_clone_node(PARROT_INTERP, ARGIN(PMC_clone_node \\* node), ARGIN(PMC \\* clone))\n  +{\n-    ASSERT_ARGS(Parrot_pmc_set_clone_node)\n-    if(node == NULL)\n-        return;\n-    node-\u003eclone = clone;\n  +}\n  +\n  +PARROT_CAN_RETURN_NULL\n  +PMC *\n  +Parrot_pmc_find_registered_clone(PARROT_INTERP, ARGIN(PMC *self))\n  +{\n-    ASSERT_ARGS(Parrot_pmc_find_registered_clone)\n-    PMC_clone_node \\* node = interp-\u003eclone_registry;\n-    while (node != NULL) {\n-        PMC \\* const old = node-\u003eold;\n-        if (old == self)\n-            return node-\u003eclone;\n-        else if (old \u003c self)\n-            node = node-\u003ebigger;\n-        else\n-            node = node-\u003esmaller;\n-    }\n-    return NULL;\n  +}\n  +\n  +PARROT_CANNOT_RETURN_NULL\n  +static PMC_clone_node *\n  +Parrot_pmc_insert_clone_node(PARROT_INTERP, ARGMOD(PMC_clone_node \\* node), ARGIN(PMC \\* data), ARGIN(PMC *clone))\n  +{\n-    ASSERT_ARGS(Parrot_pmc_insert_clone_node)\n-    if (node == NULL)\n-        return Parrot_pmc_new_clone_node(interp, data, clone);\n-    else {\n-        PMC \\* const old = node-\u003eold;\n-        if (data \u003e old)\n-            node-\u003ebigger = Parrot_pmc_insert_clone_node(interp, node-\u003ebigger, data, clone);\n-        else\n-            node-\u003esmaller = Parrot_pmc_insert_clone_node(interp, node-\u003esmaller, data, clone);\n-    }\n  +}\n  +\n  +PARROT_CANNOT_RETURN_NULL\n  +static PMC_clone_node *\n  +Parrot_pmc_new_clone_node(PARROT_INTERP, ARGIN(PMC *self), ARGIN(PMC *clone))\n  +{\n-    ASSERT_ARGS(Parrot_pmc_new_clone_node)\n-    PMC_clone_node \\* const node = Parrot_gc_allocate_fixed_size_storage(interp, sizeof (PMC_clone_node));\n-    node-\u003eold = self;\n-    node-\u003eclone = clone;\n-    node-\u003ebigger = NULL;\n-    node-\u003esmaller = NULL;\n-    return node;\n  +}\n  +\n  +void\n  +Parrot_pmc_cleanup_clone_registry(PARROT_INTERP, ARGMOD(PMC_clone_node *root))\n  +{\n-    ASSERT_ARGS(Parrot_pmc_cleanup_clone_registry)\n-    Parrot_pmc_free_clone_node(interp, root);\n-    interp-\u003eclone_registry = NULL;\n  +}\n  +\n  +static void\n  +Parrot_pmc_free_clone_node(PARROT_INTERP, ARGMOD(PMC_clone_node *root))\n  +{\n-    ASSERT_ARGS(Parrot_pmc_free_clone_node)\n-    if (root-\u003ebigger != NULL)\n-        Parrot_pmc_free_clone_node(interp, root-\u003ebigger);\n-    if (root-\u003esmaller != NULL)\n-        Parrot_pmc_free_clone_node(interp, root-\u003esmaller);\n-    Parrot_gc_free_fixed_size_storage(interp, sizeof (PMC_clone_node), root);\n  +}\n  +\n  +/*\n  +\n  =back\n  \n  =head1 SEE ALSO\n  \n  # Index: src/interp/inter_create.c\n  \n  --- src/interp/inter_create.c   (revision 41346)\n  +++ src/interp/inter_create.c   (working copy)\n  @@ -130,6 +130,7 @@\n       interp = mem_allocate_zeroed_typed(Interp);\n  \n   interp-\u003elo_var_ptr = NULL;\n-    interp-\u003eclone_registry = NULL;\n  \n   /\\* the last interpreter (w/o) parent has to cleanup globals\n  - so remember parent if any */\n    \n    # Index: src/pmc/hash.pmc\n    \n    --- src/pmc/hash.pmc    (revision 41346)\n    +++ src/pmc/hash.pmc    (working copy)\n    @@ -434,11 +434,18 @@\n    */\n    \n    VTABLE PMC *clone() {\n-        PMC \\* const dest = pmc_new(INTERP, SELF-\u003evtable-\u003ebase_type);\n-        PMC_clone_node \\* const node = Parrot_pmc_create_clone_registry(INTERP, SELF);\n-        PMC \\* dest = Parrot_pmc_find_registered_clone(INTERP, SELF);\n-        if (!dest) {\n-            dest = pmc_new(INTERP, SELF-\u003evtable-\u003ebase_type);\n-            if (node)\n-                Parrot_pmc_set_clone_node(INTERP, node, dest);\n-            parrot_hash_clone(INTERP, (Hash *)SELF.get_pointer(),\n-                (Hash *)VTABLE_get_pointer(INTERP, dest));\n-        }\n-        if (node)\n- ```\n         Parrot_pmc_cleanup_clone_registry(INTERP, node);\n  ```\n- ```\n     parrot_hash_clone(INTERP, (Hash *)SELF.get_pointer(),\n  ```\n\n## \\-                   (Hash *)VTABLE_get_pointer(INTERP, dest));\n\n```\n     return dest;\n }\n```\n\n# Index: include/parrot/pmc.h\n\n--- include/parrot/pmc.h    (revision 41346)\n+++ include/parrot/pmc.h    (working copy)\n@@ -19,6 +19,7 @@\n\n #define PARROT_MAX_CLASSES 100\n\n+\n /\\* HEADERIZER BEGIN: src/pmc.c _/\n /_ Don't modify between HEADERIZER BEGIN / HEADERIZER END.  Your changes will be lost. */\n\n@@ -132,6 +133,30 @@\n INTVAL get_new_vtable_index(PARROT_INTERP)\n         **attribute__nonnull**(1);\n\n+void Parrot_pmc_cleanup_clone_registry(PARROT_INTERP,\n-    ARGMOD(PMC_clone_node *root))\n-        **attribute__nonnull**(1)\n-        **attribute__nonnull**(2)\n-        FUNC_MODIFIES(*root);\n  +\n  +PARROT_CAN_RETURN_NULL\n  +PMC_clone_node \\* Parrot_pmc_create_clone_registry(PARROT_INTERP,\n-    ARGIN(PMC *self))\n-        **attribute__nonnull**(1)\n-        **attribute__nonnull**(2);\n  +\n  +PARROT_CAN_RETURN_NULL\n  +PMC \\* Parrot_pmc_find_registered_clone(PARROT_INTERP, ARGIN(PMC *self))\n-        **attribute__nonnull**(1)\n-        **attribute__nonnull**(2);\n  +\n  +void Parrot_pmc_set_clone_node(PARROT_INTERP,\n-    ARGIN(PMC_clone_node \\* node),\n-    ARGIN(PMC \\* clone))\n-        **attribute__nonnull**(1)\n-        **attribute__nonnull**(2)\n-        **attribute__nonnull**(3);\n  +\n  void temporary_pmc_free(PARROT_INTERP, ARGMOD(PMC *pmc))\n         **attribute__nonnull**(1)\n         **attribute__nonnull**(2)\n  @@ -187,6 +212,22 @@\n   || PARROT_ASSERT_ARG(name)\n  #define ASSERT_ARGS_get_new_vtable_index **attribute__unused** int _ASSERT_ARGS_CHECK = \\\n        PARROT_ASSERT_ARG(interp)\n  +#define ASSERT_ARGS_Parrot_pmc_cleanup_clone_registry \\\n-     **attribute__unused** int _ASSERT_ARGS_CHECK = \\\n-       PARROT_ASSERT_ARG(interp) \\\n-    || PARROT_ASSERT_ARG(root)\n  +#define ASSERT_ARGS_Parrot_pmc_create_clone_registry \\\n-     **attribute__unused** int _ASSERT_ARGS_CHECK = \\\n-       PARROT_ASSERT_ARG(interp) \\\n-    || PARROT_ASSERT_ARG(self)\n  +#define ASSERT_ARGS_Parrot_pmc_find_registered_clone \\\n-     **attribute__unused** int _ASSERT_ARGS_CHECK = \\\n-       PARROT_ASSERT_ARG(interp) \\\n-    || PARROT_ASSERT_ARG(self)\n  +#define ASSERT_ARGS_Parrot_pmc_set_clone_node **attribute__unused** int _ASSERT_ARGS_CHECK = \\\n-       PARROT_ASSERT_ARG(interp) \\\n-    || PARROT_ASSERT_ARG(node) \\\n-    || PARROT_ASSERT_ARG(clone)\n  #define ASSERT_ARGS_temporary_pmc_free **attribute__unused** int _ASSERT_ARGS_CHECK = \\\n        PARROT_ASSERT_ARG(interp) \\\n     || PARROT_ASSERT_ARG(pmc)\n  Index: include/parrot/interpreter.h\n  ===================================================================\n  --- include/parrot/interpreter.h    (revision 41346)\n  +++ include/parrot/interpreter.h    (working copy)\n  @@ -177,6 +177,12 @@\n  */\n  #define CURRENT_CONTEXT(interp) ((interp)-\u003ectx)\n\n+typedef struct _PMC_clone_node {\n-    struct _PMC_clone_registry *bigger;\n-    struct _PMC_clone_registry *smaller;\n-    PMC\\* old;\n-    PMC\\* clone;\n  +} PMC_clone_node;\n  \n  typedef struct _context_mem {\n     void *_free_list;               /_ array of free-lists, per size free slots */\n  @@ -309,6 +315,7 @@\n  - inside the invoke these get moved to the context structure _/\n    PMC *current_cont;                        /_ the return continuation PMC _/\n    PMC *current_object;                      /_ invocant, if a method call */\n-    PMC_clone_node _clone_registry;           /_ registry to prevent cycles while cloning */\n  };\n  \n  /\\* typedef struct parrot_interp_t Interp;    done in parrot.h so that\n\n```\n```","files":null},{"type":3,"author":{"id":"aef4977f5ea786238d7c9581a2f192f4adc3f39d"},"timestamp":1253348442,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDM1Nzg=","github-url":"https://github.com/parrot/parrot/issues/558#issuecomment-3503578"},"message":"\u003cp\u003e\npatch that fixes the clone issue using a new \"clone registry\" API. PGE fails to build with this however\n\u003c/p\u003e","files":null},{"type":3,"author":{"id":"aef4977f5ea786238d7c9581a2f192f4adc3f39d"},"timestamp":1253348795,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDM1Nzk=","github-url":"https://github.com/parrot/parrot/issues/558#issuecomment-3503579"},"message":"\u003cp\u003e\nOkay, I've attached my first stab at a patch. This patch is not intended to be committed as-is.\n\u003c/p\u003e\n\n\u003cp\u003e\nI created a new set of API functions for a \"clone registry\". The registry keeps track of objects that have been cloned in the current operation, so we don't recurse. The API is ugly (I can already think of a few ways to make it better and more performant), but it appears to mostly work. A short test program segfaults before the patch, and doesn't segfault after it:\n\u003c/p\u003e\n\n\u003cpre class=\"wiki\"\u003e.sub main :main\n    $P0 = new 'Hash'\n    $S0 = \"Whatever\"\n    $P0[$S0] = $P0\n    $P1 = clone $P0\n    say \"Ok\"\n.end\n\u003c/pre\u003e\u003cp\u003e\nHowever, with this patch, PGE fails with a weird error:\n\u003c/p\u003e\n\u003cpre class=\"wiki\"\u003e../../parrot  /home/andrew/Projects/parrot/runtime/parrot/library/PGE/Perl6Grammar.pir \\\n        --output=src/Grammar_gen.pir src/Grammar.pg\nCan only replace inside string or index after end of string\ncurrent instr.: 'parrot;PGE;OPTable;newtok' pc 893 (compilers/pge/PGE/OPTable.pir:158)\ncalled from Sub 'parrot;PGE;P5Regex;__onload' pc 12224 (compilers/pge/PGE/P5Regex.pir:86)\ncalled from Sub 'parrot;PGE;Perl6Grammar;Compiler;__onload' pc 24 (/home/andrew/Projects/parrot/runtime/parrot/library/PGE/Perl6Grammar.pir:75)\n\u003c/pre\u003e\u003cp\u003e\nso once we fix this PGE issue, rework the API to be better and clean up the patch a little bit, this should be what we need.\n\u003c/p\u003e\n\n\u003cp\u003e\nThis patch only currently prevents recursions in Hash. I haven't used the new API in any other aggregate types where it is probably necessary to prevent recursions. Once we get everything working we will probably want to apply it to more PMC types to prevent issues from developing there too.\n\u003c/p\u003e","files":null},{"type":3,"author":{"id":"aef4977f5ea786238d7c9581a2f192f4adc3f39d"},"timestamp":1253383788,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDM1ODA=","github-url":"https://github.com/parrot/parrot/issues/558#issuecomment-3503580"},"message":"\u003cpre class=\"wiki\"\u003echromatic has a great point here, there's no reason why we couldn't\nfind a general solution to it. The basic requirements are (1) to store\na list of objects that have already been traversed (possibly with\nmetadata like a cloned version) and (2) be able to search for and\nreturn the record of that traversal along with the associated\nmetadata.\nDeep clone and PMC freeze are probably the best two candidates for a\nchange like this (I'm actually surprised we haven't seen more\nsegfaults in the past because of cyclic structures!). GC mark is a\nlittle different because the PMC structure uses flags and other\npointers to keep track of which objects have been marked, and a\ngeneral solution might not work in all possible cores.\nThe patch I posted on TT #1015 is mostly a proof-of-concept that we\ncan resolve the particular segfault problem by caching\npreviously-traversed aggregates. As I've mentioned before, if we want\nclone to preserve relationships between objects (repeated references),\nwe'll also want to cache everything that gets cloned. Take this for\nexample:\n$P0 = new 'ResizablePMCArray'\n$P0[0] = $P1\n$P0[1] = $P1\n$P2 = clone $P0\nHere the data structure $P0 consists of two PMCs, while currently the\nclone $P2 contains three! The two objects, though \"clones\", will\nhardly behave similarly.\nThis brings us to two questions:\n1) What is a generalized API for solving all these problems going to look like?\n2) How widespread do we want it's use to be? Is the PIR example above\na problem for people?\n--Andrew Whitworth\nOn Fri, Sep 18, 2009 at 9:54 PM, chromatic \u0026lt;chromatic@wgz.org\u0026gt; wrote:\n\u0026gt; On Friday 18 September 2009 18:26:35 Parrot wrote:\n\u0026gt;\n\u0026gt;\u0026gt;  I created a new set of API functions for a \"clone registry\". The registry\n\u0026gt;\u0026gt;  keeps track of objects that have been cloned in the current operation, so\n\u0026gt;\u0026gt;  we don't recurse. The API is ugly (I can already think of a few ways to\n\u0026gt;\u0026gt;  make it better and more performant), but it appears to mostly work.\n\u0026gt;\n\u0026gt; Note that \"freeze\", \"deep clone\", and \"GC mark\" are all so conceptually\n\u0026gt; similar that they're the same problem: traversing a cyclic graph while\n\u0026gt; avoiding cycles.\n\u0026gt;\n\u0026gt; If we can solve it for one case, perhaps we can solve it for all cases.\n\u0026gt;\n\u0026gt; -- c\n\u0026gt; _______________________________________________\n\u0026gt; parrot-tickets mailing list\n\u0026gt; parrot-tickets@lists.parrot.org\n\u0026gt; http://lists.parrot.org/mailman/listinfo/parrot-tickets\n\u0026gt;\n\u003c/pre\u003e","files":null},{"type":3,"author":{"id":"0782f66a529ccd24e18226f5eebab20a90bea166"},"timestamp":1253413702,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDM1ODE=","github-url":"https://github.com/parrot/parrot/issues/558#issuecomment-3503581"},"message":"\u003cpre class=\"wiki\"\u003eOn Fri, Sep 18, 2009 at 9:54 PM, chromatic \u0026lt;chromatic@wgz.org\u0026gt; wrote:\n\u0026gt; On Friday 18 September 2009 18:26:35 Parrot wrote:\n\u0026gt;\n\u0026gt;\u0026gt;  I created a new set of API functions for a \"clone registry\". The registry\n\u0026gt;\u0026gt;  keeps track of objects that have been cloned in the current operation, so\n\u0026gt;\u0026gt;  we don't recurse. The API is ugly (I can already think of a few ways to\n\u0026gt;\u0026gt;  make it better and more performant), but it appears to mostly work.\n\u0026gt;\n\u0026gt; Note that \"freeze\", \"deep clone\", and \"GC mark\" are all so conceptually\n\u0026gt; similar that they're the same problem: traversing a cyclic graph while\n\u0026gt; avoiding cycles.\nSee also the dumper lib.\n\u0026gt; If we can solve it for one case, perhaps we can solve it for all cases.\n\u0026gt;\n\u0026gt; -- c\n\u0026gt; _______________________________________________\n\u0026gt; parrot-tickets mailing list\n\u0026gt; parrot-tickets@lists.parrot.org\n\u0026gt; http://lists.parrot.org/mailman/listinfo/parrot-tickets\n\u0026gt;\n--\nWill \"Coke\" Coleda\n\u003c/pre\u003e","files":null},{"type":3,"author":{"id":"d9b4aee65ce8c18d4a43eced1eecb0d154e1eebb"},"timestamp":1298626566,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDM1ODI=","github-url":"https://github.com/parrot/parrot/issues/558#issuecomment-3503582"},"message":"\u003cp\u003e\nwhiteknight,\n\u003c/p\u003e\n\n\u003cp\u003e\nCan we get an update on the status of issues discussed in this ticket?\n\u003c/p\u003e\n\n\u003cp\u003e\nThank you very much.\n\u003c/p\u003e\n\n\u003cp\u003e\nkid51\n\u003c/p\u003e","files":null}]}