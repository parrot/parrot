{"version":1,"ops":[{"type":3,"author":{"id":"2e07d1e375724352b47c35e84b16d7b9852990d2"},"timestamp":1261446713,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDMwNzE=","github-url":"https://github.com/parrot/parrot/issues/419#issuecomment-3503071"},"message":"16313 byte attachment from kurahaupo\nat http://trac.parrot.org/parrot/raw-attachment/ticket/1386/exporter.t.patch\n\n# ```Index: t/pmc/exporter.t\n\n--- t/pmc/exporter.t    (revision 43187)\n+++ t/pmc/exporter.t    (working copy)\n@@ -1,13 +1,7 @@\n-#!perl\n-# Copyright (C) 2007, Parrot Foundation.\n+#!parrot\n+# Copyright (C) 2009, Parrot Foundation.\n # $Id$\n\n-use strict;\n-use warnings;\n-use lib qw( . lib ../lib ../../lib );\n-use Test::More;\n\n## -use Parrot::Test tests =\u003e 12;\n\n =head1 NAME\n\n t/pmc/exporter.t - test the Exporter PMC\n@@ -23,143 +17,152 @@\n =cut\n\n # L\u003cPDD17/Exporter PMC\u003e\n-pir_output_is( \u003c\u003c'CODE', \u003c\u003c'OUT', 'new' );\n-.sub 'test' :main\n+\n+.sub 'main' :main\n-    .include 'test_more.pir'\n-    plan(28)\n  +\n  +#\n  +# Arguably the rest of this file is moot, since if we can import test_more.pir\n  +# and use it, exporter.pir has already been tested. However our point is to\n  +# ensure exhausive testing, and to document any failures in a sensible manner,\n  +# so we press on...\n  +#\n  +\n-    test_new_exporter()         # 5 tests\n-    test_source()               # 4 tests\n-    test_destination()          # 5 tests\n  +\n-    $P0 = get_global ['test_globals'], 'test'\n-    $P0()                       # 6 tests\n  +\n-    $P0 = get_global ['test_import_without_args'], 'test'\n-    $P0()                       # 1 test\n  +\n-    $P0 = get_global ['test_import_with_s_d_g'], 'test'\n-    $P0()                       # 1 test\n  +\n-    $P0 = get_global ['test_import_with_s_gs'], 'test'\n-    $P0()                       # 1 test\n  +\n-    $P0 = get_global ['test_import_with_gs'], 'test'\n-    $P0()                       # 1 test\n  +\n-    $P0 = get_global ['test_import_with_s_ga'], 'test'\n-    $P0()                       # 1 test\n  +\n-    $P0 = get_global ['test_import_with_s_gh'], 'test'\n-    $P0()                       # 1 test\n  +\n-    $P0 = get_global ['test_import_and_call'], 'test'\n-    $P0()                       # 1 test\n  +\n-    $P0 = get_global ['test_import_and_ind_call'], 'test'\n-    $P0()                       # 1 test\n  +\n  +\n  +.end\n  +\n  +.sub 'test_new_exporter'\n   $P0 = new ['Exporter']\n-    say \"ok 1 - $P0 = new ['Exporter']\"\n-    $I0 = isnull $P0\n-    is( $I0, 0, 'Constructed \"Exporter\" object' )\n  \n   $I0 = isa $P0, 'Exporter'\n-    if $I0 goto ok_2\n-    print 'not '\n-  ok_2:\n-    say \"ok 2 - isa $P0, 'Exporter'\"\n-    ok( $I0, '... isa \"Exporter\"' )\n  +\n-    $I0 = can $P0, 'source'\n-    ok( $I0, '... can \"source\"' )\n  +\n-    $I0 = can $P0, 'destination'\n-    ok( $I0, '... can \"destination\"' )\n  +\n-    $I0 = can $P0, 'import'\n-    ok( $I0, '... can \"import\"' )\n  .end\n  -CODE\n  -ok 1 - $P0 = new ['Exporter']\n  -ok 2 - isa $P0, 'Exporter'\n  -OUT\n\n-pir_output_is( \u003c\u003c'CODE', \u003c\u003c'OUT', 'source' );\n-.sub 'test' :main\n+.sub 'test_source'\n     $P0 = new ['Exporter']\n     $P1 = $P0.'source'()\n-    if null $P1 goto ok_1\n-    print 'not '\n-  ok_1:\n-    say 'ok 1 - source() returns PMCNULL upon Exporter init'\n-    $I0 = isnull $P1\n-    ok( $I0, 'source() returns PMCNULL upon Exporter init' )\n  \n   # get a NameSpace PMC for testing\n-    # TT #1233 replace with make_namespace, when implemented\n-    .local pmc ns\n-    ns = get_namespace ['Eponymous']\n-    # RT #46859 replace with make_namespace, when implemented\n-    $P98 = get_namespace ['Eponymous']\n-    $P0.'source'(ns)\n-    $P0.'source'($P98)\n   $P1 = $P0.'source'()\n-    if $P1 == 'Eponymous' goto ok_2\n-    print 'not '\n-  ok_2:\n-    say 'ok 2 - source() with args sets source namespace'\n-    is( $P1, 'Eponymous', '... with args sets source namespace' )\n\n## \\-    $P1 = clone ns\n-    $P1 = clone $P98\n-    $I0 = 1\n   push_eh ok_3\n-    $P0.'source'(ns, $P1)\n-    $P0.'source'($P98, $P1)\n-    $I0 = 0\n-  ok_3:\n   pop_eh\n-    ok( $I0, '... with too many args throws exception' )\n-    print 'not '\n-  ok_3:\n\n## \\-    say 'ok 3 - source() with too many args fails'\n-    $I0 = 1\n   push_eh ok_4\n   $P0.'source'('foo')\n-    pop_eh\n-    print 'not '\n-    $I0 = 0\n  \n  ok_4:\n-    say 'ok 4 - source() with non-namespace arg throws exception'\n-    pop_eh\n-    ok( $I0, '... with non-namespace arg throws exception' )\n  .end\n\n## \n\n-# TT #1233 replace with make_namespace, when implemented\n-.namespace ['Eponymous']\n-.sub 'Eponymous' :anon\n-.end\n-CODE\n-ok 1 - source() returns PMCNULL upon Exporter init\n-ok 2 - source() with args sets source namespace\n-ok 3 - source() with too many args fails\n-ok 4 - source() with non-namespace arg throws exception\n\n## -OUT\n\n-pir_output_is( \u003c\u003c'CODE', \u003c\u003c'OUT', 'destination' );\n-.sub 'test' :main\n+.sub 'test_destination'\n     $P0 = new ['Exporter']\n     $P1 = $P0.'destination'()\n-    unless null $P1 goto ok_1\n-    print 'not '\n-  ok_1:\n-    say 'ok 1 - destination() with no args returns destination namespace'\n-    $I0 = isnull $P1\n-    is( $I0, 0, 'destination() with no args returns destination namespace' )\n  \n   $P99 = get_namespace\n-    if $P1 == $P99 goto ok_2\n-    print 'not '\n-  ok_2:\n-    say 'ok 2 - ...which is current namespace at first'\n-    is( $P1, $P99, '... which is current namespace at first' )\n  \n   # get a NameSpace PMC for testing\n-    # TT #1233 replace with make_namespace, when implemented\n-    .local pmc ns\n-    ns = get_namespace ['Eponymous']\n-    # RT #46859 replace with make_namespace, when implemented\n-    $P98 = get_namespace ['Eponymous']\n-    $P0.'destination'(ns)\n-    $P0.'destination'($P98)\n   $P1 = $P0.'destination'()\n-    if $P1 == 'Eponymous' goto ok_3\n-    print 'not '\n-  ok_3:\n-    say 'ok 3 - destination() with args sets destination namespace'\n-    is( $P1, 'Eponymous', '... with args sets destination namespace' )\n\n## \\-    $P1 = clone ns\n-    $P1 = clone $P98\n-    $I0 = 1\n   push_eh ok_4\n-    $P0.'destination'(ns, $P1)\n-    $P0.'destination'($P98, $P1)\n-    $I0 = 0\n-  ok_4:\n   pop_eh\n-    ok( $I0, '... with too many args throws exception' )\n-    print 'not '\n-  ok_4:\n\n## \\-    say 'ok 4 - destination() with too many args fails'\n-    $I0 = 1\n   push_eh ok_5\n   $P0.'destination'('foo')\n-    $I0 = 0\n-  ok_5:\n   pop_eh\n-    print 'not '\n-    ok( $I0, '... with non-namespace arg throws exception' )\n-  ok_5:\n-    say 'ok 5 - destination() with non-namespace arg throws exception'\n  .end\n\n## \n\n-# TT #1233 replace with make_namespace, when implemented\n+# RT #46859 replace with make_namespace, when implemented\n .namespace ['Eponymous']\n .sub 'Eponymous' :anon\n .end\n-CODE\n-ok 1 - destination() with no args returns destination namespace\n-ok 2 - ...which is current namespace at first\n-ok 3 - destination() with args sets destination namespace\n-ok 4 - destination() with too many args fails\n-ok 5 - destination() with non-namespace arg throws exception\n-OUT\n\n-pir_output_is( \u003c\u003c'CODE', \u003c\u003c'OUT', 'globals' );\n-.sub 'test' :main\n+\n+.namespace ['test_globals']\n+.sub 'test'\n     $P0 = new ['Exporter']\n\n```\n $P1 = $P0.'globals'()\n $I0 = isnull $P1\n```\n-    if $I0 goto ok_1\n-    print 'not '\n-  ok_1:\n-    say 'ok 1 - globals() returns PMCNULL upon Exporter init'\n-    ok( $I0, 'globals() returns PMCNULL upon Exporter init' )\n  \n   # create an array to store globals in\n   $P99 = new ['ResizableStringArray']\n  @@ -167,30 +170,29 @@\n   $P0.'globals'($P99)\n   $P1 = $P0.'globals'()\n   $I0 = isnull $P1\n-    if $I0 goto ok_2\n-    print 'not '\n-  ok_2:\n-    say 'ok 2 - globals() with empty array arg sets PMCNULL'\n-    ok( $I0, '... with empty array arg sets PMCNULL' )\n  \n   $P99 = push 'Alex'\n   $P99 = push 'Prince'\n-    $I9 = 1\n   $P0.'globals'($P99)\n   $P1 = $P0.'globals'()\n   $I0 = does $P1, 'hash'\n-    eq $I0, 0, nok_3\n   $I99 = $P99\n   $I1 = $P1\n-    unless $I0 == 1 goto nok_3\n-    unless $I1 == $I99 goto nok_3\n-    unless $I1 == 2 goto ok_3\n-    ne $I1, $I99, nok_3\n-    ne $I1, 2, ok_3     # \u003c\u003c\u003c should this be nok_3 instead?!?\n   $I0 = exists $P1['Prince']\n-    unless $I0 goto nok_3\n-    eq $I0, 0, nok_3\n   $I0 = exists $P1['Alex']\n-    eq $I0, 0, nok_3\n   goto ok_3\n  nok_3:\n-    print 'not '\n-    $I9 = 0\n  ok_3:\n-    say 'ok 3 - globals() with array arg sets globals hash (hash with two keys)'\n-    ok( $I9, '... with array arg sets globals hash (hash with two keys)' )\n  \n   # create a hash to store globals in\n   $P99 = new ['Hash']\n  @@ -198,219 +200,159 @@\n   $P0.'globals'($P99)\n   $P1 = $P0.'globals'()\n   $I0 = isnull $P1\n-    if $I0 goto ok_4\n-    print 'not '\n-  ok_4:\n-    say 'ok 4 - globals() with empty hash arg sets PMCNULL'\n-    ok( $I0, '... with empty hash arg sets PMCNULL' )\n  \n   $P99['Prince'] = ''\n   $P99['Alex'] = ''\n-    $I9 = 1\n   $P0.'globals'($P99)\n   $P1 = $P0.'globals'()\n   $I99 = $P99\n   $I1 = $P1\n-    unless $I1 == $I99 goto nok_5\n-    unless $I1 == 2 goto nok_5\n-    ne $I1, $I99, nok_5\n-    ne $I1, 2, nok_5\n   $I0 = exists $P1['Prince']\n-    unless $I0 goto nok_5\n-    eq $I0, 0, nok_5\n   $I0 = exists $P1['Alex']\n-    unless $I0 goto nok_5\n-    eq $I0, 0, nok_5\n   goto ok_5\n  nok_5:\n-    print 'not '\n-    $I9 = 0\n  ok_5:\n-    say 'ok 5 - globals() with hash arg sets globals hash (hash with two keys)'\n-    ok( $I9, '... with hash arg sets globals hash (hash with two keys)' )\n\n## \n\n```\n $P98 = clone $P99\n```\n-    $I9 = 1\n   push_eh ok_6\n   $P0.'globals'($P99, $P98)\n-    $I9 = 0\n-  ok_6:\n   pop_eh\n-    ok( $I9, '... with too many args throws exception' )\n-    print 'not '\n-  ok_6:\n\n## \\-    say 'ok 6 - globals() with too many args fails'\n\n .end\n-CODE\n-ok 1 - globals() returns PMCNULL upon Exporter init\n-ok 2 - globals() with empty array arg sets PMCNULL\n-ok 3 - globals() with array arg sets globals hash (hash with two keys)\n-ok 4 - globals() with empty hash arg sets PMCNULL\n-ok 5 - globals() with hash arg sets globals hash (hash with two keys)\n-ok 6 - globals() with too many args fails\n-OUT\n\n-pir_error_output_like( \u003c\u003c'CODE', \u003c\u003c'OUT', 'import - no args' );\n-.sub 'test' :main\n+.namespace ['test_import_without_args']\n+.sub 'test'\n     $P0 = new ['Exporter']\n-    $I0 = 1\n-    push_eh e1\n   $P0.'import'()\n\n## \\-    say 'ok 1 - import() with no args throws an exception'\n-    $I0 = 0\n  +e1:\n-    pop_eh\n  +# /^source namespace not set\\n/\n-    ok( $I0, 'import() with no args throws exception' )\n  .end\n  -CODE\n  -/^source namespace not set\\n/\n  -OUT\n\n-pir_output_is( \u003c\u003c'CODE', \u003c\u003c'OUT', 'import - same source and destination namespaces' );\n-.sub 'test' :main\n-    .local pmc exporter, src\n  +.namespace ['test_import_with_s_d_g']\n  +.sub 'test'\n-    $P99 = get_namespace\n\n## \\-    src      = get_namespace\n-    exporter = new ['Exporter']\n-    exporter.'import'( src :named('source'), src :named('destination'), 'plan ok' :named('globals') )\n-    plan(1)\n-    ok(1)\n-    $P97 = new ['Exporter']\n-    $I0 = 0\n-    push_eh e1\n-    $P97.'import'( $P99 :named('source'), $P99 :named('destination'), 'plan ok' :named('globals') )\n-    $I0 = 1\n  +e1:\n-    pop_eh\n-    ok( $I0, '... idempotently does nothing (and succeeds)' )\n  .end\n  \n  .sub 'plan'\n-    .param int one\n-    say '1..1'\n-    die 'Extra planning was not expected'\n  .end\n  \n  .sub 'ok'\n-    .param int one\n-    say 'ok 1'\n-    .param pmc args :slurpy\n-    $P0 = get_root_global [ 'parrot'; 'Test'; 'More' ], 'ok'\n-    $P0( args :flat )\n  .end\n  -CODE\n  -1..1\n  -ok 1\n  -OUT\n\n-pir_output_is( \u003c\u003c'CODE', \u003c\u003c'OUT', 'import - globals as string' );\n-.sub 'test' :main\n-    load_bytecode 'Test/More.pbc'\n\n## \\-    .local pmc exporter, src\n\n## \\-    src      = get_namespace [ 'Test'; 'More' ]\n-    exporter = new ['Exporter']\n-    exporter.'import'( src :named('source'), 'plan ok' :named('globals') )\n-    plan(1)\n-    ok(1)\n  +.namespace ['test_import_with_s_gs']\n  +.sub 'test'\n-    $P99 = get_root_namespace [ 'parrot'; 'Test'; 'More' ]\n-    $P97 = new ['Exporter']\n-    $P97.'import'( $P99 :named('source'), 'plan ok' :named('globals') )\n-    ok( 1, '... with globals-as-string succeeds' )\n  .end\n  -CODE\n  -1..1\n  -ok 1\n  -OUT\n\n-pir_output_is( \u003c\u003c'CODE', \u003c\u003c'OUT', 'import - globals with source passed separately' );\n-.sub 'test' :main\n-    load_bytecode 'Test/More.pbc'\n-    .local pmc exporter, src\n  +.namespace ['test_import_with_gs']\n  +.sub 'test'\n-    $P99 = get_root_namespace [ 'parrot'; 'Test'; 'More' ]\n\n## \\-    src      = get_namespace [ 'Test'; 'More' ]\n-    exporter = new ['Exporter']\n-    exporter.'source'( src )\n-    exporter.'import'( 'plan ok' :named('globals') )\n-    plan(1)\n-    ok(1)\n-    $P97 = new ['Exporter']\n-    $P97.'source'( $P99 )\n-    $P97.'import'( 'plan ok' :named('globals') )\n-    ok( 1, '... having called \"source\" separately succeeds' )\n  .end\n  -CODE\n  -1..1\n  -ok 1\n  -OUT\n\n-pir_output_is( \u003c\u003c'CODE', \u003c\u003c'OUT', 'import - globals as array' );\n-.sub 'test' :main\n-    load_bytecode 'Test/More.pbc'\n-    .local pmc exporter, src, globals\n  +.namespace ['test_import_with_s_ga']\n  +.sub 'test'\n-    $P99 = get_root_namespace [ 'parrot'; 'Test'; 'More' ]\n-    $P96 = new ['ResizableStringArray']\n-    $P96 = push 'ok'\n-    $P96 = push 'plan'\n-    src     = get_namespace [ 'Test'; 'More' ]\n-    globals = new ['ResizableStringArray']\n-    globals = push 'ok'\n\n## \\-    globals = push 'plan'\n-    exporter = new ['Exporter']\n-    exporter.'import'( src :named('source'), globals :named('globals') )\n-    plan(1)\n-    ok(1)\n-    $P97 = new ['Exporter']\n-    $P97.'import'( $P99 :named('source'), $P96 :named('globals') )\n-    ok( 1, '... with globals-as-array succeeds' )\n  .end\n  -CODE\n  -1..1\n  -ok 1\n  -OUT\n\n-pir_output_is( \u003c\u003c'CODE', \u003c\u003c'OUT', 'import - globals as hash - null + empty string' );\n-.sub 'test' :main\n-    load_bytecode 'Test/More.pbc'\n-    .local pmc exporter, src, globals, nul\n  +.namespace ['test_import_with_s_gh']\n  +.sub 'test'\n-    $P95 = new ['Null']\n-    $P99 = get_root_namespace [ 'parrot'; 'Test'; 'More' ]\n-    $P96 = new ['Hash']\n-    $P96['ok'] = $P95\n-    $P96['plan'] = ''\n-    nul     = new ['Null']\n-    src     = get_namespace [ 'Test'; 'More' ]\n-    globals = new ['Hash']\n-    globals['ok'] = nul\n\n## \\-    globals['plan'] = ''\n-    exporter = new ['Exporter']\n-    exporter.'import'( src :named('source'), globals :named('globals') )\n-    plan(1)\n-    ok(1)\n-    $P97 = new ['Exporter']\n-    $P97.'import'( $P99 :named('source'), $P96 :named('globals') )\n-    ok( 1, '... with globals-as-hash succeeds' )\n  .end\n  -CODE\n  -1..1\n  -ok 1\n  -OUT\n\n-pir_output_is( \u003c\u003c'CODE', \u003c\u003c'OUT', 'import - globals as hash - with dest names (latin)' );\n-.sub 'test' :main\n-    load_bytecode 'Test/More.pbc'\n-    .local pmc exporter, src, globals\n  +.namespace ['test_import_and_call']\n  +.sub 'test'\n-    $P99 = get_root_namespace [ 'parrot'; 'Test'; 'More' ]\n-    $P96 = new ['Hash']\n-    $P96['plan'] = 'consilium'\n-    $P96['ok'] = 'rectus'\n-    src     = get_namespace [ 'Test'; 'More' ]\n-    globals = new ['Hash']\n-    globals['plan'] = 'consilium'\n\n## \\-    globals['ok'] = 'rectus'\n-    exporter = new ['Exporter']\n-    exporter.'import'( src :named('source'), globals :named('globals') )\n-    consilium(1)\n-    rectus(1)\n-    $P97 = new ['Exporter']\n-    $P97.'import'( $P99 :named('source'), $P96 :named('globals') )\n-    #consilium(1)\n-    rectus( 1, '... into current namespace with another (global) name succeeds' )\n  .end\n  -CODE\n  -1..1\n  -ok 1\n  -OUT\n\n-pir_output_is( \u003c\u003c'CODE', \u003c\u003c'OUT', 'import - globals with destination' );\n-.sub 'test' :main\n-    load_bytecode 'Test/More.pbc'\n-    .local pmc exporter, src, dest, globals\n  +.namespace ['test_import_and_ind_call']\n  +.sub 'test'\n-    $P99 = get_root_namespace [ 'parrot'; 'Test'; 'More' ]\n-    $P98 = get_root_namespace [ 'parrot'; 'foo' ]\n-    $P96 = new ['ResizableStringArray']\n-    $P96 = push 'ok'\n-    $P96 = push 'plan'\n-    src     = get_namespace [ 'Test'; 'More' ]\n-    dest    = get_namespace ['foo']\n-    globals = new ['ResizableStringArray']\n-    globals = push 'ok'\n-    globals = push 'plan'\n-    $P97 = new ['Exporter']\n-    $P97.'import'( $P99 :named('source'), $P98 :named('destination'), $P96 :named('globals') )\n-    exporter = new ['Exporter']\n\n## \\-    exporter.'import'( src :named('source'), dest :named('destination'), globals :named('globals') )\n-    $P0 = get_global ['foo'], 'bar'\n-    $P0 = get_root_global [ 'parrot'; 'foo' ], 'bar'\n   $P0()\n  .end\n  \n  .namespace ['foo']\n  .sub 'bar'\n-    plan(1)\n-    ok(1)\n-    ok( 1, '... into another namespace succeeds' )\n  .end\n  -CODE\n  -1..1\n  -ok 1\n  -OUT\n\n-# TODO: Test exporting mmd subs: TT #1205\n-# https://trac.parrot.org/parrot/ticket/1205\n+# RT #46861 test exporting mmd subs\n\n # Local Variables:\n-#   mode: cperl\n+#   mode: pir\n #   cperl-indent-level: 4\n #   fill-column: 100\n # End:\n-# vim: expandtab shiftwidth=4:\n+# vim: expandtab shiftwidth=4 ft=pir:\n\n```\n```","files":null},{"type":3,"author":{"id":"2e07d1e375724352b47c35e84b16d7b9852990d2"},"timestamp":1261468202,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDMwNzI=","github-url":"https://github.com/parrot/parrot/issues/419#issuecomment-3503072"},"message":"\u003cp\u003e\nIn a number of places I had to use get_root_namespace or get_root_global rather than get_namespace or get_global. I'm not really clear why this was necessary, and the mixture seems quite untidy, so I welcome feedback on where I've gone wrong with this.\n\u003c/p\u003e","files":null},{"type":3,"author":{"id":"2e07d1e375724352b47c35e84b16d7b9852990d2"},"timestamp":1261468313,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDMwNzM=","github-url":"https://github.com/parrot/parrot/issues/419#issuecomment-3503073"},"message":"\u003cp\u003e\nConvert t/pmc/exporter.t to PIR\n\u003c/p\u003e","files":null},{"type":3,"author":{"id":"2e07d1e375724352b47c35e84b16d7b9852990d2"},"timestamp":1261494003,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDMwNzQ=","github-url":"https://github.com/parrot/parrot/issues/419#issuecomment-3503074"},"message":"\u003cp\u003e\nFYI this is based on (but not identical) to \u003ca class=\"closed ticket\" href=\"http://trac.parrot.org/parrot/ticket/1090\" title=\"patch: Convert t/pmc/exporter.t to PIR (closed: done)\"\u003e#1090\u003c/a\u003e\n\u003c/p\u003e","files":null},{"type":3,"author":{"id":"56b030459ff5c3e63b58d71e1bed10897e6a7686"},"timestamp":1282223288,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDMwNzU=","github-url":"https://github.com/parrot/parrot/issues/419#issuecomment-3503075"},"message":"\u003cp\u003e\nThis patch no longer applies; would you mind rebasing it for easier application?\n\u003c/p\u003e","files":null},{"type":3,"author":{"id":"d9b4aee65ce8c18d4a43eced1eecb0d154e1eebb"},"timestamp":1299402592,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDMwNzY=","github-url":"https://github.com/parrot/parrot/issues/419#issuecomment-3503076"},"message":"\u003cp\u003e\nI spent a couple of hours tonight trying to rewrite the test following the patch.  I did not get very far.\n\u003c/p\u003e\n\n\u003cp\u003e\nUnless the original poster wants to update the patch, I think we should reject it.\n\u003c/p\u003e\n\n\u003cp\u003e\nThank you very much.\n\u003c/p\u003e\n\n\u003cp\u003e\nkid51\n\u003c/p\u003e","files":null}]}