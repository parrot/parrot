{"version":1,"ops":[{"type":3,"author":{"id":"2da6485217cbb88ff96be8f3dcc7f9ae44cf6bf0"},"timestamp":1357256822,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDExODY2NDU4","github-url":"https://github.com/parrot/parrot/issues/909#issuecomment-11866458"},"message":"@rurban do you have the tuits to write a test for this?\n\nUnless I hear otherwise from core Rakudo devs, I will assume they want the original behavior, since they inherited this change from an unintended Parrot change.\n\n@Whiteknight just to verify, was this an unintended change due to the refactor, or was this a conscious change of behavior?","files":null},{"type":3,"author":{"id":"86141a663c2eb7543d1a51ec6253a1d54de912fd"},"timestamp":1357258718,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDExODY3Mjk3","github-url":"https://github.com/parrot/parrot/issues/909#issuecomment-11867297"},"message":"http://pubs.opengroup.org/onlinepubs/009695399/functions/read.html\n_If fildes refers to a socket, read() shall be equivalent to recv() with no flags set._\n\nThe POSIX spec say that the $bytes parameter to socket.read contains the max buffer size to be returned, and the actual read buffer size is returned. \n\nBut there is an option to specify the behavior we had before:\n\"The receive low-water mark (the SO_RCVLOWAT setsockopt option) determines the minimum amount of data that must be received before the read function is completed. If the read function times out, any data that was received is returned to the application even if the amount of data received is less than the receive low-water mark value.\"\n\nI suggest we keep our new implementation which matches the C specs (and perl5 IO::Socket). \nThe user should not be able to come up with an artifical socket buffer size, and force the library to follow that size.\n\n```\n#include  \u003csys/socket.h\u003e\nint       read(int s,\n               char *buf,\n               int len);\ns   The socket descriptor.\nbuf Pointer to the buffer that receives the data.\nlen  Length, in bytes, of the buffer pointed to by the buf parameter. The maximum amount of data that can be received is 65535 bytes.\n```\n\nSo we need to change our docs.\n\nProblem is that we have a low-level API method socket.recv() which does it like POSIX, and a high-level API \nmethod read() which docs said to always return the wanted number of bytes.\n\n_METHOD read(INTVAL bytes)_\n\n```\nRead the given number of bytes from the socket and return them in a string.\n```\n\nImplemented by the same function Parrot_io_read_s(), which does the wanted high-level buffering already.","files":null},{"type":3,"author":{"id":"86141a663c2eb7543d1a51ec6253a1d54de912fd"},"timestamp":1357839759,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDEyMTA5MDM1","github-url":"https://github.com/parrot/parrot/issues/909#issuecomment-12109035"},"message":"Fixed our docs. Added api.yaml entry. \n\nrakudo also fixed their implementation of IO::Socket. https://github.com/rakudo/rakudo/commit/d2d2c85079c47314e653e5881258af2c8d66ea30\n\nThere are two pending branches, which I try out: \n`rurban/socket-read2-gh909` (setsockopt on every overlarge read, send) and `rurban/sockopt-gh909` (provide opt methods)","files":null},{"type":4,"author":{"id":"86141a663c2eb7543d1a51ec6253a1d54de912fd"},"timestamp":1357839760,"metadata":{"github-id":"MDExOkNsb3NlZEV2ZW50MzQwMDI1MTY="},"status":2}]}