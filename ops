{"version":1,"ops":[{"type":3,"author":{"id":"6d59fc378929d99368e023bcfc49aacae1e68aad"},"timestamp":1281124702,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDM3OTM=","github-url":"https://github.com/parrot/parrot/issues/627#issuecomment-3503793"},"message":"\u003cpre class=\"wiki\"\u003eOn Thu, 5 Aug 2010, Parrot wrote:\n\u0026gt;  Various memory management routines (e.g., `gc_ms_allocate_buffer_storage`)\n\u0026gt;  assume that the size of a buffer header is equal to the size of a pointer.\n\u0026gt;  This is probably true throughout the system as it stands, but those same\n\u0026gt;  routines take pains not to make that assumption in other places.\n\u0026gt;\n\u0026gt;  Here is a line from the above routine:\n\u0026gt;  {{{\n\u0026gt;      Buffer_buflen(buffer)   = new_size - sizeof (void *);\n\u0026gt;  }}}\n\u0026gt;  If the size of a pointer is less than the buffer header size, the value\n\u0026gt;  stored in `buflen` will be too big. `new_size` includes the entire size of\n\u0026gt;  the buffer header, which may include alignment padding in addition to the\n\u0026gt;  pointer.\nI don't understand what you are saying.  A Buffer looks like this\n(include/parrot/pobj.h):\ntypedef struct buffer_t {\n    Parrot_UInt flags;\n    void *     _bufstart;\n    size_t     _buflen;\n} Buffer;\nWhich part, specifically, is the \"header\"? Or are you referring to\nsomething else?\n--\n    Andy Dougherty      doughera@lafayette.edu\n\u003c/pre\u003e","files":null},{"type":3,"author":{"id":"c16eb74d82b49d6895509951834e12a05587f8f1"},"timestamp":1281128528,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDM3OTQ=","github-url":"https://github.com/parrot/parrot/issues/627#issuecomment-3503794"},"message":"\u003cp\u003e\nSorry, confusing terminology. The buffer \"header\" is the information stored in front of the actual buffer memory. The Buffer object is the buffer \"descriptor.\" Here's the new description from pobj.h:\n\u003c/p\u003e\n\n\u003cpre class=\"wiki\"\u003e/* A buffer descriptor object points to a buffer in a Memory_Block.\n   The buffer includes a header, but _bufstart points to the data\n   portion. Here is how it works:\n    Buffer descriptor                     buffer\n   +-------------------+                 +------------------------+\n   |       flags       |                 |  (possible padding)    | }\n   +-------------------+                 +---------------------+--+  \u0026gt; header\n   |      _bufstart    | ------+         |    *Memory_Block    |fl| }\n   +-------------------+       |         +---------------------+--+\n   |      _buflen      |       +-------\u0026gt; |    data portion        |\n   +-------------------+                 |                        |\n                                         ~                        ~\n                                         |                        |\n                                         +------------------------+\n   The buffer header consists of possible padding and a pointer to the\n   Memory_Block containing the buffer. There are two flags in the low-order\n   bits of the pointer (see string.h). Padding is only required if the\n   alignment of the data portion is higher than that of a pointer.\n   This was not the case as of 8/2010.\n*/\n\u003c/pre\u003e","files":null},{"type":3,"author":{"id":"6d59fc378929d99368e023bcfc49aacae1e68aad"},"timestamp":1281145629,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDM3OTU=","github-url":"https://github.com/parrot/parrot/issues/627#issuecomment-3503795"},"message":"\u003cp\u003e\nReplying to \u003ca href=\"http://trac.parrot.org/parrot/ticket/1731#comment:3\" title=\"Comment 3 for Ticket #1731\"\u003ePaul C. Anagnostopoulos\u003c/a\u003e:\n\u003c/p\u003e\n\n\u003cblockquote class=\"citation\"\u003e\n\u003cp\u003e\n Sorry, confusing terminology. The buffer \"header\" is the information stored in front of the actual buffer memory. The Buffer object is the buffer \"descriptor.\"\n\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e\nAh, I see.  Thanks for the new description.  I had hoped that with the new memory organization, that hidden flag stuck before _bufstart could have been eliminated.  I have never been a fan of that trick, and prefer to tell the compiler explicitly what I'm doing so it automatically gets all the alignment correct.\n\u003c/p\u003e\n\n\u003cp\u003e\nDoes every Buffer have that Memory_Block element?  If so, would it make sense to just explicitly list it in the Buffer \"descriptor?\"\n\u003c/p\u003e\n\n\u003cblockquote class=\"citation\"\u003e\n\u003cp\u003e\n    Padding is only required if the\n    alignment of the data portion is higher than that of a pointer.\n    This was not the case as of 8/2010.\n\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e\nIt depends on how the memory blocks are obtained and carved up.  On 32-bit SPARC, doubles should be aligned at 8-byte boundaries, but pointers are only 4 bytes.  I'm not sure how parrot obtains and carves up space for those buffers.\n\u003c/p\u003e","files":null},{"type":3,"author":{"id":"c16eb74d82b49d6895509951834e12a05587f8f1"},"timestamp":1281148490,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDM3OTY=","github-url":"https://github.com/parrot/parrot/issues/627#issuecomment-3503796"},"message":"\u003cp\u003e\nNow that I think about my terminology, it runs contrary to the terminology used elsewhere. I'll fix that in the comments.\n\u003c/p\u003e\n\n\u003cp\u003e\nI believe that every memory buffer has the Memory_Block in its header, although I'm not positive. In order to move it to the Buffer object, we would have to do a careful analysis to see if any functions grab the Memory_Block directly from a memory buffer rather than via its Buffer object.\n\u003c/p\u003e\n\n\u003cp\u003e\nBuffers are currently aligned using \u003ctt\u003eWORD_ALIGN_1\u003c/tt\u003e, which is based on the size of a pointer. That's why this problem won't arise now. But there is \u003ctt\u003eBUFFER_ALIGN_1\u003c/tt\u003e lurking around and it would align on 8-byte boundaries if it were used. This is odd, since a comment claims that buffers are aligned for \u003ctt\u003eFLOATVAL\u003c/tt\u003es. Either the comment is wrong or I don't understand what is going on.\n\u003c/p\u003e","files":null},{"type":3,"author":{"id":"c16eb74d82b49d6895509951834e12a05587f8f1"},"timestamp":1281150820,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDM3OTc=","github-url":"https://github.com/parrot/parrot/issues/627#issuecomment-3503797"},"message":"\u003cp\u003e\nThe Buffer descriptor is indeed called the header, so I'll now refer to the stuff preceding the actual buffer memory as the \u003ci\u003eprolog.\u003c/i\u003e\n\u003c/p\u003e","files":null},{"type":3,"author":{"id":"c16eb74d82b49d6895509951834e12a05587f8f1"},"timestamp":1281405129,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDM3OTg=","github-url":"https://github.com/parrot/parrot/issues/627#issuecomment-3503798"},"message":"\u003cp\u003e\nWe have two options for fixing the faulty assumption described in the original ticket.\n\u003c/p\u003e\n\n\u003cp\u003e\nOne approach is to simply declare by fiat that the size of the buffer prolog will always equal the size of a pointer. This means that the buffer data area will always be aligned on the same alignment as a pointer; there will be no possibility of any other alignment.\n\u003c/p\u003e\n\n\u003cp\u003e\nThe second approach is actually to fix the problem. This means that the calculation of the buffer alignment will become more complex, which affects about a dozen functions in three or four files.\n\u003c/p\u003e\n\n\u003cp\u003e\nWhich approach should we take?\n\u003c/p\u003e","files":null},{"type":3,"author":{"id":"6d59fc378929d99368e023bcfc49aacae1e68aad"},"timestamp":1281734341,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDM3OTk=","github-url":"https://github.com/parrot/parrot/issues/627#issuecomment-3503799"},"message":"\u003cp\u003e\nReplying to \u003ca href=\"http://trac.parrot.org/parrot/ticket/1731#comment:7\" title=\"Comment 7 for Ticket #1731\"\u003ePaul C. Anagnostopoulos\u003c/a\u003e:\n\u003c/p\u003e\n\n\u003cblockquote class=\"citation\"\u003e\n\u003cp\u003e\n Which approach should we take?\n\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e\nIt depends on what buffers are supposed to be able to store.  If they are supposed to be able to store arbitrary items (e.g. FLOATVALS, or structures) then they must be aligned properly for those structures, which may require padding.  If they are not supposed to be able to store arbitrary items, then less strict alingment may be appropriate.\n\u003c/p\u003e\n\n\u003cp\u003e\nI was not able to find any documentation for what they are supposed to be able to store.  Many of the comments in the source about alignment date back to times when there was a \"cache\" element in most of the structures that could hold a FLOATVAL, and may not apply anymore.\n\u003c/p\u003e","files":null}]}