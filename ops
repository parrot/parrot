{"version":1,"ops":[{"type":3,"author":{"id":"96fb2e2e33b59677e3a85ec74746c085275c50d1"},"timestamp":1262498291,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDM4MzU=","github-url":"https://github.com/parrot/parrot/issues/632#issuecomment-3503835"},"message":"\u003cp\u003e\nCopying Garbage Collector\n\u003c/p\u003e\n\n\u003cp\u003e\nThe basic concept of a Copying Collector is that the heap is divided into two\nequal semi-spaces, one of which contains the current data and the other\nobsolete data.  The Garbage Collection phase starts by flipping the roles of\nthe two semi-spaces.  The collector then scans the active data in the old\nsemi-space, Fromspace, copying each live cell into the new semi-space, Tospace.\nOn completion of the collection phase, Tospace contains all the active data and\nFromspace is effectively abandoned.\n\u003c/p\u003e\n\n\u003cp\u003e\nOne major advantage of this is that the active data is compacted at the bottom\nof Tospace.  Compacting collectors can allocate space much more efficiently\nthan collectors in which fragmentation is a problem.\n\u003c/p\u003e\n\n\u003cp\u003e\nAllocation costs are extremely low.  The out-of-space check is a simple pointer\ncomparison.  New memory is acquired by simply incrementing the free-space\npointer. Fragmentation is eliminated by simply copying the active data into the\nbottom of Tospace.\n\u003c/p\u003e\n\n\u003cp\u003e\nThe chief drawback of copying collectors is the need to divide the available\nmemory into two semi-spaces.  As the residency of a program increases the\nperformance of the collector degrades, as less free space is recovered and\ncollections become more frequent.\n\u003c/p\u003e\n\n\u003cp\u003e\nThe basic algorithm:\n\u003c/p\u003e\n\n\u003cpre class=\"wiki\"\u003einit() =\n    Tospace = Heap_bottom\n    space_size - Heap_size / 2\n    top_of_space = Tospace + space_size\n    Fromspace = top_of_space + 1\n    free = Tospace\nNew(n) =\n    if free + n \u0026gt; top_of_spece\n        flip()\n    if free + n \u0026gt; top_of_space\n        abort \"Memory exhausted\"\n    newcell = free\n    free = free + n\n    return newcell\nflip() =\n    Fromspace, Tospace = Tospace, Fromspace\n    top_of_space = Tospace + space_size\n    free = Tospace\n    for R in roots\n        R = copy(R)\n-- P points to a word not a cell\ncopy(P) =\n    if atomic(P) or P == nil        -- P is not a pointer\n        return P\n    if not forwarded(P)\n        n = size(P)\n        P' = free                   -- reserve space in Topace\n        free = free + n\n        temp = P[0]                 -- field 0 will hold the forwarding address\n        forwardingaddress[P] = P'\n        P'[0] = copy(temp)\n        for i = 1 to n-1            -- copy each field of P into P'\n            P'[i] = copy(P[i])\n    return forwarding_address(P)\n\u003c/pre\u003e\u003cp\u003e\nFirst, the roles of Tospace and Fromspace ar swapped by a flip, which resets\nthe variables Tospace, Fromspace and top_of_space.  Each cell reachable from\na root is then copied from Fromspace to Tospace.  For clarity, a simple\nrecursive algorithm is used, (more elegant iterative algorithms are available).\nCopy(P) scavenges the fields of the cell pointed to by P.  Care has to be taken\nwhen copying data structures to ensure that the topology of the shared data\nstructures is preserved.  Failure to do this would lead to multiple copies of\nshared objects, which at best would increase heap residency of the program but\nmay also break the user program (for example, if it updated one copy of a cell,\nbut then read the value from another).  Copying cyclic data structures without\npreserving sharing would also require a lot of room!\n\u003c/p\u003e\n\n\u003cp\u003e\nCopying collectors preserve sharing by leaving a forwarding address in the\nFromspace object when it is copied.  The forwarding address is the address of\nthe copy in Tospace.  When a cell in Fromspace is visited, copy checks to see\nif it has already been copied, if it has the forwarding address is returned,\notherwise memory is reserved for the copy in Tospace.  In this recursive\ncopying algorithm, the forwarding address is set to point to this reserved\nmemory before the constituent fields of the object are copied -- this ensures\ntermination and that sharing is preserved.\n\u003c/p\u003e\n\n\u003cp\u003e\nThe forwarding address might be held in its own field in the cell.  More\ngenerally it can be written over the first word in the cell provided that the\noriginal value of the cell is saved beforehand.  In the above it is assumed\nthat the forwarding address field in cell P is P[0], and forwarding address(P)\nand P[0] are used interchangeably.\n\u003c/p\u003e\n\n\u003cp\u003e\nextracted from: Garbage Collection: Algotithms for Automatic Dynamic Memory Management by Richard Jones and Rafael Sims \u003ca   href=\"http://www.cs.kent.ac.uk/people/staff/rej/gc.html\"\u003e\u003cspan class=\"icon\"\u003eÂ \u003c/span\u003ehttp://www.cs.kent.ac.uk/people/staff/rej/gc.html\u003c/a\u003e\n\u003c/p\u003e","files":null},{"type":3,"author":{"id":"96fb2e2e33b59677e3a85ec74746c085275c50d1"},"timestamp":1262498844,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDM4MzY=","github-url":"https://github.com/parrot/parrot/issues/632#issuecomment-3503836"},"message":"\u003cp\u003e\nthe second line of init() should be\n\u003c/p\u003e\n\n\u003cp\u003e\nspace_size = Heap_size / 2\n\u003c/p\u003e","files":null},{"type":3,"author":{"id":"aef4977f5ea786238d7c9581a2f192f4adc3f39d"},"timestamp":1262504548,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDM4Mzc=","github-url":"https://github.com/parrot/parrot/issues/632#issuecomment-3503837"},"message":"\u003cp\u003e\nI have some misgivings about the utility of a copying collector in Parrot. In a \"normal\" memory allocation system objects in memory can be allocated in random-sized chunks. Think about the way a program uses malloc(), to get various chunks that it needs for different purposes. However in Parrot, all our PMC objects are fixed-size, and each PMC type contains a fixed-size attributes structure. Some PMC types (Arrays) and our strings use arbitrary-sized buffers, but most do not.\n\u003c/p\u003e\n\n\u003cp\u003e\nA copying collector helps to reduce memory fragmentation by copying data from the Fromspace into the bottom of the ToSpace to help free up large contiguous chunks of memory from which large buffers can be allocated. In Parrot for PMC allocations, this isn't necessary: Any free chunk is large enough to hold any PMC. We can allocate very efficiently off a free list and don't need to worry about PMC pools becoming fragmented. It would be a huge waste to implement copying/compacting for our PMC pools.\n\u003c/p\u003e\n\n\u003cp\u003e\nWhere we do run into a problem is in the string pools and storage allocations for our Array PMC types. These buffers are going to need to be compacted during collections to help improve allocation performance. This leads us to a two-stage GC: one that is non-copying for PMCs and fixed-size objects, and one that is compacting for the buffers.\n\u003c/p\u003e\n\n\u003cp\u003e\nWhat I think we need to do is make a clear separation in the GC subsystem to show the two different parts: the fixed-size PMC/STRING header manager, and the arbitrary-sized buffer manager. These things should be pluggable independently, and one of the cores for the arbitrary-sized buffer manager should implement a copying/compacting collector.\n\u003c/p\u003e","files":null},{"type":3,"author":{"id":"96fb2e2e33b59677e3a85ec74746c085275c50d1"},"timestamp":1262549524,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDM4Mzg=","github-url":"https://github.com/parrot/parrot/issues/632#issuecomment-3503838"},"message":"\u003cp\u003e\nI agree with the above comment in essence, however one of the major advantages of copying collectors is that the collector compacts the heap discarding short-lived objects.  Techniques are available so that long-lived objects can be set up in a 'different' space and handled in a generational or incremental collector.  I have put these notes on the wiki as \u003ca class=\"wiki\" href=\"http://trac.parrot.org/parrot/wiki/CopyingGarbageCollector\"\u003eCopyingGarbageCollector\u003c/a\u003e and also \u003ca class=\"wiki\" href=\"http://trac.parrot.org/parrot/wiki/CheneysCopyingCollector\"\u003eCheneysCopyingCollector\u003c/a\u003e and I will expand them as well as adding further notes later.\n\u003c/p\u003e","files":null},{"type":3,"author":{"id":"aef4977f5ea786238d7c9581a2f192f4adc3f39d"},"timestamp":1336524465,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDU1OTA0MDQ=","github-url":"https://github.com/parrot/parrot/issues/632#issuecomment-5590404"},"message":"@mikehh, @allisonrandal, @bacek, @cotto: We have a good generational collector now, and complaints about GC performance are infrequent. Do we want to actively pursue copying GC still? If so, is this ticket specific enough to be actionable, or do we want to dump this info to a wiki page somewhere and keep it around as a sort of general GC-related wishlist?","files":null}]}