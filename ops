{"version":1,"ops":[{"type":3,"author":{"id":"2da6485217cbb88ff96be8f3dcc7f9ae44cf6bf0"},"timestamp":1254673892,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDI2NDA=","github-url":"https://github.com/parrot/parrot/issues/290#issuecomment-3502640"},"message":"\u003cp\u003e\nThis patch is a good start, but needs some work. Firstly, there is a bunch of dead commented out code. That should either be made to work or removed. Next, please break up test rewriting from add features or fixing bugs into separate patches. Rewriting some tests and adding tests in the same patch is fine. It is generally preferable to have somewhat atomic patches, that way, if something does not work, it does not block the other parts from getting applied.\n\u003c/p\u003e\n\n\u003cp\u003e\nAlso, if you can attach the patch directly to the TT with the \"Attach file\" button, that will be best and easiest for everyone.\n\u003c/p\u003e","files":null},{"type":3,"author":{"id":"2e07d1e375724352b47c35e84b16d7b9852990d2"},"timestamp":1254810762,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDI2NDE=","github-url":"https://github.com/parrot/parrot/issues/290#issuecomment-3502641"},"message":"419 byte attachment from kurahaupo\nat http://trac.parrot.org/parrot/raw-attachment/ticket/1089/resizableintegerarray.pmc.p1\n\n```**\\* src/pmc/resizableintegerarray.pmc    2009-10-06 17:29:09.000000000 +1300\n--- src/pmc/resizableintegerarray.pmc.1 2009-10-06 17:30:22.000000000 +1300\n\n---\n\n**\\* 198,204 ****\n\n  =item C\u003cvoid unshift_integer(INTVAL value)\u003e\n\n! Add and integer to the start of the array.\n\n  =cut\n\n--- 198,204 ----\n\n  =item C\u003cvoid unshift_integer(INTVAL value)\u003e\n\n! Add an integer to the start of the array.\n\n  =cut\n\n```\n```","files":null},{"type":3,"author":{"id":"2e07d1e375724352b47c35e84b16d7b9852990d2"},"timestamp":1254812455,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDI2NDI=","github-url":"https://github.com/parrot/parrot/issues/290#issuecomment-3502642"},"message":"18724 byte attachment from kurahaupo\nat http://trac.parrot.org/parrot/raw-attachment/ticket/1089/resizableintegerarray.t.patch1\n\n# ```Index: t/pmc/resizableintegerarray.t\n\n--- t/pmc/resizableintegerarray.t   (revision 41731)\n+++ t/pmc/resizableintegerarray.t   (working copy)\n@@ -1,20 +1,14 @@\n-#! perl\n-# Copyright (C) 2001-2007, Parrot Foundation.\n+#! parrot\n+# Copyright © 2001-2007, Parrot Foundation.\n # $Id$\n\n-use strict;\n-use warnings;\n-use lib qw( . lib ../lib ../../lib );\n-use Test::More;\n\n## -use Parrot::Test tests =\u003e 18;\n\n =head1 NAME\n\n t/pmc/resizableintegerarray.t - ResizableIntegerArray PMC\n\n =head1 SYNOPSIS\n-    % prove t/pmc/ResizableIntegerArray.t\n-    % prove t/pmc/resizableintegerarray.t\n  \n  =head1 DESCRIPTION\n\n@@ -23,433 +17,539 @@\n\n =cut\n\n-pasm_output_is( \u003c\u003c'CODE', \u003c\u003c'OUTPUT', \"Setting array size\" );\n-    new P0, ['ResizableIntegerArray']\n  +=for notes\n-    set I0,P0\n-    eq I0,0,OK_1\n-    print \"not \"\n  -OK_1:    print \"ok 1\\n\"\n  +Coverage plan:\n-    set P0,1\n-    set I0,P0\n-    eq I0,1,OK_2\n-    print \"not \"\n  -OK_2:    print \"ok 2\\n\"\n- - Get \u0026 Set Size\n-    set P0,5\n-    set I0,P0\n-    eq I0,5,OK_3\n-    print \"not \"\n  -OK_3:    print \"ok 3\\n\"\n- \\* Get \u0026 Set Element\n-     \\* Type of value (int, num, string, pmc)\n-     \\* Type of index (int, pmc)\n-     \\* index negative/in-range/beyond-end\n- ```\n  * Set doesn't clobber other elements\n  ```\n-    set P0,9\n-    set I0,P0\n-    eq I0,9,OK_4\n-    print \"not \"\n  -OK_4:    print \"ok 4\\n\"\n- \\* Push/Unshift, Pop/Shift\n-     \\* Correct values\n-     \\* Correct sequence\n- ```\n  * Correctly resized\n  ```\n-    set P0,7\n-    set I0,P0\n-    eq I0,7,OK_5\n-    print \"not \"\n  -OK_5:    print \"ok 5\\n\"\n- \\* Iterator\n-     \\* Doesn't change array size\n- ```\n  * Multiple concurrent iterators don't interfere\n  ```\n- ```\n     end\n  ```\n  \n  -CODE\n  -ok 1\n  -ok 2\n  -ok 3\n  -ok 4\n  -ok 5\n  -OUTPUT\n  +=cut\n\n-pasm_output_is( \u003c\u003c'CODE', \u003c\u003c'OUTPUT', \"Setting first element\" );\n-    new P0, ['ResizableIntegerArray']\n-    set P0, 1\n  +.sub main :main\n-    .include 'test_more.pir'\n-    plan(41)\n-    set P0[0],-7\n-    set I0,P0[0]\n-    eq I0,-7,OK_1\n-    print \"not \"\n  -OK_1:    print \"ok 1\\n\"\n-    test_does_interfaces()       # 4 tests\n-    set P0[0],3.7\n-    set N0,P0[0]\n-    eq N0,3.0,OK_2\n-    print \"not \"\n  -OK_2:    print \"ok 2\\n\"\n-    test_get_size()              # 2 tests\n-    test_resize()                # 3 tests\n-    test_distinct_storage()      # 1 test\n-    set P0[0],\"17\"\n-    set S0,P0[0]\n-    eq S0,\"17\",OK_3\n-    print \"not \"\n  -OK_3:    print \"ok 3\\n\"\n-    test_cant_set_negative()     # 1 test\n-    test_cant_get_negative()     # 1 test\n-    test_set_beyond_end()        # 2 test\n-    test_get_beyond_end()        # 3 tests\n-    end\n  -CODE\n  -ok 1\n  -ok 2\n  -ok 3\n  -OUTPUT\n-    test_conversion()            # 6 tests\n-    test_conversion_overflow()   # 1 test\n\n-pasm_output_is( \u003c\u003c'CODE', \u003c\u003c'OUTPUT', \"Setting second element\" );\n-    new P0, ['ResizableIntegerArray']\n-    test_set_pmc_index()         # 1 tests\n-    test_get_pmc_index()         # 1 tests\n-    set P0[1], -7\n-    set I0, P0[1]\n-    eq I0,-7,OK_1\n-    print \"not \"\n  -OK_1:    print \"ok 1\\n\"\n-    test_push()                  # 2 tests\n-    test_pop()                   # 2 tests\n-    test_pop_many()              # 2 test\n-    test_push_many()             # 2 test\n-    test_push_pop()              # 1 tests\n-    test_cant_pop_empty()        # 1 test\n-    test_shift()                 # 2 tests\n-    test_unshift()               # 2 tests\n-    test_iterator()              # 1 test\n  +.end\n-    set P0[1], 3.7\n-    set N0, P0[1]\n-    eq N0,3.0,OK_2\n-    print \"not \"\n  -OK_2:    print \"ok 2\\n\"\n  +.sub test_does_interfaces\n-    $P0 = new ['ResizableIntegerArray']\n-    ok( 1, 'Instantiated ResizableIntegerArray PMC' )\n-    $I0 = does $P0, 'array'\n-    ok( $I0, 'Interface does \"array\"' )\n-    $I0 = does $P0, 'scalar'\n-    is( $I0, 0, 'Interface does not do \"scalar\"' )\n-    $I0 = does $P0, 'no_interface'\n-    is( $I0, 0, 'Interface does not do \"no_interface\"' )\n  +.end\n-    set P0[1],\"17\"\n-    set S0, P0[1]\n-    eq S0,\"17\",OK_3\n-    print \"not \"\n  -OK_3:    print \"ok 3\\n\"\n  +.sub test_get_size\n-    $P0 = new ['ResizableIntegerArray']\n-    $I0 = $P0\n-    is( $I0, 0, 'Initial array size is 0' )\n-    $I1 = elements $P0\n-    is( $I0, $I1, '... and \"elements\" opcode agrees' )\n  +.end\n-    end\n  -CODE\n  -ok 1\n  -ok 2\n  -ok 3\n  -OUTPUT\n  +.sub test_resize\n-    $P0 = new ['ResizableIntegerArray']\n-    $I1 = 0\n\n-pasm_output_is( \u003c\u003c'CODE', \u003c\u003c'OUTPUT', \"Setting negatively indexed elements\" );\n-    new P0, ['ResizableIntegerArray']\n-    set P0, 1\n-    $P0 = 1\n-    $I0 = $P0\n-    ne $I0, 1, X1\n-    inc $I1\n-    $P0 = 9\n-    $I0 = $P0\n-    ne $I0, 9, X1\n-    inc $I1\n  +\n-    $P0 = 5\n-    $I0 = $P0\n-    ne $I0, 5, X1\n-    inc $I1\n  +\n-    $P0 = 99999\n-    $I0 = $P0\n-    ne $I0, 99999, X1\n-    inc $I1\n  +\n-    $P0 = 0\n-    $I0 = $P0\n-    ne $I0, 0, X1\n-    inc $I1\n  +\n-    $P0 = 77\n-    $I0 = $P0\n-    ne $I0, 77, X1\n-    inc $I1\n  +\n  +X1:\n-    is( $I1, 6, 'Setting array size (four different values, including 0)' )\n  +\n-    $I2 = elements $P0\n-    is( $I0, $I2, '... and \"elements\" opcode still agrees' )\n  +\n-    push_eh E\n-    $I1 = 1\n-    $P0 = -4\n-    $I1 = 0\n  +E:\n-    pop_eh\n-    ok( $I1, 'Setting negative size should throw an exception' )\n  +.end\n  +\n  +.sub test_distinct_storage\n-    # Walk the array in pseudo-random order\n-    # Pick a sample size $I4 and another number $I2, such that\n-    #   ∀n: n \u003e 0 ∧ $I2 ⁿ % $I4 = 1 ⇒ n % $I4 = 0\n-    $I4 = 17\n-    $I2 = 3\n-    # Create and fill array in random order\n-    $P0 = new ['ResizableIntegerArray']\n-    $P0 = $I4\n  +#   say '\\n ... checking that pseudo-random sequence is exhaustive ...'\n-    $I0 = 1\n  +L1:\n  +#   say $I0\n-    $I0 = mul $I0, $I2\n-    $I0 = mod $I0, $I4\n-    $P0[$I0] = $I0\n-    gt $I0, 1, L1\n-    $P0[0] = 0\n  +#   say 0\n-    # Read back array and check values match\n-    $I0 = 0\n  +L2:\n-    $I1 = $P0[$I0]\n-    ne $I1, $I0, X1\n-    inc $I0\n-    lt $I0, $I4, L2\n  +X1:\n-    is( $I0, $I4, 'All array elements stored separately' )\n  +.end\n  +\n  +.sub test_cant_set_negative\n-    $P0 = new ['ResizableIntegerArray']\n-    $P0 = 1\n-    $I0 = 1\n   push_eh eh\n-    set P0[-1], -7\n-    $P0[-1] = -7\n-    $I0 = 0\n  +eh:\n   pop_eh\n-    print \"no ex\\n\"\n-    end\n-    ok( $I0, 'Setting with negative index should throw an exception' )\n  +.end\n  +\n  +.sub test_cant_get_negative\n-    $P0 = new ['ResizableIntegerArray']\n-    $P0 = 1\n-    $I0 = 1\n-    push_eh eh\n-    $I0 = $P0[-1]\n-    $I0 = 0\n  eh:\n-    say \"got an ex\"\n-    end\n  -CODE\n  -got an ex\n  -OUTPUT\n-    pop_eh\n-    ok( $I0, 'Getting with negative index should throw an exception' )\n  +.end\n\n-pasm_output_is( \u003c\u003c'CODE', \u003c\u003c'OUTPUT', \"Getting negatively indexed elements\" );\n-    new P0, ['ResizableIntegerArray']\n-    set P0, 1\n  +.sub test_set_beyond_end\n-    $P0 = new ['ResizableIntegerArray']\n-    $P0 = 1\n-    $I0 = 0\n-    push_eh eh\n-    $P0[1] = -7\n-    $I0 = 1\n  +eh:\n-    pop_eh\n-    ok( $I0, 'Setting with too-big index should not throw an exception' )\n-    $I0 = $P0\n-    is( $I0, 2, '... and should extend array' )\n  +.end\n  +\n  +.sub test_get_beyond_end\n-    $P0 = new ['ResizableIntegerArray']\n-    $P0 = 1\n-    $I0 = 1\n   push_eh eh\n-    set I0, P0[-1]\n-    $I1 = $P0[1]\n-    $I0 = 1\n  +eh:\n   pop_eh\n-    print \"no ex\\n\"\n-    end\n  -eh:\n-    say \"got an ex\"\n-    end\n  -CODE\n  -got an ex\n  -OUTPUT\n-    ok( $I0, 'Getting with too-big index should not throw an exception' )\n-    is( $I1, 0, '... and result should be 0' )\n\n-pasm_output_is( \u003c\u003c'CODE', \u003c\u003c'OUTPUT', \"Setting out-of-bounds elements\" );\n-    new P0, ['ResizableIntegerArray']\n-    set P0, 1\n-    $I0 = $P0\n-    is( $I0, 1, '... and should not extend array' )\n  +.end\n-    set P0[1], -7\n-    print \"ok 1\\n\"\n  +.sub test_conversion\n-    $P0 = new ['ResizableIntegerArray']\n-    $P0 = 6\n-    $P0[0] = -7\n-    $P0[1] = 3.7\n-    $P0[2] = '17'\n-    $P1 = new ['Integer']\n-    $P1 = 123456\n-    $P0[3] = $P1\n-    $P2 = new ['Float']\n-    $P2 = 7.3\n-    $P0[4] = $P2\n-    $P3 = new ['String']\n-    $P3 = '987654321'\n-    $P0[5] = $P3\n-    $I0 = $P0[0]\n-    is( $I0, -7, 'Setting element to integer' )\n-    $N0 = $P0[1]\n-    is( $N0, 3.0, 'Setting element to float (gets truncated)' )\n-    $S0 = $P0[2]\n-    is( $S0, '17', 'Setting element to string (gets converted to int and back)' )\n-    $I0 = $P0[3]\n-    is( $I0, 123456, 'Setting element to boxed integer' )\n-    $N0 = $P0[4]\n-    is( $N0, 7.0, 'Setting element to boxed float (gets truncated)' )\n-    $S0 = $P0[5]\n-    is( $S0, '987654321', 'Setting element to boxed string (gets converted to int and back)' )\n  +.end\n-    end\n  -CODE\n  -ok 1\n  -OUTPUT\n  +.sub test_conversion_overflow\n-    $P0 = new ['ResizableIntegerArray']\n-    $P0 = 1\n\n-pasm_output_is( \u003c\u003c'CODE', \u003c\u003c'OUTPUT', \"Getting out-of-bounds elements\" );\n-    new P0, ['ResizableIntegerArray']\n-    set P0, 1\n-    $S0 = '12345678901234567890123456789012345678901234567890123456789012345678901234567890'\n-    set I0, P0[1]\n-    print \"ok 1\\n\"\n-    end\n  -CODE\n  -ok 1\n  -OUTPUT\n-    push_eh eh0\n-    $I1 = 1\n-        $P0[0] = $S0\n-        $I0 = $P0[0]\n-    $I1 = 0\n  +eh0:\n-    pop_eh\n-    ok( $I1, 'Throw exception when setting element to too-large digit-string' )\n\n-pasm_output_is( \u003c\u003c\"CODE\", \u003c\u003c'OUTPUT', \"Set via PMC keys, access via INTs\" );\n-     .include 'fp_equality.pasm'\n-     new P0, ['ResizableIntegerArray']\n- ```\n  new P1, ['Key']\n  ```\n  \n  +.end\n- ```\n  set P1, 0\n  ```\n-     set P0[P1], 25\n  +.sub test_set_pmc_index\n-    $P0 = new ['ResizableIntegerArray']\n-    $P1 = new ['Key']\n-    $P1 = 0\n-    $P0[$P1] = 25\n-    $P1 = 1\n-    $P0[$P1] = 2.5\n-    $P1 = 2\n-    $P0[$P1] = '17'\n- ```\n  set P1, 1\n  ```\n-     set P0[P1], 2.5\n-    $I1 = 0\n- ```\n  set P1, 2\n  ```\n-     set P0[P1], \"17\"\n-    $I0 = $P0[0]\n-    ne $I0, 25, X1\n-    inc $I1\n- ```\n  set I0, P0[0]\n  ```\n-     eq I0, 25, OK1\n-     print \"not \"\n  -OK1: print \"ok 1\\n\"\n-    $N0 = $P0[1]\n-    ne $N0, 2.0, X1\n-    inc $I1\n- ```\n  set N0, P0[1]\n  ```\n-     .fp_eq_pasm(N0, 2.0, OK2)\n-     print \"not \"\n  -OK2: print \"ok 2\\n\"\n-    $S0 = $P0[2]\n-    ne $S0, '17', X1\n-    inc $I1\n  +X1:\n-    is( $I1, 3, 'Setting via PMC key (3 different types)' )\n  +.end\n- ```\n  set S0, P0[2]\n  ```\n-     eq S0, \"17\", OK3\n-     print \"not \"\n  -OK3: print \"ok 3\\n\"\n  +.sub test_get_pmc_index\n-    $P0 = new ['ResizableIntegerArray']\n-    $P0 = 1\n-    $P0[25] = 125\n-    $P0[128] = 10.2\n-    $P0[513] = '17'\n-    $P0[1023] = 123456\n- ```\n  end\n  ```\n  \n  -CODE\n  -ok 1\n  -ok 2\n  -ok 3\n  -OUTPUT\n-    $I1 = 0\n\n-pasm_output_is( \u003c\u003c\"CODE\", \u003c\u003c'OUTPUT', \"Set via INTs, access via PMC Keys\" );\n-     .include 'fp_equality.pasm'\n-     new P0, ['ResizableIntegerArray']\n-     set P0, 1\n-    $P2 = new ['Key']\n- ```\n  set P0[25], 125\n  ```\n-     set P0[128], 10.2\n-     set P0[513], \"17\"\n-     new P1, ['Integer']\n-     set P1, 123456\n-     set P0[1023], P1\n-    $P2 = 25\n-    $I0 = $P0[$P2]\n-    ne $I0, 125, X1\n-    inc $I1\n- ```\n  new P2, ['Key']\n  ```\n-     set P2, 25\n-     set I0, P0[P2]\n-     eq I0, 125, OK1\n-     print \"not \"\n  -OK1: print \"ok 1\\n\"\n-    $P2 = 128\n-    $N0 = $P0[$P2]\n-    ne $N0, 10.0, X1\n-    inc $I1\n- ```\n  set P2, 128\n  ```\n-     set N0, P0[P2]\n-     .fp_eq_pasm(N0, 10.0, OK2)\n-     print \"not \"\n  -OK2: print \"ok 2\\n\"\n-    $P2 = 513\n-    $S0 = $P0[$P2]\n-    ne $S0, '17', X1\n-    inc $I1\n- ```\n  set P2, 513\n  ```\n-     set S0, P0[P2]\n-     eq S0, \"17\", OK3\n-     print \"not \"\n  -OK3: print \"ok 3\\n\"\n-    $P2 = 1023\n-    $I2 = $P0[$P2]\n-    ne $I2, 123456, X1\n-    inc $I1\n  +X1:\n-    is( $I1, 4, 'Getting via PMC key (4 different types)' )\n  +.end\n- ```\n  set P2, 1023\n  ```\n-     set P3, P0[P2]\n-     set I1, P3\n-     eq I1, 123456, OK4\n-     print \"not \"\n  -OK4: print \"ok 4\\n\"\n  +.sub test_push\n-    $P0 = new ['ResizableIntegerArray']\n-    $P0[9999] = 0\n-    push $P0, 12345\n-    $I0 = $P0\n-    is( $I0, 10001, 'Push increases number of elements by one' )\n-    $I0 = $P0[10000]\n-    is( $I0, 12345, '... and stores correct value' )\n  +.end\n- ```\n  end\n  ```\n  \n  -CODE\n  -ok 1\n  -ok 2\n  -ok 3\n  -ok 4\n  -OUTPUT\n  +.sub test_pop\n-    $P0 = new ['ResizableIntegerArray']\n-    $P0[0] = 4\n-    $P0[1] = 8\n-    $P0[2] = 16\n-    $I0 = $P0\n-    $I0 = pop $P0\n-    is( $I0, 16, 'Pop retrieves correct value' )\n-    $I0 = $P0\n-    is( $I0, 2, '... and reduces number of elements by one' )\n  +.end\n\n-pir_output_is( \u003c\u003c 'CODE', \u003c\u003c 'OUTPUT', \"check whether interface is done\" );\n+.sub test_pop_many\n-    $P0 = new ['ResizableIntegerArray']\n-    $I0 = 0\n  +l1:\n-    $P0[$I0] = $I0\n-    inc $I0\n-    lt $I0, 100000, l1\n  +l2:\n-    le $I0, 0, e2\n-    dec $I0\n-    $I1 = pop $P0\n-    eq $I0, $I1, l2\n  +e2:\n-    is( $I0, $I1, 'Pop many times retrieves correct values' )\n-    $I0 = $P0\n-    is( $I0, 0, '... and leaves array empty' )\n  +.end\n\n-.sub test :main\n-    .local pmc pmc1\n-    pmc1 = new ['ResizableIntegerArray']\n-    .local int bool1\n-    does bool1, pmc1, \"scalar\"\n-    print bool1\n-    print \"\\n\"\n-    does bool1, pmc1, \"array\"\n-    print bool1\n-    print \"\\n\"\n-    does bool1, pmc1, \"no_interface\"\n-    print bool1\n-    print \"\\n\"\n-    end\n  +.sub test_push_many\n-    $P0 = new ['ResizableIntegerArray']\n-    $I0 = 0\n  +l1:\n-    push $P0, $I0\n-    inc $I0\n-    lt $I0, 100000, l1\n-    $I1 = $P0\n-    is( $I1, 100000, 'Push many values fills array to correct size' )\n  +l2:\n-    le $I0, 0, e2\n-    dec $I0\n-    $I1 = $P0[$I0]\n-    eq $I0, $I1, l2\n  +e2:\n-    is( $I0, $I1, '... and stores correct values')\n  .end\n  -CODE\n  -0\n  -1\n  -0\n  -OUTPUT\n\n-pir_output_is( \u003c\u003c 'CODE', \u003c\u003c 'OUTPUT', \"push integer\" );\n+.sub test_push_pop\n-    $P0 = new ['ResizableIntegerArray']\n-    $I1 = 0\n\n-.sub test :main\n-    .local pmc pmc1\n-    pmc1 = new ['ResizableIntegerArray']\n-    pmc1[9999] = 0\n-    push pmc1, 10001\n-    .local int elements\n-    elements = pmc1\n-    print elements\n-    print \"\\n\"\n-    .local string last\n-    last = pmc1[10000]\n-    print last\n-    print \"\\n\"\n-    end\n-    push $P0, 2\n-    $I0 = $P0\n-    ne $I0, 1, X1\n-    inc $I1\n  +\n-    push $P0, 4\n-    $I0 = $P0\n-    ne $I0, 2, X1\n-    inc $I1\n  +\n-    push $P0, 6\n-    $I0 = $P0\n-    ne $I0, 3, X1\n-    inc $I1\n  +\n-    $I0 = pop $P0\n-    ne $I0, 6, X1\n-    inc $I1\n  +\n-    $I0 = $P0\n-    ne $I0, 2, X1\n-    inc $I1\n  +\n-    $I0 = pop $P0\n-    ne $I0, 4, X1\n-    inc $I1\n  +\n-    $I0 = $P0\n-    ne $I0, 1, X1\n-    inc $I1\n  +\n-    $I0 = pop $P0\n-    ne $I0, 2, X1\n-    inc $I1\n  +\n-    $I0 = $P0\n-    ne $I0, 0, X1\n-    inc $I1\n  +\n  +X1:\n-    is( $I1, 9, 'Push-then-Pop retrieves values in reverse order' )\n  .end\n  -CODE\n  -10001\n  -10001\n  -OUTPUT\n\n-pasm_output_is( \u003c\u003c'CODE', \u003c\u003c'OUTPUT', 'basic pop' );\n-     new P0, ['ResizableIntegerArray']\n-     set P0[0], 4\n-     set P0[1], 8\n-     set P0[2], 16\n-     pop I0, P0\n-     eq I0, 16, OK1\n-     print \"not \"\n-     print I0\n  -OK1: print \"ok 1\\n\"\n  +.sub test_cant_pop_empty\n-    $P0 = new ['ResizableIntegerArray']\n-    $I0 = 1\n-    push_eh eh\n-    $I0 = pop $P0\n-    $I0 = 0\n  +eh:\n-    pop_eh\n-    ok( $I0, 'Pop from empty array should throw an exception' )\n  +.end\n- ```\n  pop I0, P0\n  ```\n-     eq I0, 8, OK2\n-     print \"not \"\n- ```\n  print I0\n  ```\n  \n  -OK2: print \"ok 2\\n\"\n  +# .sub test_cant_pop_empty\n  +# #   test_pass( 'pop from empty array should throw exception' )\n  +#     throws_like( \u003c\u003c'CODE', 'Can\\'t pop from an empty array!', 'pop from empty array should throw exception' )\n  +# .sub main\n  +#     $P0 = new ['ResizableIntegerArray']\n  +#     $I0 = pop $P0\n  +# .end\n  +# CODE\n  +# #   test_test( 'pop from empty array should throw exception' )\n  +# .end\n- ```\n  pop I0, P0\n  ```\n-     eq I0, 4, OK3\n-     print \"not \"\n-     print I0\n  -OK3: print \"ok 3\\n\"\n-     end\n  -CODE\n  -ok 1\n  -ok 2\n  -ok 3\n  -OUTPUT\n  +.sub test_shift\n-    $P0 = new ['ResizableIntegerArray']\n-    $P0[0] = 10\n-    $P0[1] = 20\n\n-pasm_output_is( \u003c\u003c'CODE', \u003c\u003c'OUTPUT', 'pop many values' );\n-     new P0, ['ResizableIntegerArray']\n-     set I0, 0\n  -L1:  set P0[I0], I0\n-     inc I0\n-     lt I0, 100000, L1\n-    $I1 = 0\n\n-L2:  dec I0\n-     pop I1, P0\n-     eq I0, I1, OK\n-     branch NOT_OK\n  -OK:  gt I0, 0, L2\n-     print \"ok\\n\"\n-     end\n-    $I0 = $P0\n-    ne $I0, 2, X1\n-    inc $I1\n\n-NOT_OK:\n-     print I0\n-     print \"\\n\"\n-     print I1\n-     print \"\\n\"\n-     end\n  -CODE\n  -ok\n  -OUTPUT\n-    $I0 = shift $P0\n-    ne $I0, 10, X1\n-    inc $I1\n\n-pasm_output_is( \u003c\u003c'CODE', \u003c\u003c'OUTPUT', 'push/pop' );\n-     new P0, ['ResizableIntegerArray']\n-     push P0, 2\n-     push P0, 4\n-     push P0, 6\n-     pop I0, P0\n-     eq I0, 6, OK1\n-     print \"not \"\n  -OK1: print \"ok 1\\n\"\n-     end\n  -CODE\n  -ok 1\n  -OUTPUT\n-    $I0 = $P0\n-    ne $I0, 1, X1\n-    inc $I1\n\n-pasm_error_output_like( \u003c\u003c'CODE', \u003c\u003c'OUTPUT', 'pop from empty array' );\n-     new P0, ['ResizableIntegerArray']\n-     pop I0, P0\n-     end\n  -CODE\n  -/ResizableIntegerArray: Can't pop from an empty array!/\n  -OUTPUT\n-    $I0 = shift $P0\n-    ne $I0, 20, X1\n-    inc $I1\n\n-#'\n-pir_output_is( \u003c\u003c 'CODE', \u003c\u003c 'OUTPUT', \"shift integer\" );\n-.sub test :main\n-    .local pmc ar\n-    ar = new ['ResizableIntegerArray']\n-    ar[0] = 10\n-    ar[1] = 20\n-    $I0 = elements ar\n-    print $I0\n-    print ' '\n-    $I0 = shift ar\n-    print $I0\n-    print ' '\n-    $I0 = elements ar\n-    print $I0\n-    print ' '\n-    $I0 = shift ar\n-    print $I0\n-    print ' '\n-    $I0 = elements ar\n-    say $I0\n  +X1:\n-    is( $I1, 4, 'Shift returns values in correct order' )\n  +\n-    $I0 = $P0\n-    is( $I0, 0, '... and removes correct number of elements' )\n  .end\n  -CODE\n  -2 10 1 20 0\n  -OUTPUT\n\n-pir_output_is( \u003c\u003c 'CODE', \u003c\u003c 'OUTPUT', \"unshift integer\" );\n-.sub test :main\n-    .local pmc ar\n-    ar = new ['ResizableIntegerArray']\n-    unshift ar, 10\n-    unshift ar, 20\n-    $I0 = elements ar\n-    print $I0\n-    print ' '\n-    $I0 = ar[0]\n-    print $I0\n-    print ' '\n-    $I0 = ar[1]\n-    say $I0\n  +.sub test_unshift\n-    $P0 = new ['ResizableIntegerArray']\n-    unshift $P0, 10\n-    unshift $P0, 20\n  +\n-    $I0 = $P0\n-    is( $I0, 2, 'Unshift adds correct number of elements' )\n  +\n-    $I1 = 0\n  +\n-    $I0 = $P0[0]\n-    ne $I0, 20, X1\n-    inc $I1\n-    $I0 = $P0[1]\n-    ne $I0, 10, X1\n-    inc $I1\n  +\n  +X1:\n-    is( $I1, 2, '... and stores values in correct order' )\n  .end\n  -CODE\n  -2 20 10\n  -OUTPUT\n\n-pir_output_is( \u003c\u003c'CODE', \u003c\u003c'OUTPUT', \"get_iter\" );\n-.sub 'main' :main\n+.sub test_iterator\n     $P0 = new ['ResizableIntegerArray']\n-    push_eh k0\n   $P0[0] = 42\n   $P0[1] = 43\n   $P0[2] = 44\n   push $P0, 999\n-    $I0 = 0\n   $P1 = iter $P0\n  -loop:\n-    unless $P1 goto loop_end\n-    $S2 = shift $P1\n-    say $S2\n-    goto loop\n  -loop_end:\n-    $I2 = shift $P1\n-    inc $I0\n-    eq $I2, 42, k3\n-    dec $I0\n-    say 'Missing 42'\n  +k3:\n-    $I2 = shift $P1\n-    inc $I0\n-    eq $I2, 43, k2\n-    dec $I0\n-    say 'Missing 43'\n  +k2:\n-    $I2 = shift $P1\n-    inc $I0\n-    eq $I2, 44, k1\n-    dec $I0\n-    say 'Missing 44'\n  +k1:\n-    $I2 = shift $P1\n-    inc $I0\n-    eq $I2, 999, k0\n-    dec $I0\n-    say 'Missing 999'\n  +k0:\n-    pop_eh\n-    is( $I0, 4, 'get_iter: iterator returns all values in correct sequence' )\n  .end\n  -CODE\n  -42\n  -43\n  -44\n  -999\n  -OUTPUT\n\n## \n\n # Local Variables:\n-#   mode: cperl\n-#   cperl-indent-level: 4\n+#   mode: pir\n #   fill-column: 100\n # End:\n-# vim: expandtab shiftwidth=4:\n+# vim: expandtab shiftwidth=4 ft=pir:\n\n```\n```","files":null},{"type":3,"author":{"id":"2e07d1e375724352b47c35e84b16d7b9852990d2"},"timestamp":1254812933,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDI2NDM=","github-url":"https://github.com/parrot/parrot/issues/290#issuecomment-3502643"},"message":"3888 byte attachment from kurahaupo\nat http://trac.parrot.org/parrot/raw-attachment/ticket/1089/resizableintegerarray.patch2\n\n# ```Index: src/pmc/resizableintegerarray.pmc\n\n--- src/pmc/resizableintegerarray.pmc   (revision 41731)\n+++ src/pmc/resizableintegerarray.pmc   (working copy)\n@@ -84,12 +84,14 @@\n     VTABLE void set_integer_native(INTVAL size) {\n\n```\n     INTVAL *int_array;\n```\n- ```\n     INTVAL  cur_size;\n   INTVAL  resize_threshold;\n  \n   if (size \u003c 0)\n       Parrot_ex_throw_from_c_args(INTERP, NULL, EXCEPTION_OUT_OF_BOUNDS,\n               \"ResizableIntegerArray: Can't resize!\");\n  ```\n- ```\n     GET_ATTR_size(INTERP, SELF, cur_size);\n   GET_ATTR_int_array(INTERP, SELF, int_array);\n   GET_ATTR_resize_threshold(INTERP, SELF, resize_threshold);\n   if (!int_array) {\n  ```\n  \n  @@ -103,15 +105,14 @@\n               SUPER(size);\n               SET_ATTR_resize_threshold(INTERP, SELF, size);\n           }\n-            GET_ATTR_int_array(INTERP, SELF, int_array);\n       }\n       else if (size \u003c= resize_threshold) {\n           /\\* we could shrink here if necessary */\n           SET_ATTR_size(INTERP, SELF, size);\n-            return;\n       }\n       else {\n           INTVAL  cur = resize_threshold;\n- ```\n         INTVAL *int_array;\n  \n       if (cur \u003c 8192)\n           cur = size \u003c 2 * cur ? 2 * cur : size;\n  ```\n  \n  @@ -121,12 +122,19 @@\n               cur          \u0026= ~0xfff;\n           }\n- ```\n         GET_ATTR_int_array(INTERP, SELF, int_array);\n       int_array = (INTVAL*) mem_sys_realloc((void*) int_array, cur * sizeof (INTVAL));\n       SET_ATTR_int_array(INTERP, SELF, int_array);\n       SET_ATTR_size(INTERP, SELF, size);\n       SET_ATTR_resize_threshold(INTERP, SELF, cur);\n   }\n  ```\n  \n  +\n-        if ( size \u003e cur_size ) {\n-            if ( size == cur_size+1 )\n-                int_array[cur_size] = 0;    // optimize for most common case (push)\n-            else\n-                mem_sys_memset(int_array + cur_size, 0, (size - cur_size) \\* sizeof (INTVAL));\n- ```\n     }\n  ```\n  \n  +\n   }\n  \n  /*\n  \n  # Index: include/parrot/memory.h\n  \n  --- include/parrot/memory.h (revision 41731)\n  +++ include/parrot/memory.h (working copy)\n  @@ -33,6 +33,7 @@\n  #define mem_allocate_new_stack() NULL\n  #define mem_sys_memcopy memcpy\n  #define mem_sys_memmove memmove\n  +#define mem_sys_memset memset\n  \n  #define mem_allocate_typed(type)            (type *)mem_sys_allocate(sizeof (type))\n  #define mem_allocate_n_typed(n, type)       (type *)mem_sys_allocate((n) \\* sizeof(type))\n  \n  # Index: t/pmc/resizableintegerarray.t\n  \n  --- t/pmc/resizableintegerarray.t   (revision 41731)\n  +++ t/pmc/resizableintegerarray.t   (working copy)\n  @@ -1,6 +1,6 @@\n  #! parrot\n  \n  # Copyright © 2001-2007, Parrot Foundation.\n  \n  -# $Id: resizableintegerarray.t 38718 2009-05-12 16:48:28Z kurahaupo $\n  +# $Id$\n  \n  =head1 NAME\n\n@@ -38,11 +38,13 @@\n      \\* Doesn't change array size\n      \\* Multiple concurrent iterators don't interfere\n- - Lengthening zeroes elements if previously allocated space\n    +\n    =cut\n  \n  .sub main :main\n     .include 'test_more.pir'\n-    plan(41)\n-    plan(42)\n  \n   test_does_interfaces()       # 4 tests\n\n@@ -54,6 +56,7 @@\n     test_cant_get_negative()     # 1 test\n     test_set_beyond_end()        # 2 test\n     test_get_beyond_end()        # 3 tests\n-    test_zero_after_resize()     # 1 test\n  \n   test_conversion()            # 6 tests\n   test_conversion_overflow()   # 1 test\n  @@ -225,6 +228,16 @@\n   is( $I0, 1, '... and should not extend array' )\n  .end\n\n+.sub test_zero_after_resize\n-    $P0 = new ['ResizableIntegerArray']\n-    $P0 = 10\n-    $P0[7] = 23\n-    $P0 = 5\n-    $P0[9] = 0\n-    $I0 = $P0[7]\n-    is( $I0, 0, 'Latent elements are zeroed when array is shrunk and re-stretched' )\n  +.end\n  +\n  .sub test_conversion\n     $P0 = new ['ResizableIntegerArray']\n     $P0 = 6\n\n```\n```","files":null},{"type":3,"author":{"id":"2e07d1e375724352b47c35e84b16d7b9852990d2"},"timestamp":1254828762,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDI2NDQ=","github-url":"https://github.com/parrot/parrot/issues/290#issuecomment-3502644"},"message":"\u003cp\u003e\nFix typo in comments\n\u003c/p\u003e","files":null},{"type":3,"author":{"id":"2e07d1e375724352b47c35e84b16d7b9852990d2"},"timestamp":1254830933,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDI2NDU=","github-url":"https://github.com/parrot/parrot/issues/290#issuecomment-3502645"},"message":"\u003cp\u003e\nImplement (and test) zero-fill on resizing\n\u003c/p\u003e","files":null},{"type":3,"author":{"id":"2da6485217cbb88ff96be8f3dcc7f9ae44cf6bf0"},"timestamp":1254920028,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDI2NDY=","github-url":"https://github.com/parrot/parrot/issues/290#issuecomment-3502646"},"message":"\u003cp\u003e\nFirst two patches were applied in r41750 . The third patch, which has to do with zeroing out elements in resized arrays, should probably get a code review on parrot-dev.\n\u003c/p\u003e","files":null},{"type":3,"author":{"id":"2da6485217cbb88ff96be8f3dcc7f9ae44cf6bf0"},"timestamp":1282424442,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDI2NDc=","github-url":"https://github.com/parrot/parrot/issues/290#issuecomment-3502647"},"message":"2634 byte attachment from leto\nat http://trac.parrot.org/parrot/raw-attachment/ticket/1089/ria.patch\n\n# ```Index: src/pmc/resizableintegerarray.pmc\n\n--- src/pmc/resizableintegerarray.pmc   (revision 48587)\n+++ src/pmc/resizableintegerarray.pmc   (working copy)\n@@ -90,12 +90,14 @@\n\n```\n VTABLE void set_integer_native(INTVAL size) {\n     INTVAL *int_array;\n```\n- ```\n     INTVAL  cur_size;\n   INTVAL  resize_threshold;\n  \n   if (size \u003c 0)\n       Parrot_ex_throw_from_c_args(INTERP, NULL, EXCEPTION_OUT_OF_BOUNDS,\n               \"ResizableIntegerArray: Can't resize!\");\n  ```\n- ```\n     GET_ATTR_size(INTERP, SELF, cur_size);\n   GET_ATTR_int_array(INTERP, SELF, int_array);\n   GET_ATTR_resize_threshold(INTERP, SELF, resize_threshold);\n   if (!int_array) {\n  ```\n  \n  @@ -109,15 +111,14 @@\n               SUPER(size);\n               SET_ATTR_resize_threshold(INTERP, SELF, size);\n           }\n-            GET_ATTR_int_array(INTERP, SELF, int_array);\n       }\n       else if (size \u003c= resize_threshold) {\n           /\\* we could shrink here if necessary */\n           SET_ATTR_size(INTERP, SELF, size);\n-            return;\n       }\n       else {\n           INTVAL  cur = resize_threshold;\n- ```\n         INTVAL *int_array;\n  \n       if (cur \u003c 8192)\n           cur = size \u003c 2 * cur ? 2 * cur : size;\n  ```\n  \n  # Index: include/parrot/memory.h\n  \n  --- include/parrot/memory.h (revision 48587)\n  +++ include/parrot/memory.h (working copy)\n  @@ -47,6 +47,7 @@\n  \n  #define mem_sys_memcopy memcpy\n  #define mem_sys_memmove memmove\n  +#define mem_sys_memset memset\n  \n  #define mem_allocate_typed(type)            (type *)mem_sys_allocate(sizeof (type))\n  #define mem_allocate_n_typed(n, type)       (type *)mem_sys_allocate((n) \\* sizeof (type))\n  \n  # Index: t/pmc/resizableintegerarray.t\n  \n  --- t/pmc/resizableintegerarray.t   (revision 48587)\n  +++ t/pmc/resizableintegerarray.t   (working copy)\n  @@ -43,7 +43,7 @@\n  \n  .sub main :main\n     .include 'test_more.pir'\n-    plan(47)\n-    plan(48)\n  \n   test_does_interfaces()\n\n@@ -59,7 +59,9 @@\n\n```\n test_conversion()\n test_conversion_overflow()\n```\n-    test_zero_after_resize()\n\n+\n     test_set_pmc_index()\n     test_get_pmc_index()\n\n@@ -255,6 +257,16 @@\n end:\n .end\n\n+.sub test_zero_after_resize\n-    $P0 = new ['ResizableIntegerArray']\n-    $P0 = 10\n-    $P0[7] = 23\n-    $P0 = 5\n-    $P0[9] = 0\n-    $I0 = $P0[7]\n-    is( $I0, 0, 'Latent elements are zeroed when array is shrunk and re-stretched' )\n  +.end\n  +\n  .sub test_conversion\n     $P0 = new ['ResizableIntegerArray']\n     $P0 = 6\n\n```\n```","files":null},{"type":3,"author":{"id":"2da6485217cbb88ff96be8f3dcc7f9ae44cf6bf0"},"timestamp":1282442387,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDI2NDg=","github-url":"https://github.com/parrot/parrot/issues/290#issuecomment-3502648"},"message":"\u003cp\u003e\nThe third patch does not pass the one test that it adds. I have updated the resizableintegerarray.patch2 to apply against r48587.\n\u003c/p\u003e","files":null},{"type":3,"author":{"id":"2da6485217cbb88ff96be8f3dcc7f9ae44cf6bf0"},"timestamp":1282442442,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDI2NDk=","github-url":"https://github.com/parrot/parrot/issues/290#issuecomment-3502649"},"message":"\u003cp\u003e\nZero out elements of ResizableIntegerArrays\n\u003c/p\u003e","files":null},{"type":3,"author":{"id":"2da6485217cbb88ff96be8f3dcc7f9ae44cf6bf0"},"timestamp":1355294894,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDExMjc4Njk3","github-url":"https://github.com/parrot/parrot/issues/290#issuecomment-11278697"},"message":"Looks like this patch was applied in d86b0f5978 , closing.","files":null}]}