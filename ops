{"version":1,"ops":[{"type":1,"author":{"id":"0c9c62332064205b2d799407019fa3e7e2f43862"},"timestamp":1279721566,"metadata":{"github-id":"MDU6SXNzdWUyODQ4Nzkz","github-url":"https://github.com/parrot/parrot/issues/585","origin":"github"},"title":"[BUG]  exit of a Coroutine affects all of its sister clones","message":"If any clone of a Coroutine dies, then it exits all of the clones.  The best way to illustrate is with code:\n\n```\n$ cat coro.pir \n.sub 'main' :main\n    .const 'Sub' $P99 = 'coro'\n\n    .local pmc three, four, five\n    three = clone $P99\n    four  = clone $P99\n    five  = clone $P99\n\n    three(3)\n    four(4)\n    five(5)\n\n    three()\n    four()\n    five()\n\n    three()\n.end\n\n.sub '' :anon :subid('coro')\n    .param int x\n    print x\n    say '.0'\n    .yield (x)\n\n    print x\n    say '.1'\n    .yield (x)\n\n    print x\n    say '.done'\n.end\n$ ./parrot coro.pir \n3.0\n4.0\n5.0\n3.1\n4.1\n5.1\n3.done\n4.done\n5.done\nCannot resume dead coroutine.\ncurrent instr.: 'main' pc 37 (coro.pir:11)\n$ \n```\n\nNote that calling the 'three' clone the final time is sufficient to make the 'four' and 'five' clones to also resume + exit (without being explicitly invoked), and leads to the \"Cannot resume dead coroutine\" exception.\n\nThis is very likely to be strongly related to TT #1702.\n\nOne possible workaround is to make sure that a coroutine never exits; e.g., by entering an infinite \"yield\" loop at the end of the Coroutine.  This is what PGE has apparently done for quite some time.\n\nPm\n\nOriginally http://trac.parrot.org/parrot/ticket/1710","files":null}]}