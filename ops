{"version":1,"ops":[{"type":5,"author":{"id":"86141a663c2eb7543d1a51ec6253a1d54de912fd"},"timestamp":1420553079,"metadata":{"github-id":"MDEyOkxhYmVsZWRFdmVudDIxNDY4MTE0Mg=="},"added":["Component-imcc"],"removed":[]},{"type":3,"author":{"id":"86141a663c2eb7543d1a51ec6253a1d54de912fd"},"timestamp":1420553696,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDY4ODY5NjU2","github-url":"https://github.com/parrot/parrot/issues/1168#issuecomment-68869656"},"message":"in both cases: `id:000115,sig:11,src:000000,op:havoc,rep:2` and `afl-out/crashes/id:000119,sig:11,src:000000,op:havoc,rep:8`\n\n```\nProgram received signal SIGSEGV, Segmentation fault.\n0x00007ffff7a5baa5 in try_rev_cmp (name=0x6fbc70 \"ge\", r=0x6f3ec8) at compilers/imcc/parser_util.c:650\n650             if (r[to_swap + 1]-\u003eset == 'P')\n(gdb) bt\n#0  0x00007ffff7a5baa5 in try_rev_cmp (name=0x6fbc70 \"ge\", r=0x6f3ec8) at compilers/imcc/parser_util.c:650\n\n(gdb) p r[to_swap + 1]\n$1 = (SymReg *) 0x0\n(gdb) p to_swap\n$2 = 0\n```","files":null},{"type":3,"author":{"id":"86141a663c2eb7543d1a51ec6253a1d54de912fd"},"timestamp":1420639761,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDY5MDI1ODM1","github-url":"https://github.com/parrot/parrot/issues/1168#issuecomment-69025835"},"message":"another nice one (`crash_3.pir`):\n\n```\n#!./parrot\n# afl crash 3 - GH #1168 - \n# src/call/context.c:713: failed assertion 'Parrot_pcc_get_regs_used(interp, ctx, REGNO_STR) \u003e idx'\n\n.sub main :main\n    $P1 = newclass \"Foo11\"\n    $P2 = new \"Foo11\"\n    $S1 = $P2\n    eq $S1, 'stringy thingy', ok\n  ok:     \n.end\n\n.namespace [ \"Foo11\" ]\n\n.sub 'get_string' :vtable\n    self.'bar'()\n    end\n    .return (\"stringy thingy\")\n.end\n\n.sub bar :method\n    say \":vtable implies self - called bar\"\n.end\n```\n\nleads to an invalid register index, which is only caught with --debugging,\nsrc/call/context.c:713\nPARROT_ASSERT(Parrot_pcc_get_regs_used(interp, ctx, REGNO_STR) \u003e idx)","files":null},{"type":3,"author":{"id":"86141a663c2eb7543d1a51ec6253a1d54de912fd"},"timestamp":1420886089,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDY5NDUxMzU2","github-url":"https://github.com/parrot/parrot/issues/1168#issuecomment-69451356"},"message":"Status:\nFixed all but one: - see https://github.com/parrot/parrot/issues/1168#issuecomment-69025835\n\nThis needs to be caught in imcc, before being executed in parrot","files":null},{"type":3,"author":{"id":"86141a663c2eb7543d1a51ec6253a1d54de912fd"},"timestamp":1420915344,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDY5NDY2ODA3","github-url":"https://github.com/parrot/parrot/issues/1168#issuecomment-69466807"},"message":"Actually, it's a vm bug, not a compiler bug. \n\n`end` ends the current interpreter runloop, but since calling user-defined methods go \nvia `ext_call` into a new interp, `end` inside a method behaves like a return, \njust without the proper continuation a `returncc` =\u003e `invoke` would do.\n\nbut the fix is still needed to go into the compiler: replace any `end` inside a `pcc_sub` to a `returncc`. \nthe interp issue is internally only. `end` ends the current runloop, which is the current function.","files":null},{"type":3,"author":{"id":"86141a663c2eb7543d1a51ec6253a1d54de912fd"},"timestamp":1420983468,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDY5NDk0NzI2","github-url":"https://github.com/parrot/parrot/issues/1168#issuecomment-69494726"},"message":".pir (and .pbc) can now be considered fuzzing safe","files":null},{"type":4,"author":{"id":"86141a663c2eb7543d1a51ec6253a1d54de912fd"},"timestamp":1420983468,"metadata":{"github-id":"MDExOkNsb3NlZEV2ZW50MjE3MDgzMzc2"},"status":2}]}