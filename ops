{"version":1,"ops":[{"type":3,"author":{"id":"aef4977f5ea786238d7c9581a2f192f4adc3f39d"},"timestamp":1267753884,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDM4MjI=","github-url":"https://github.com/parrot/parrot/issues/629#issuecomment-3503822"},"message":"\u003cp\u003e\nOkay, here are some preliminary digging results. This code prints what we expect:\n\u003c/p\u003e\n\n\u003cpre class=\"wiki\"\u003e.sub foo :main\n    .local pmc class_p\n    .local pmc class_nsp\n    class_p = newclass [ 'P' ]\n    class_nsp = newclass [\"N\";'S';'P']\n        say class_p\n        say class_nsp\n        $P0 = new ['P']\n        $P0.'bar'()\n        $P1 = new ['N';'S';'P']\n        $P1.'bar'()\n.end\n.namespace ['N';'S';'P']\n.sub bar :method\n    say \"NSP\"\n.end\n.namespace ['P']\n.sub bar :method\n    say \"P\"\n.end\n\u003c/pre\u003e\u003cp\u003e\nThis correctly says:\n\u003c/p\u003e\n\u003cpre class=\"wiki\"\u003eP\nN;S;P\nP\nNSP\n\u003c/pre\u003e\u003cp\u003e\nHowever, when we look up using the namespace, we have a problem:\n\u003c/p\u003e\n\u003cpre class=\"wiki\"\u003e.sub foo :main\n    .local pmc class_p\n    .local pmc class_nsp\n    class_p = newclass [ 'P' ]\n    $P1 = get_hll_namespace ['N';'S';'P']\n    class_nsp = get_class $P1\n        say class_p\n        say class_nsp\n        $P0 = new ['P']\n        $P0.'bar'()\n        $P1 = new ['N';'S';'P']\n        $P1.'bar'()\n.end\n.namespace ['N';'S';'P']\n.sub bar :method\n    say \"NSP\"\n.end\n.namespace ['P']\n.sub bar :method\n    say \"P\"\n.end\n\u003c/pre\u003e\u003cp\u003e\nWhich outputs something like this (I've ommitted line numbers since they are different in my test file:\n\u003c/p\u003e\n\u003cpre class=\"wiki\"\u003eP\nP\nP\nClass '[ 'N' ; 'S' ; 'P' ]' not found\n\u003c/pre\u003e","files":null},{"type":3,"author":{"id":"aef4977f5ea786238d7c9581a2f192f4adc3f39d"},"timestamp":1267754893,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDM4MjM=","github-url":"https://github.com/parrot/parrot/issues/629#issuecomment-3503823"},"message":"\u003cp\u003e\nNext piece of the puzzle. In src/oo.c:Parrot_oo_get_class, when we call it with the NSP namespace PMC from my example above, we hit this piece of code:\n\u003c/p\u003e\n\n\u003cpre class=\"wiki\"\u003eswitch (key-\u0026gt;vtable-\u0026gt;base_type) {\n  case enum_class_NameSpace:\n    classobj = VTABLE_get_class(interp, key);\n    break;\n\u003c/pre\u003e\u003cp\u003e\nHowever, at this point there is no NSP class object, VTABLE_get_class returns PMCNULL, and we enter a branch further down in the function that is intended to handle lazy creation of a PMCProxy. Here's the codepath it takes:\n\u003c/p\u003e\n\u003cpre class=\"wiki\"\u003etype = Parrot_pmc_get_type_str(interp, VTABLE_get_string(interp, key));\nclassobj = get_pmc_proxy(interp, type);\n\u003c/pre\u003e\u003cp\u003e\n...And when stringified, the namespace apparently is just \"P\". get_pmc_proxy, despite the name, doesn't get a PMCProxy for the type if a class is already defined for it. Instead, it returns the \"P\" class object, which is where Austin's code got lost.\n\u003c/p\u003e\n\n\u003cp\u003e\nI think the problem is calling get_class to lookup a Class object that doesn't exist yet. In this case, I think we should return PMCNULL from get_class until newclass is created. I'm going to hack that solution together now, test it, and commit it if things look good.\n\u003c/p\u003e","files":null},{"type":3,"author":{"id":"aef4977f5ea786238d7c9581a2f192f4adc3f39d"},"timestamp":1268437075,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDM4MjQ=","github-url":"https://github.com/parrot/parrot/issues/629#issuecomment-3503824"},"message":"\u003cp\u003e\nAfter looking through this some more, I can't think of a good way to fix this as-is. Here's the situation:\n\u003c/p\u003e\n\n\u003cp\u003e\nWhen we call get_class\u0026lt;namespace\u0026gt; and the requested class does not currently exist, one of two things could plausibly happen: (1) we return PMCNULL, or (2) we create the necessary class object on the fly and return that.\n\u003c/p\u003e\n\n\u003cp\u003e\nConfusing this issue is the fact that we don't always get back a Class, sometimes for built-in types we would get a PMCProxy instead. In case (1) above the get_class opcode would only need minimal changes but calling newclass is obviously wrong unless we make newclass smart enough to detect a built-in type name and create the PMCProxy instead of Class. In case (2) above, get_class would need to detect the built-in type name and then create the PMCProxy or Class object appropriately.\n\u003c/p\u003e\n\n\u003cp\u003e\nSince the arguments we're talking about here are NameSpaces, it's not a simple matter of calling NameSpace's get_string VTABLE to get the class name, since each namespace only contains the \"last name\". We would need to walk the entire -\u0026gt;parent chain to assemble the \"full name\" of the namespace, and then use that to determine if the type is built-in or not. No current functions in Parrot are suitable for this operation, and I suspect it will be difficult because C-based dynpmcs could be loaded into a different HLL namespace.\n\u003c/p\u003e\n\n\u003cp\u003e\nAlso we need to consider what to do in the case of an HLL override, whether we would want get_class to return the class of the override instead of the built-in type (this is a design decision that I think we can delay making for now).\n\u003c/p\u003e\n\n\u003cp\u003e\nThis ticket becomes much easier to resolve if PMCProxies for C-based PMCs are created more eagerly at VM startup time, or dynpmc load time. In that case, the NameSpace's get_class VTABLE \u003ci\u003ealways returns a non-null PMCProxy\u003c/i\u003e for C-based types, and the behavior of get_class\u0026lt;namespace\u0026gt; op becomes substantially easier. In case (2) above, get_class\u0026lt;namespace\u0026gt; either returns the existing proxy, returns an existing class, or creates a new Class (not needing to ever worry about creating a PMCProxy or conflicting with an existing C-based PMC type name). In case (1) above, newclass would need to lookup the NameSpace and ensure the -\u0026gt;class slot isn't already filled with a PMCProxy or existing Class, and then create a new one. Of course, if we're being passed a NameSpace as an argument, the lookup is already done.\n\u003c/p\u003e\n\n\u003cp\u003e\nI think chromatic's current plan for \u003ca class=\"closed ticket\" href=\"http://trac.parrot.org/parrot/ticket/389\" title=\"deprecation: subs with :method should not be entered as symbols in the namespace (closed: fixed)\"\u003e#389\u003c/a\u003e is to create PMCProxies eagerly as I describe here. If that's the case, we can fix this ticket shortly thereafter. If this is not his current intention or the final result of that work, I don't think this ticket can be reasonably fixed.\n\u003c/p\u003e","files":null},{"type":3,"author":{"id":"0c9c62332064205b2d799407019fa3e7e2f43862"},"timestamp":1290393727,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDM4MjU=","github-url":"https://github.com/parrot/parrot/issues/629#issuecomment-3503825"},"message":"\u003cblockquote class=\"citation\"\u003e\n\u003cp\u003e\n In case (2) above, get_class\u0026lt;namespace\u0026gt; either returns the existing proxy, returns an existing class, or creates a new Class (not needing to ever worry about creating a PMCProxy or conflicting with an existing C-based PMC type name).\n\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e\nIMO, get_class\u0026lt;namespace\u0026gt; should never automatically create a new Class PMC object.  It should return PMCNULL for non-existing classes.  (Built-in PMC types should be assumed to have a class object of some sort.)\n\u003c/p\u003e\n\n\u003cp\u003e\nPm\n\u003c/p\u003e","files":null},{"type":3,"author":{"id":"aef4977f5ea786238d7c9581a2f192f4adc3f39d"},"timestamp":1290399199,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDM4MjY=","github-url":"https://github.com/parrot/parrot/issues/629#issuecomment-3503826"},"message":"\u003cp\u003e\nI like that idea, Patrick. However, if I make that change the build fails horribly.\n\u003c/p\u003e\n\n\u003cpre class=\"wiki\"\u003e./parrot runtime/parrot/library/PGE/Perl6Grammar.pbc --output=compilers/tge/TGE/Parser.pir compilers/tge/TGE/Parser.pg\nParent isn't a Class.\ncurrent instr.: 'parrot;P6metaclass;add_parent' pc 278 (runtime/parrot/library/P6object.pir:243)\ncalled from Sub 'parrot;P6metaclass;register' pc 708 (runtime/parrot/library/P6object.pir:465)\ncalled from Sub 'parrot;PGE;Match;' pc 18 (compilers/pge/PGE/Match.pir:20)\ncalled from Sub 'parrot;PGE;Perl6Grammar;Compiler;__onload' pc 24 (runtime/parrot/library/PGE/Perl6Grammar.pir:74)\n... call repeated 1 times\n\u003c/pre\u003e\u003cp\u003e\nSo at the very least we are going to need a deprecation cycle and some non-trivial fixes to several areas of our standard runtime library. A quick review shows that TGE, PGE, and P6object are all going to need modifications in order to follow this rule. If this is okay for you, I can create a branch to start the work, and add in a deprecation notice.\n\u003c/p\u003e","files":null}]}