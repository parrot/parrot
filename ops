{"version":1,"ops":[{"type":3,"author":{"id":"aeaa659130ab92a2084a11638a6eb1a6beb03360"},"timestamp":1352458887,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDEwMjIyMzM2","github-url":"https://github.com/parrot/parrot/issues/809#issuecomment-10222336"},"message":"Some of the files mentioned in the thesis are in his [branch](https://github.com/niner/parrot/commits/chameneos_performance).  We should clean them up and steal them once threads are in master.   @niner, if you still have the source for your thesis lying around, it'd be nice to have as a starting point for developer documentation and examples.","files":null},{"type":3,"author":{"id":"507abfae537e007c08969e763a32a0acbd878b1b"},"timestamp":1352459509,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDEwMjIyNTY3","github-url":"https://github.com/parrot/parrot/issues/809#issuecomment-10222567"},"message":"On Friday 09 November 2012 03:01:29 cotto wrote:\n\n\u003e Some of the files mentioned in the thesis are in his\n\u003e [branch](https://github.com/niner/parrot/commits/chameneos_performance). \n\u003e We should clean them up and steal them once threads are in master.  \n\u003e @niner, if you still have the source for your thesis lying around, it'd be\n\u003e nice to have as a starting point for developer documentation and examples.\n\nJust pushed them to:\nhttps://github.com/niner/HybridThreads\n\nI wonder: which files did you only find in this branch? I thought, I put \neverything relevant into threads.\n\nStefan","files":null},{"type":3,"author":{"id":"aeaa659130ab92a2084a11638a6eb1a6beb03360"},"timestamp":1352487596,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDEwMjQwNDI3","github-url":"https://github.com/parrot/parrot/issues/809#issuecomment-10240427"},"message":"Thanks!  I didn't realize that your examples were already in the branch.  That'll be a big help.","files":null},{"type":3,"author":{"id":"86141a663c2eb7543d1a51ec6253a1d54de912fd"},"timestamp":1354650181,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDExMDEyMTI0","github-url":"https://github.com/parrot/parrot/issues/809#issuecomment-11012124"},"message":"Docs: Updated `pdd25_concurrency.pod` with links to the new green threads and hybrid threads explanations in 0396004edf7 and 0bc6d9ff94a18df\n\nWe still need to add documentation how and how not to access shared data, and how the Proxy PMC interfers with the GC\n\n#parrot11:\ndiakopter: does the GC scan other threads' memory areas for references to its own objects?\ndiakopter: (or traverse the other threads' live objects graph or whatever)\ndiakopter: in the thesis pdf, the implied answer is no.\ncotto: That's the impression I got too, but I haven't tested it.\ndiakopter: so my question is, what if another thread owns the object that has the only reference to an object?\ndiakopter: does this mean the GC can collect objects early/spuriously?\ndiakopter: (yes, if it doesn't scan other threads)\ndiakopter: but since (as stated in the thesis pdf) other threads can be _running_ while one thread's GC runs, that GC could miss an object while its only reference is moved from the area the GC hasn't scanned yet to the area it's already scanned.\ndiakopter: (if it actually does try to scan other threads)\ndiakopter: (or while the only reference to the object is in another CPU's register _only_)\ndiakopter: (regardless of the scanning technique (traverse or linear scan), the point still holds)\ndiakopter: the only reference can be moved on the graph while it's being traversed.\ncotto: let me check something\ndiakopter: my point is that either way (whether it scans other threads' stuff or not), it has the potential to miss references if other threads are allowed to run while it runs.\ndiakopter: .. and this is one thing the thesis makes very clear: that it is intended for other threads to run concurrently with the GC.\ncotto: The solution seems to  be that the Task holds a reference to shared objects.\ndiakopter: right, but what about when there is no Task pending\ndiakopter: surely it doesn't keep around all billion Tasks that could have run\ncotto: The reference will exist until the Task is destroyed, even if it's not executing anything at the moment.\ndiakopter: so threads cannot hold onto references to objects from other threads between requesting Tasks to be run?\ndiakopter: it's implied that, being a queue, Tasks go away after being executed\ndiakopter: (where else would they hang around)\ncotto: My impression is that Tasks are more like workers in that they don't get destroyed implicitly and that the parent can reuse them when needed.  Let me see if I can verify that,\ndiakopter: Tasks are requests from a child thread to the main thread or from the main thread to one of its child threads to perform a write operation on an object in the other thread\ndiakopter: only the main thread can spawn other threads.\ndiakopter: child threads cannot access/modify objects in each other.\ndiakopter: it doesn't say anything about parents reusing Tasks (what would it use them for?) requests to other threads?\n\ndiakopter: it says all read access must go through proxies which create read Tasks on the owner thread. If a write operation is occuring, but is preempted by a read operation, can it read the object in an inconsistent state, if the user implemented the data structure in user code (PIR or whatever)?\ndiakopter: the only ways I can think to mitigate this are to 1. not implement data structures that expect consistency during reads 2. use C for the write operations (since it only preempts on Branch) 3. use wait-free algorithms to make it fully threadsafe 4. can't use locks because of the potential for deadlock\ndiakopter: in any case, preventing the normal case (user implementing a data structure in user code)\ndiakopter: two other more specific cases of the \"only reference elsewhere\" question: if the only reference exists solely in another CPU's _register_ 2. if the only reeference exists in the Task queue of another thread, which would require obtaining a lock on _all_ the other threads' task queues, to not miss cross-writes)\n\nplus jonathans GC questions: http://irclog.perlgeek.de/perl6/2012-12-03#i_6209348\n#perl6:\n23:30   jnthn   rurban: If I solve things just by digging through the proxy to the underlying object, what happens?\n23:30   jnthn   rurban: That is, if the object is manipulated from another thread?\n23:30   rurban  read-only access should be fine.\n23:31       read-write forbidden\n23:31       for write we would need a mutex\n...\n23:33   jnthn   rurban: How's the GC handling the multiple threads?\n23:33   jnthn   rurban: I mean, is the problem with writes mostly connected to that?\n\nAnd http://irclog.perlgeek.de/perl6/2012-12-03#i_6209408\njnthn   rurban: If you have thread A owning the object that has the only reference to an object owned by thread B\n23:47       And thread A reads the reference into, say, a register and nulls it\n23:47       And then thread B runs its GC\n23:47       How does it know not to collect the object?","files":null},{"type":3,"author":{"id":"86141a663c2eb7543d1a51ec6253a1d54de912fd"},"timestamp":1416310704,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDYzNDU3NjM4","github-url":"https://github.com/parrot/parrot/issues/809#issuecomment-63457638"},"message":"Checked the content of `docs/pdds/pdd25_concurrency.pod`, it's good.","files":null},{"type":4,"author":{"id":"86141a663c2eb7543d1a51ec6253a1d54de912fd"},"timestamp":1416310704,"metadata":{"github-id":"MDExOkNsb3NlZEV2ZW50MTk0Nzk4MTYz"},"status":2},{"type":3,"author":{"id":"86141a663c2eb7543d1a51ec6253a1d54de912fd"},"timestamp":1416395917,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDYzNjI1NDQ5","github-url":"https://github.com/parrot/parrot/issues/809#issuecomment-63625449"},"message":"Added a bit about our thread-pool in 02b40b117af9c41447e8d1841e0809b87970ba83","files":null}]}