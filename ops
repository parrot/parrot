{"version":1,"ops":[{"type":1,"author":{"id":"8c86ede03c8e80b0dad5131138f96e957a4ee66b"},"timestamp":1380988577,"metadata":{"github-id":"MDU6SXNzdWUyMDU2NjQ5Nw==","github-url":"https://github.com/parrot/parrot/issues/1002","origin":"github"},"title":"const misunderstanding in coding standards doc","message":"Reported by: zefram@fysh.org\n\ndocs/pdds/pdd07_codingstd.pod has a section about using const qualification with pointers, with an example concerned with strlen. It says that in the code:\n\n```\nchar *p;\nint n = strlen(p);\n```\n\n, the fact that strlen's parameter is typed \"`const char *`\" is what lets the compiler diagnose use of an uninintialised value. This is incorrect. In the code fragment given, p has not been initialised, so using it as the argument to any function is use of an uninitialised value, regardless of the declared types of p or the function parameter. (C passes by value, not by reference.) The nearby situation where const qualification _is_ relevant is:\n\n```\nchar c;\nint n = strlen(\u0026c);\nchar d = c;\n```\n\nIn this case, c might be used uninitialised when being copied to d. The compiler might consider whether strlen might initialise c through its pointer parameter. The const qualification means that it cannot, and therefore c is indeed used uninitialised when being copied to d. (In fact, c is used uninitialised earlier, inside strlen, but the compiler can't determine that without specific knowledge of strlen's behaviour.)\n\nBut all of that is a rather dubious motivation for using const. A better one is that it catches mistakes involving modifying an object that, by API contract, the code isn't permitted to.\n\n-zefram","files":null}]}