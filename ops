{"version":1,"ops":[{"type":3,"author":{"id":"0782f66a529ccd24e18226f5eebab20a90bea166"},"timestamp":1257471482,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDM1NjQ=","github-url":"https://github.com/parrot/parrot/issues/556#issuecomment-3503564"},"message":"\u003cp\u003e\nOriginally reported in \u003ca   href=\"http://rt.perl.org/rt3/Ticket/Display.html?id=61224\"\u003e\u003cspan class=\"icon\"\u003e \u003c/span\u003ehttp://rt.perl.org/rt3/Ticket/Display.html?id=61224\u003c/a\u003e\n\u003c/p\u003e\n\n\u003cp\u003e\nSee also TT \u003ca class=\"new ticket\" href=\"http://trac.parrot.org/parrot/ticket/760\" title=\"patch: readline_interactive method no longer returns PMCNULL on eof (new)\"\u003e#760\u003c/a\u003e\n\u003c/p\u003e","files":null},{"type":3,"author":{"id":"0782f66a529ccd24e18226f5eebab20a90bea166"},"timestamp":1257471500,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDM1NjU=","github-url":"https://github.com/parrot/parrot/issues/556#issuecomment-3503565"},"message":"\u003cp\u003e\nComment from allison:\n\u003c/p\u003e\n\n\u003cp\u003e\nOn Tue Dec 09 06:36:51 2008, jonathan@… wrote:\n\u003c/p\u003e\n\n\u003cblockquote class=\"citation\"\u003e\n\u003cp\u003e\n Hi,\n It seems that the .eof() method on file handles can sometimes return\n true even if there is nothing more to read.\n\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e\nYes, a read that returns 0 bytes is what sets the EOF flag. (True of any\nkind of read other than one that requests 0 bytes.)\n\u003c/p\u003e\n\n\u003cp\u003e\nThis behavior is the same as the old implementation.\n\u003c/p\u003e\n\n\u003cblockquote class=\"citation\"\u003e\n\u003cp\u003e\n This occurs when you have\n read upto the last byte of a file (e.g. when a readline reads up to the\n end of a newline, and that newline is the last thing in the file), but\n not beyond (which seems to be what causes the EOF flag to be set). I'm\n thinking this is the wrong behaviour?\n\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e\nThe way to check if the byte after the last requested byte is the end of\nthe file is to read ahead. Perl (at least 5.10) does this by actually\nreading the next character and then putting it back with 'ungetc'. Not\nthe best solution. Any read ahead can be a bit expensive. I experimented\nwith a quick patch to use 'peek' in the test for EOF in Parrot, just to\nsee what would happen... it broke a large quantity of code (probably\nbecause all the code is expecting the old behavior of the EOF test, or\npossibly a bug in 'peek').\n\u003c/p\u003e\n\n\u003cp\u003e\nAt the end of the day, it's a cost/benefit question. Individual\nlanguages can implement the 1 character lookahead with the current I/O\nsystem if they need it. Will all languages (or even most languages) want\nthe 1 character lookahead?\n\u003c/p\u003e\n\n\u003cp\u003e\nAllison\n\u003c/p\u003e","files":null},{"type":3,"author":{"id":"0782f66a529ccd24e18226f5eebab20a90bea166"},"timestamp":1257471529,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDM1NjY=","github-url":"https://github.com/parrot/parrot/issues/556#issuecomment-3503566"},"message":"\u003cp\u003e\nComment from Joshua Juran:\n\u003c/p\u003e\n\n\u003cp\u003e\nOn Dec 11, 2008, at 5:07 PM, Allison Randal via RT wrote:\n\u003c/p\u003e\n\n\u003cblockquote class=\"citation\"\u003e\n\u003cp\u003e\n The way to check if the byte after the last requested byte is the\n end of\n the file is to read ahead. Perl (at least 5.10) does this by actually\n reading the next character and then putting it back with 'ungetc'. Not\n the best solution. Any read ahead can be a bit expensive. I\n experimented\n with a quick patch to use 'peek' in the test for EOF in Parrot,\n just to\n see what would happen... it broke a large quantity of code (probably\n because all the code is expecting the old behavior of the EOF test, or\n possibly a bug in 'peek').\n\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e\nIf I'm understanding correctly, unrequested read-ahead is an error.\nThe problem is that you can't put the toothpaste back into the tube,\nso to speak. Continuing with this analogy, calling ungetc() is like\nputting the extra toothpaste in a paper cup for later. If I'm the\nnext person to brush my teeth, then sure, I'll scrape the toothpaste\nout of the cup first before I get more from the tube, but any\nhypothetical roommates would regard the cup as personal to me and\nignore it, going straight for the tube.\n\u003c/p\u003e\n\n\u003cp\u003e\nToothpaste is fungible, though, and it doesn't matter in what order\nit's used, whereas the same is not true of streamed bytes. If\nmultiple processes are sharing a file descriptor and coordinating\nreads from it, any non-undoable read-ahead* will break the protocol.\n\u003c/p\u003e\n\n\u003cp\u003e\n* Read-ahead could be undone via lseek() for files, or be done non-\ndestructively with recv( ..., MSG_PEEK ) for sockets.\n\u003c/p\u003e\n\n\u003cp\u003e\nJosh\n\u003c/p\u003e","files":null},{"type":3,"author":{"id":"0782f66a529ccd24e18226f5eebab20a90bea166"},"timestamp":1257471566,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDM1Njc=","github-url":"https://github.com/parrot/parrot/issues/556#issuecomment-3503567"},"message":"\u003cp\u003e\nThis ticket needs a design decision in order to proceed.\n\u003c/p\u003e","files":null},{"type":3,"author":{"id":"d9b4aee65ce8c18d4a43eced1eecb0d154e1eebb"},"timestamp":1298625312,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDM1Njg=","github-url":"https://github.com/parrot/parrot/issues/556#issuecomment-3503568"},"message":"\u003cp\u003e\nReplying to \u003ca href=\"http://trac.parrot.org/parrot/ticket/1212#comment:4\" title=\"Comment 4 for Ticket #1212\"\u003ecoke\u003c/a\u003e:\n\u003c/p\u003e\n\n\u003cblockquote class=\"citation\"\u003e\n\u003cp\u003e\n This ticket needs a design decision in order to proceed.\n\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e\nAccordingly, cc-ing the current architect.\n\u003c/p\u003e\n\n\u003cp\u003e\nkid51\n\u003c/p\u003e","files":null},{"type":3,"author":{"id":"aeaa659130ab92a2084a11638a6eb1a6beb03360"},"timestamp":1298645321,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDM1Njk=","github-url":"https://github.com/parrot/parrot/issues/556#issuecomment-3503569"},"message":"\u003cp\u003e\nThe original report from jnthn is confusing.  I can see it being a potential issue that fh.eof() returns *false* when there are 0 bytes left in a file but a read hasn't returned fewer bytes than requested.  A build from the day the original rt was filed displays the same behavior as a current build (modulo some api changes), so presumably that was the intent of the ticket.\n\u003c/p\u003e\n\n\u003cp\u003e\nGiven that, I'd like to avoid trying to secretly read and unread an extra character if we can make fh.eof do so reliably and portably.  If that's not an option, we should document the surprising behavior and give HLLs the tools they need to do whatever makes sense for their users.\n\u003c/p\u003e","files":null},{"type":3,"author":{"id":"6d59fc378929d99368e023bcfc49aacae1e68aad"},"timestamp":1298674584,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDM1NzA=","github-url":"https://github.com/parrot/parrot/issues/556#issuecomment-3503570"},"message":"\u003cp\u003e\nReplying to \u003ca href=\"http://trac.parrot.org/parrot/ticket/1212#comment:7\" title=\"Comment 7 for Ticket #1212\"\u003ecotto\u003c/a\u003e:\n\u003c/p\u003e\n\n\u003cblockquote class=\"citation\"\u003e\n\u003cp\u003e\n The original report from jnthn is confusing.  I can see it being a potential issue that fh.eof() returns *false* when there are 0 bytes left in a file but a read hasn't returned fewer bytes than requested.\n\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e\nThis is the documented and expected behavior of the C-level stdio function feof(3).  It's intended as an after-the-fact error status check after you've hit the end of the file.  (It is occasionally useful in distinguishing among various error conditions that may cause an fread(3) to return less than the asked-for number of bytes).\n\u003c/p\u003e\n\n\u003cp\u003e\nPerl 5 does implement the ungetc look-ahead trick in some circumstances, but \u003ctt\u003e perldoc -f eof \u003c/tt\u003e also contains this hint:\n\u003c/p\u003e\n\n\u003cblockquote\u003e\n\u003cp\u003e\nPractical hint: you almost never need to use \"eof\" in Perl,\nbecause the input operators typically return \"undef\" when they\nrun out of data, or if there was an error.\n\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cblockquote class=\"citation\"\u003e\n\u003cp\u003e\n Given that, I'd like to avoid trying to secretly read and unread an extra character if we can make fh.eof do so reliably and portably.  If that's not an option, we should document the surprising behavior and give HLLs the tools they need to do whatever makes sense for their users.\n\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e\nThis ticket appears to request a predictive fh.eof() function that asks what would happen if you tried to read another character, without actually reading another character.  I don't know how you could implement that reliably and portably for all different types of inputs.  I suppose one could do it only on file handles that also advertise the .ungetc method, but then the .eof function becomes even more magically erratic in its actual behavior.\n\u003c/p\u003e\n\n\u003cp\u003e\nI think parrot should simply provide the fh.eof function that answers the question of whether the previous read ran off the end of the file.  The HLL writer (or the end user) who has more context about the particular input source in question may be able to provide something more predictive.\n\u003c/p\u003e","files":null},{"type":3,"author":{"id":"aeaa659130ab92a2084a11638a6eb1a6beb03360"},"timestamp":1298684059,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDM1NzE=","github-url":"https://github.com/parrot/parrot/issues/556#issuecomment-3503571"},"message":"\u003cp\u003e\nThe approach of providing a dumb eof for FileHandle and letting users build on top of it makes sense to me and seems preferable to trying to dtrt while avoid unexpected costs and side-effects.  I updated the description of the relevant functions in 8c0d19cc9 so that anyone reading them will be made aware of their potentially surprising behavior.  I'll leave this ticket open in case anyone wants to argue for a smarter fh.eof, but if nobody responds within 2 week we can consider the matter closed.\n\u003c/p\u003e","files":null},{"type":3,"author":{"id":"0c9c62332064205b2d799407019fa3e7e2f43862"},"timestamp":1298686814,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDM1NzI=","github-url":"https://github.com/parrot/parrot/issues/556#issuecomment-3503572"},"message":"\u003cpre class=\"wiki\"\u003eOn Fri, Feb 25, 2011 at 05:34:19PM -0000, Parrot wrote:\n\u0026gt;  The approach of providing a dumb eof for FileHandle and letting users\n\u0026gt;  build on top of it makes sense to me and seems preferable to trying to\n\u0026gt;  dtrt while avoid unexpected costs and side-effects.\n\u0026gt; [...]\nJust wanted to add a \"me too\" to this -- in the general case I don't\nthink it's possible to detect that you've reached the end of file\nuntil you actually try to read beyond it.  And many handles are\nreally streams where the length _can't_ be known until an attempt\nis made to read from the handle and there's nothing more to read.\nI'd much rather have a .eof that works consistently across handles\nthan one that tries to be smart about it in certain (albeit\ncommon) cases.  And the traditional interpretation of \"eof\" in\nmost languages I've dealt with has been that it occurs _after_ a\nread has failed.\nI strongly recommend that the current behavior is the \"correct\"\none for Parrot and that we should reject this ticket.\nPm\n\u003c/pre\u003e","files":null},{"type":3,"author":{"id":"d9b4aee65ce8c18d4a43eced1eecb0d154e1eebb"},"timestamp":1298705934,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDM1NzM=","github-url":"https://github.com/parrot/parrot/issues/556#issuecomment-3503573"},"message":"\u003cp\u003e\ncotto:\n\u003c/p\u003e\n\n\u003cp\u003e\nAm I correct in thinking that the consensus is to reject this ticket?\n\u003c/p\u003e\n\n\u003cp\u003e\nI'll assign it to you so that you can make the final call.\n\u003c/p\u003e\n\n\u003cp\u003e\nThank you very much.\n\u003c/p\u003e\n\n\u003cp\u003e\nkid51\n\u003c/p\u003e","files":null}]}