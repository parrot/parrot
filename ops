{"version":1,"ops":[{"type":3,"author":{"id":"86141a663c2eb7543d1a51ec6253a1d54de912fd"},"timestamp":1235130475,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDMwMjk=","github-url":"https://github.com/parrot/parrot/issues/408#issuecomment-3503029"},"message":"9493 byte attachment from rurban\nat http://trac.parrot.org/parrot/raw-attachment/ticket/359/tt359-pbc_uuid.patch\n\n# ```Index: parrot-svn/lib/Parrot/BuildUtil.pm\n\n--- parrot-svn.orig/lib/Parrot/BuildUtil.pm\n+++ parrot-svn/lib/Parrot/BuildUtil.pm\n@@ -12,9 +12,9 @@ Parrot::BuildUtil - Utilities for buildi\n\n =head1 DESCRIPTION\n\n-This package holds three subroutines:  C\u003cparrot_version()\u003e, C\u003cslurp_file\u003e,\n-and C\u003cgenerated_file_header\u003e. Subroutines are not exported--each must be\n-requested by using a fully qualified name.\n+This package holds pre-configure time subroutines, which are not exported\n+and should not require Parrot::Config.\n+Each must be requested by using a fully qualified name.\n\n =head1 SUBROUTINES\n\n@@ -134,13 +134,60 @@ END_HEADER\n     return $header;\n }\n\n-1;\n+=item C\u003cgenerate_pbc_fingerprint()\u003e\n\n-=back\n+Generate a unique number, the md5 of F\u003cPBC_COMPAT\u003e,\n+for each pbc format change. The length (12) influences\n+the header layout.\n+\n+This is used in the packfile library.\n+See also F\u003ctools/dev/pbc_header.pl\u003e\n+\n+=cut\n+\n+sub generate_pbc_fingerprint {\n+\n-    unless (eval { require Digest::MD5; }) {\n-        warn \"Digest::MD5 not found. Skipping fingerprint\";\n-        return '';\n-    }\n-    my $content = slurp_file('PBC_COMPAT');\n-    $content =~ s/^#.*\\n//gm;\n-    $content =~ s/^\\n//gm;\n-    my $fingerprint = Digest::MD5::md5($content);\n-    return substr $fingerprint, 0, 12;\n  +}\n  +\n  +=item C\u003cget_bc_version()\u003e\n  +\n  +Return an array of ($bc_major, $bc_minor) from F\u003cPBC_COMPAT\u003e.\n  +This is used to generate the pbc_uuid.\n\n-=head1 AUTHOR\n+See also F\u003ctools/dev/pbc_header.pl\u003e and F\u003ctools/build/pbcversion_h.pl\u003e.\n\n-Gregor N. Purdy.  Revised by James E Keenan.\n+=cut\n+\n+sub get_bc_version {\n-    my $compat_file = 'PBC_COMPAT';\n-    my ( $bc_major, $bc_minor );\n-    open my $IN, '\u003c', $compat_file or die \"Can't read $compat_file\";\n-    while (\u003c$IN\u003e) {\n-        if (/^(\\d+).0*(\\d+)/) {\n-            ( $bc_major, $bc_minor ) = ( $1, $2 );\n-            last;\n-        }\n-    }\n-    unless ( defined $bc_major \u0026\u0026 defined $bc_minor ) {\n-        die \"No bytecode version found in '$compat_file'.\";\n-    }\n-    close $IN;\n-    return ( $bc_major, $bc_minor );\n  +}\n  +\n  +\n  +1;\n  +\n  +=back\n  \n  =cut\n\n# Index: parrot-svn/tools/dev/pbc_header.pl\n\n--- parrot-svn.orig/tools/dev/pbc_header.pl\n+++ parrot-svn/tools/dev/pbc_header.pl\n@@ -36,28 +36,14 @@ headers.\n =cut\n\n use Getopt::Long;\n-use Digest::MD5 qw(md5);\n+use lib \"lib\";\n+use Parrot::BuildUtil;\n\n my %opt;\n-use constant FP_LEN =\u003e 12;\n my $word_size = 4;\n\n main();\n\n## -sub get_fp {\n-    # s. also fingerprint_c.pl\n-    my $compat_file = 'PBC_COMPAT';\n-    open my $IN, '\u003c', $compat_file or die \"Can't read $compat_file\";\n-    my @lines = \u003c$IN\u003e;\n\n## \\-    close $IN;\n-    my $len = FP_LEN;\n\n## \\-    my $fingerprint = md5 join \"\\n\", grep { !/^#/ } @lines;\n-    return substr $fingerprint, 0, $len;\n  \n  ## -}\n  \n  sub get_version {\n     my $version_file = 'VERSION';\n     open my $IN, '\u003c', $version_file or die \"Can't read $version_file\";\n  @@ -87,7 +73,8 @@ sub get_bc_version {\n  sub update_fp {\n     my (@args) = @_;\n-    my $fp = get_fp();\n-    my $fp = Parrot::BuildUtil::generate_pbc_fingerprint();\n-    my $fp_len = length $fp;\n   my ( $major, $minor, $patch ) = get_version();\n   my ( $bc_major, $bc_minor ) = get_bc_version();\n   for my $f (@args) {\n  @@ -104,12 +91,12 @@ sub update_fp {\n       # uuid_type = 1, uuid_size = 10, uuid_data = $fp\n       read $F, $b, 8;\n       my ($type, $uuid_len) = unpack \"cc\", $b;\n-        if ($type != 1 or $uuid_len != FP_LEN) {\n-        if ($type != 1 or $uuid_len != $fp_len) {\n           # if uuid_type was 0 or of different size copy the tail first\n           my $leftover = (18 + $uuid_len) % 16;\n           my $n = $leftover == 0 ? 0 : 16 - $leftover;\n-            # we can skip the copy if there's enough room already (pad:14=\u003e2)\n-            goto SEEK if $n \u003c FP_LEN;\n-            # we can skip the copy if there's enough room already (pad: 14=\u003e2)\n-            goto SEEK if $n \u003e $fp_len;\n           my $dirstart = 18 + $uuid_len + $n;\n           seek $F, $dirstart, 0;   # skip to dir\n           my $size = -s $F;\n  @@ -119,7 +106,7 @@ sub update_fp {\n       }\n     SEEK:\n       seek $F, 16, 0;   # back to pos 16: uuid_type, uuid_size\n-        print $F pack \"cc\", 1, FP_LEN;\n- ```\n     print $F pack \"cc\", 1, $fp_len;\n   print $F $fp;\n   close $F;\n  ```\n  \n   }\n  \n  # Index: parrot-svn/config/gen/config_h/config_h.in\n  \n  --- parrot-svn.orig/config/gen/config_h/config_h.in\n  +++ parrot-svn/config/gen/config_h/config_h.in\n  @@ -94,6 +94,7 @@ struct PackFile;      typedef struct Pac\n  #define PARROT_BYTEORDER        0x@byteorder@\n  #define PARROT_BIGENDIAN        @bigendian@\n  #define PARROT_PTR_ALIGNMENT    @ptr_alignment@\n  +#define PARROT_PBC_UUID         \"@pbc_uuid@\"\n  \n  #define PARROT_LITTLEENDIAN    !(PARROT_BIGENDIAN)\n\n# Index: parrot-svn/src/packfile.c\n\n--- parrot-svn.orig/src/packfile.c\n+++ parrot-svn/src/packfile.c\n@@ -1245,6 +1245,15 @@ PackFile_set_header(ARGOUT(PackFile_Head\n #    endif\n #  endif\n #endif\n-    if (*PARROT_PBC_UUID) {\n-        header-\u003euuid_type = 1;\n-        header-\u003euuid_size = sizeof(PARROT_PBC_UUID);\n-        header-\u003euuid_data = (unsigned char *)PARROT_PBC_UUID;\n-        mem_sys_allocate(header-\u003euuid_size + 1);\n-        memcpy(header-\u003euuid_data, PARROT_PBC_UUID, header-\u003euuid_size);\n-        /\\* NULL terminate */\n-        header-\u003euuid_data[header-\u003euuid_size] = 0;\n-    }\n  }\n\n# Index: parrot-svn/Configure.pl\n\n--- parrot-svn.orig/Configure.pl\n+++ parrot-svn/Configure.pl\n@@ -64,8 +64,9 @@ $conf-\u003eadd_steps( @{ $steps_list_ref } )\n # from Parrot::Configure::Data\n $conf-\u003eoptions-\u003eset( %{$args} );\n # save the command-line for make reconfig\n-$conf-\u003edata-\u003eset(configure_args =\u003e @ARGV ? '\"'.join(\"\\\" \\\"\", map {qq($_)} @ARGV).'\"'\n-                                         : '');\n  +$conf-\u003edata-\u003eset(configure_args =\u003e\n-                 @ARGV ? '\"'.join(\"\\\" \\\"\", map {qq($_)} @ARGV).'\"'\n- ```\n                    : '');\n  ```\n  \n  # Log files created by Configure.pl in MANIFEST.configure.generated\n  \n  $conf-\u003e{active_configuration} = 1;\n  \n  # Index: parrot-svn/config/auto/pmc.pm\n  \n  --- parrot-svn.orig/config/auto/pmc.pm\n  +++ parrot-svn/config/auto/pmc.pm\n  @@ -9,6 +9,9 @@ config/auto/pmc.pm - PMC Files\n  \n  Asks the user to select which PMC files to include.\n\n+Generate a specific UUID for this selection then,\n+for the default use the md5 of PBC_COMPAT.\n+\n =cut\n\n package auto::pmc;\n@@ -22,6 +25,7 @@ use File::Basename qw/basename/;\n use File::Spec::Functions qw/catfile/;\n\n use Parrot::Configure::Utils ':auto';\n+use Parrot::BuildUtil;\n\n sub _init {\n     my $self = shift;\n@@ -168,9 +172,28 @@ PMC: for my $pmc_file ( split( /\\s+/, $p\n\n```\n my @names = $self-\u003eorder_pmcs_by_hierarchy( \\%parents );\n```\n-    # Generate a specific UUID for user-defined pmc's and ops\n-    # auto::ops runs before auto::pmc, so do it here.\n-    my $pbc_uuid = '';\n-    if ($conf-\u003eoptions-\u003eget('pmc') or $conf-\u003eoptions-\u003eget('ops')) {\n-        unless (eval { require Digest::MD5; }) {\n-            warn \"Digest::MD5 not found. Skipping fingerprint\";\n-        }\n-        else {\n-            my ( $major, $minor ) = Parrot::BuildUtil::get_bc_version();\n-            my $ops = $conf-\u003edata-\u003eget( 'ops' );\n-            my $fp = join( ' ', @names ) . \" \". $ops . \" \" . $major . \" \" . $minor;\n-            $pbc_uuid = substr Digest::MD5::md5( $fp ), 0, 12;\n-        }\n-    }\n-    else { # use the default UUID. This requires PBC_COMPAT discipline\n-        $pbc_uuid = Parrot::BuildUtil::generate_pbc_fingerprint();\n-    }\n  +\n   $conf-\u003edata-\u003eset(\n       pmc                  =\u003e $pmc_list,\n       pmc_names            =\u003e join( ' ', @names ),\n-        pbc_uuid             =\u003e $pbc_uuid,\n       TEMP_pmc_o           =\u003e $TEMP_pmc_o,\n       TEMP_pmc_build       =\u003e $TEMP_pmc_build,\n       TEMP_pmc_classes_o   =\u003e $TEMP_pmc_classes_o,\n  Index: parrot-svn/tools/build/pbcversion_h.pl\n  ===================================================================\n  --- parrot-svn.orig/tools/build/pbcversion_h.pl\n  +++ parrot-svn/tools/build/pbcversion_h.pl\n  @@ -21,28 +21,15 @@ them in a header file.\n  use warnings;\n  use strict;\n  use lib 'lib';\n  +use Parrot::BuildUtil;\n\n## -my ( $major, $minor );\n\n-my $compat_file = 'PBC_COMPAT';\n-open my $IN, '\u003c', $compat_file or die \"Can't read $compat_file\";\n-while (\u003c$IN\u003e) {\n-    if (/^(\\d+).0*(\\d+)/) {\n-        ( $major, $minor ) = ( $1, $2 );\n-        last;\n-    }\n  -}\n  -close $IN;\n  -\n  -unless ( defined $major \u0026\u0026 defined $minor ) {\n-    die \"No bytecode version found in '$compat_file'.\";\n  -}\n  +my ( $major, $minor ) = Parrot::BuildUtil::get_bc_version();\n  \n  print \u003c\u003c \"EOF\";\n  /\\* ex: set ro:\n  - !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!\n    *\n- \\* This file is generated automatically from '$compat_file'\n- - This file is generated automatically from 'PBC_COMPAT'\n  - by $0.\n    *\n  - Any changes made here will be lost!\n    Index: parrot-svn/config/auto/ops.pm\n    ===================================================================\n    --- parrot-svn.orig/config/auto/ops.pm\n    +++ parrot-svn/config/auto/ops.pm\n    @@ -9,6 +9,8 @@ config/auto/ops.pm - Ops Files\n  \n  Asks the user to select which ops files to include.\n\n+Generate a specific UUID for this selection in auto::pmc then.\n+\n =cut\n\n package auto::ops;\n\n```\n```","files":null},{"type":3,"author":{"id":"86141a663c2eb7543d1a51ec6253a1d54de912fd"},"timestamp":1235148688,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDMwMzA=","github-url":"https://github.com/parrot/parrot/issues/408#issuecomment-3503030"},"message":"13553 byte attachment from rurban\nat http://trac.parrot.org/parrot/raw-attachment/ticket/359/tt359-pbc_uuid.2.patch\n\n```[core] TT #359 implement pbc_uuid writing\n- pbc_uuid now binary safe, as md5_base64 size=23\n- pbc_uuid is calculated in auto::pmc, after auto::ops. \n  Two use-cases:\n  1) on user-defined pmc and ops take this name list, plus bc_major, bc_minor.\n  2) default: md5 of PBC_COMPAT\n- What should else should be taken into the uuid? I just have the pmc and ops\n  names plus bc version, but in reality all the public interfaces are needed also.\n- Two generic pbc functions are moved to Parrot::BuildUtil, get_bc_version() and\n  generate_pbc_fingerprint(). This simplifies dev/pbc_header.pl and\n  tools/build/pbcversion_h.pl.\n- Added an exported Parrot_freeze_size, currently the same as Parrot_freeze, \n  but should internally use VISIT_FREEZE_SIZE, not to malloc/free around like crazy.\n\nMissing:\n- warnings/errors on mismatches.\n- generate better a UUID, based on changed interfaces (configure-time), not\n  a required change description in PBC_COMPAT.\n\n# Index: parrot-svn/lib/Parrot/BuildUtil.pm\n\n--- parrot-svn.orig/lib/Parrot/BuildUtil.pm 2009-02-20 14:27:44.000000000 +0000\n+++ parrot-svn/lib/Parrot/BuildUtil.pm  2009-02-20 14:28:28.015875000 +0000\n@@ -12,9 +12,9 @@\n\n =head1 DESCRIPTION\n\n-This package holds three subroutines:  C\u003cparrot_version()\u003e, C\u003cslurp_file\u003e,\n-and C\u003cgenerated_file_header\u003e. Subroutines are not exported--each must be\n-requested by using a fully qualified name.\n+This package holds pre-configure time subroutines, which are not exported\n+and should not require Parrot::Config.\n+Each must be requested by using a fully qualified name.\n\n =head1 SUBROUTINES\n\n@@ -134,13 +134,65 @@\n     return $header;\n }\n\n-1;\n+=item C\u003cgenerate_pbc_fingerprint()\u003e\n\n-=back\n+Generate a unique number, the md5 of either the given arguments or\n+of the non-commented lines of F\u003cPBC_COMPAT\u003e, for each pbc format change.\n+\n+This is used in the packfile library.\n+See also F\u003ctools/dev/pbc_header.pl\u003e\n+\n+=cut\n+\n+sub generate_pbc_fingerprint {\n+\n-    unless (eval { require Digest::MD5; }) {\n-        warn \"Digest::MD5 not found. Skipping fingerprint\";\n-        return '';\n-    }\n-    my $uuid;\n-    if (@_) {\n-        $uuid = Digest::MD5::md5_base64(join \" \", @_);\n-    }\n-    else {\n-        my $content = slurp_file('PBC_COMPAT');\n-        $content =~ s/^#.*\\n//gm;\n-        $content =~ s/^\\n//gm;\n-        $uuid = Digest::MD5::md5_base64($content);\n-    }\n-    return substr $uuid, 0, 22;\n  +}\n  +\n  +=item C\u003cget_bc_version()\u003e\n  +\n  +Return an array of ($bc_major, $bc_minor) from F\u003cPBC_COMPAT\u003e.\n  +This is used to generate the pbc_uuid.\n\n-=head1 AUTHOR\n+See also F\u003ctools/dev/pbc_header.pl\u003e and F\u003ctools/build/pbcversion_h.pl\u003e.\n\n-Gregor N. Purdy.  Revised by James E Keenan.\n+=cut\n+\n+sub get_bc_version {\n-    my $compat_file = 'PBC_COMPAT';\n-    my ( $bc_major, $bc_minor );\n-    open my $IN, '\u003c', $compat_file or die \"Can't read $compat_file\";\n-    while (\u003c$IN\u003e) {\n-        if (/^(\\d+).0*(\\d+)/) {\n-            ( $bc_major, $bc_minor ) = ( $1, $2 );\n-            last;\n-        }\n-    }\n-    unless ( defined $bc_major \u0026\u0026 defined $bc_minor ) {\n-        die \"No bytecode version found in '$compat_file'.\";\n-    }\n-    close $IN;\n-    return ( $bc_major, $bc_minor );\n  +}\n  +\n  +\n  +1;\n  +\n  +=back\n  \n  =cut\n\n# Index: parrot-svn/tools/dev/pbc_header.pl\n\n--- parrot-svn.orig/tools/dev/pbc_header.pl 2009-02-20 14:27:44.000000000 +0000\n+++ parrot-svn/tools/dev/pbc_header.pl  2009-02-20 14:28:28.015875000 +0000\n@@ -36,60 +36,21 @@\n =cut\n\n use Getopt::Long;\n-use Digest::MD5 qw(md5);\n+use lib \"lib\";\n+use Parrot::BuildUtil;\n\n my %opt;\n-use constant FP_LEN =\u003e 12;\n-my $word_size = 4;\n+my $word_size = 4; # fixed and not opcode_t_size !\n\n main();\n\n## -sub get_fp {\n-    # s. also fingerprint_c.pl\n-    my $compat_file = 'PBC_COMPAT';\n-    open my $IN, '\u003c', $compat_file or die \"Can't read $compat_file\";\n-    my @lines = \u003c$IN\u003e;\n\n## \\-    close $IN;\n-    my $len = FP_LEN;\n\n## \\-    my $fingerprint = md5 join \"\\n\", grep { !/^#/ } @lines;\n-    return substr $fingerprint, 0, $len;\n  -}\n  -\n  -sub get_version {\n-    my $version_file = 'VERSION';\n-    open my $IN, '\u003c', $version_file or die \"Can't read $version_file\";\n-    my $v = \u003c$IN\u003e;\n-    close $IN;\n-    $v =~ /^(\\d+).(\\d+).?(\\d+)?/;\n-    my ($major, $minor, $patch) = ($1, $2, $3 ? $3 : 0);\n-    die \"Can't read $version_file\" unless defined $major;\n-    return ( $major, $minor, $patch );\n  -}\n  -\n  -sub get_bc_version {\n-    my $compat_file = 'PBC_COMPAT';\n-    my ( $major, $minor );\n-    open my $IN, '\u003c', $compat_file or die \"Can't read $compat_file\";\n-    while (\u003c$IN\u003e) {\n-        if (/^(\\d+).0*(\\d+)/) {\n-            ( $major, $minor ) = ( $1, $2 );\n-            last;\n-        }\n-    }\n-    die \"Can't read $compat_file\" unless defined $major;\n-    close $IN;\n-    return ( $major, $minor );\n  \n  ## -}\n  \n  sub update_fp {\n     my (@args) = @_;\n-    my $fp = get_fp();\n-    my ( $major, $minor, $patch ) = get_version();\n-    my ( $bc_major, $bc_minor ) = get_bc_version();\n-    my $fp = Parrot::BuildUtil::generate_pbc_fingerprint();\n-    my $fp_len = length $fp;\n-    my ( $major, $minor, $patch ) = Parrot::BuildUtil::parrot_version();\n-    my ( $bc_major, $bc_minor ) = Parrot::BuildUtil::get_bc_version();\n   for my $f (@args) {\n       my $b;\n       open my $F, \"+\u003c\", \"$f\" or die \"Can't open $f: $!\";\n  @@ -104,12 +65,12 @@\n       # uuid_type = 1, uuid_size = 10, uuid_data = $fp\n       read $F, $b, 8;\n       my ($type, $uuid_len) = unpack \"cc\", $b;\n-        if ($type != 1 or $uuid_len != FP_LEN) {\n-        if ($type != 1 or $uuid_len != $fp_len) {\n           # if uuid_type was 0 or of different size copy the tail first\n           my $leftover = (18 + $uuid_len) % 16;\n           my $n = $leftover == 0 ? 0 : 16 - $leftover;\n-            # we can skip the copy if there's enough room already (pad:14=\u003e2)\n-            goto SEEK if $n \u003c FP_LEN;\n-            # we can skip the copy if there's enough room already (pad: 14=\u003e2)\n-            goto SEEK if $n \u003e $fp_len;\n           my $dirstart = 18 + $uuid_len + $n;\n           seek $F, $dirstart, 0;   # skip to dir\n           my $size = -s $F;\n  @@ -119,7 +80,7 @@\n       }\n     SEEK:\n       seek $F, 16, 0;   # back to pos 16: uuid_type, uuid_size\n-        print $F pack \"cc\", 1, FP_LEN;\n- ```\n     print $F pack \"cc\", 1, $fp_len;\n   print $F $fp;\n   close $F;\n  ```\n  \n   }\n  \n  # Index: parrot-svn/config/gen/config_h/config_h.in\n  \n  --- parrot-svn.orig/config/gen/config_h/config_h.in 2009-02-20 14:27:44.000000000 +0000\n  +++ parrot-svn/config/gen/config_h/config_h.in  2009-02-20 14:28:28.015875000 +0000\n  @@ -94,6 +94,7 @@\n  #define PARROT_BYTEORDER        0x@byteorder@\n  #define PARROT_BIGENDIAN        @bigendian@\n  #define PARROT_PTR_ALIGNMENT    @ptr_alignment@\n  +#define PARROT_PBC_UUID         \"@pbc_uuid@\"\n  \n  #define PARROT_LITTLEENDIAN    !(PARROT_BIGENDIAN)\n\n# Index: parrot-svn/src/packfile.c\n\n--- parrot-svn.orig/src/packfile.c  2009-02-20 14:27:44.000000000 +0000\n+++ parrot-svn/src/packfile.c   2009-02-20 14:49:27.969000000 +0000\n@@ -981,22 +981,22 @@\n                           : FLOATTYPE_12_NAME));\n     TRACE_PRINTF((\"PackFile_unpack: Byteorder %d (%sendian).\\n\",\n\n##                    header-\u003ebyteorder, header-\u003ebyteorder ? \"big \" : \"little-\"));\n-    TRACE_PRINTF((\"PackFile_unpack: uuid_type=%d\\n\", header-\u003euuid_type));\n-    TRACE_PRINTF((\"PackFile_unpack: uuid_size=%d\\n\", header-\u003euuid_size));\n   /\\* Check the UUID type is valid and, if needed, read a UUID. _/\n   if (header-\u003euuid_type == 0) {\n       /_ No UUID; fine, nothing more to do. _/\n   }\n   else if (header-\u003euuid_type == 1) {\n       /_ Read in the UUID. We'll put it in a NULL-terminated string, just in\n-         \\* case pepole use it that way. */\n- ```\n      * case people use it that way. */\n   header-\u003euuid_data = (unsigned char *)\n       mem_sys_allocate(header-\u003euuid_size + 1);\n  ```\n- ```\n     memcpy(header-\u003euuid_data, packed + PACKFILE_HEADER_BYTES,\n  ```\n\n## \\-            header-\u003euuid_size);\n-        memcpy(header-\u003euuid_data, PARROT_PBC_UUID, header-\u003euuid_size);\n       /\\* NULL terminate */\n       header-\u003euuid_data[header-\u003euuid_size] = 0;\n-        TRACE_PRINTF((\"PackFile_unpack: uuid_data='%s'\\n\", header-\u003euuid_data));\n   }\n   else\n       /\\* Don't know this UUID type. */\n  @@ -1009,6 +1009,8 @@\n   header_read_length += header_read_length % 16 ?\n       16 - header_read_length % 16 : 0;\n   cursor              = packed + (header_read_length / sizeof (opcode_t));\n-    TRACE_PRINTF((\"PackFile_unpack: pad=%d\\n\",\n- ```\n               cursor - packed));\n  ```\n  \n   /\\* Set what transforms we need to do when reading the rest of the file. */\n   PackFile_assign_transforms(self);\n  @@ -1244,6 +1246,14 @@\n  \n  # endif\n  \n  # endif\n  \n  #endif\n-    if (strlen(PARROT_PBC_UUID)) {\n-        header-\u003euuid_type = 1;\n-        header-\u003euuid_size = strlen(PARROT_PBC_UUID);\n-        header-\u003euuid_data = (unsigned char *)mem_sys_allocate(header-\u003euuid_size + 1);\n-        memcpy(header-\u003euuid_data, PARROT_PBC_UUID, header-\u003euuid_size);\n-        /\\* NULL terminate */\n-        header-\u003euuid_data[header-\u003euuid_size] = 0;\n-    }\n  }\n\n@@ -3482,7 +3492,7 @@\n     ep-\u003etype = type;\n     ep-\u003ename = name;\n-    if (PackFile_map_segments(interp, dir, find_fixup_iter, (void *) ep));\n-    if (PackFile_map_segments(interp, dir, find_fixup_iter, (void *) ep))\n       return ep;\n  \n   return NULL;\n  \n  # Index: parrot-svn/Configure.pl\n  \n  --- parrot-svn.orig/Configure.pl    2009-02-20 14:27:44.000000000 +0000\n  +++ parrot-svn/Configure.pl 2009-02-20 14:28:28.031500000 +0000\n  @@ -64,8 +64,9 @@\n  \n  # from Parrot::Configure::Data\n  \n  $conf-\u003eoptions-\u003eset( %{$args} );\n  \n  # save the command-line for make reconfig\n  \n  -$conf-\u003edata-\u003eset(configure_args =\u003e @ARGV ? '\"'.join(\"\\\" \\\"\", map {qq($_)} @ARGV).'\"'\n-                                         : '');\n  +$conf-\u003edata-\u003eset(configure_args =\u003e\n-                 @ARGV ? '\"'.join(\"\\\" \\\"\", map {qq($_)} @ARGV).'\"'\n- ```\n                    : '');\n  ```\n  \n  # Log files created by Configure.pl in MANIFEST.configure.generated\n  \n  $conf-\u003e{active_configuration} = 1;\n  \n  # Index: parrot-svn/config/auto/pmc.pm\n  \n  --- parrot-svn.orig/config/auto/pmc.pm  2009-02-20 14:27:44.000000000 +0000\n  +++ parrot-svn/config/auto/pmc.pm   2009-02-20 14:39:47.672125000 +0000\n  @@ -9,6 +9,9 @@\n  \n  Asks the user to select which PMC files to include.\n\n+Generate a specific UUID for this selection then,\n+for the default use the md5 of PBC_COMPAT.\n+\n =cut\n\n package auto::pmc;\n@@ -22,6 +25,7 @@\n use File::Spec::Functions qw/catfile/;\n\n use Parrot::Configure::Utils ':auto';\n+use Parrot::BuildUtil;\n\n sub _init {\n     my $self = shift;\n@@ -168,9 +172,29 @@\n\n```\n my @names = $self-\u003eorder_pmcs_by_hierarchy( \\%parents );\n```\n-    # Generate a specific UUID for user-defined pmc's and ops\n-    # auto::ops runs before auto::pmc, so do it here.\n-    my $pbc_uuid = '';\n-    if ($conf-\u003eoptions-\u003eget('pmc') or $conf-\u003eoptions-\u003eget('ops')) {\n-        unless (eval { require Digest::MD5; }) {\n-            warn \"Digest::MD5 not found. Skipping fingerprint\";\n-        }\n-        else {\n-            my ( $major, $minor ) = Parrot::BuildUtil::get_bc_version();\n-            my @sources = (@names, $major, $minor);\n-            my $ops = $conf-\u003edata-\u003eget( 'ops' );\n-            push @sources, $ops if $ops;\n-            $pbc_uuid = Parrot::BuildUtil::generate_pbc_fingerprint(@sources);\n-        }\n-    }\n-    else { # use the default UUID. This requires PBC_COMPAT discipline\n-        $pbc_uuid = Parrot::BuildUtil::generate_pbc_fingerprint();\n-    }\n  +\n   $conf-\u003edata-\u003eset(\n       pmc                  =\u003e $pmc_list,\n       pmc_names            =\u003e join( ' ', @names ),\n-        pbc_uuid             =\u003e $pbc_uuid,\n       TEMP_pmc_o           =\u003e $TEMP_pmc_o,\n       TEMP_pmc_build       =\u003e $TEMP_pmc_build,\n       TEMP_pmc_classes_o   =\u003e $TEMP_pmc_classes_o,\n  Index: parrot-svn/tools/build/pbcversion_h.pl\n  ===================================================================\n  --- parrot-svn.orig/tools/build/pbcversion_h.pl 2009-02-20 14:27:44.000000000 +0000\n  +++ parrot-svn/tools/build/pbcversion_h.pl  2009-02-20 14:28:28.031500000 +0000\n  @@ -21,28 +21,15 @@\n  use warnings;\n  use strict;\n  use lib 'lib';\n  +use Parrot::BuildUtil;\n\n## -my ( $major, $minor );\n\n-my $compat_file = 'PBC_COMPAT';\n-open my $IN, '\u003c', $compat_file or die \"Can't read $compat_file\";\n-while (\u003c$IN\u003e) {\n-    if (/^(\\d+).0*(\\d+)/) {\n-        ( $major, $minor ) = ( $1, $2 );\n-        last;\n-    }\n  -}\n  -close $IN;\n  -\n  -unless ( defined $major \u0026\u0026 defined $minor ) {\n-    die \"No bytecode version found in '$compat_file'.\";\n  -}\n  +my ( $major, $minor ) = Parrot::BuildUtil::get_bc_version();\n  \n  print \u003c\u003c \"EOF\";\n  /\\* ex: set ro:\n  - !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!\n    *\n- \\* This file is generated automatically from '$compat_file'\n- - This file is generated automatically from 'PBC_COMPAT'\n  - by $0.\n    *\n  - Any changes made here will be lost!\n    Index: parrot-svn/config/auto/ops.pm\n    ===================================================================\n    --- parrot-svn.orig/config/auto/ops.pm  2009-02-20 14:27:44.000000000 +0000\n    +++ parrot-svn/config/auto/ops.pm   2009-02-20 14:28:28.062750000 +0000\n    @@ -9,6 +9,8 @@\n  \n  Asks the user to select which ops files to include.\n\n+Generate a specific UUID for this selection in auto::pmc then.\n+\n =cut\n\n package auto::ops;\n\n```\n```","files":null},{"type":3,"author":{"id":"86141a663c2eb7543d1a51ec6253a1d54de912fd"},"timestamp":1235152036,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDMwMzE=","github-url":"https://github.com/parrot/parrot/issues/408#issuecomment-3503031"},"message":"\u003cp\u003e\nAttached is an actual proof-of-concept patch.\n\u003c/p\u003e\n\n\u003cp\u003e\nSample:\n\u003c/p\u003e\n\n\u003cpre class=\"wiki\"\u003econfig.h:\n#define PARROT_PBC_UUID         \"îø=êš„˜:ª\"\nconfig_lib.pasm:\n    set P0[\"pbc_uuid\"], \"îø=êš„˜:ª\"\n\u003c/pre\u003e\u003cul\u003e\u003cli\u003eNot binary safe? Or use md5_base64 with 22 bytes instead of 12. This requires a larger header. Currently we just the spare padding, which went from 14 to 2 bytes.\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e\n./miniparrot.exe config_lib.pasm \u0026gt; runtime/parrot/include/config.fpmc\u003cbr /\u003e\nMalformed string\n\u003c/p\u003e\n\n\u003cp\u003e\npbc_uuid is calculated in auto::pmc, after auto::ops,\nand incooporates on user-defined pmc and ops those,\nplus the bc_major, bc_minor from PBC_COMPAT.\n\u003c/p\u003e\n\n\u003cp\u003e\nWhat should else should be taken into the uuid?\nI just have the pmc and ops names plus bc version,\nbut in reality all the public interfaces are needed also.\n\u003c/p\u003e\n\n\u003cp\u003e\nTwo generic pbc functions are moved to Parrot::BuildUtil,\nget_bc_version() and generate_pbc_fingerprint(). This simplifies\ndev/pbc_header.pl and tools/build/pbcversion_h.pl.\n\u003c/p\u003e","files":null},{"type":3,"author":{"id":"86141a663c2eb7543d1a51ec6253a1d54de912fd"},"timestamp":1235152075,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDMwMzI=","github-url":"https://github.com/parrot/parrot/issues/408#issuecomment-3503032"},"message":"\u003cp\u003e\nmd5 not binary safe?\n\u003c/p\u003e","files":null},{"type":3,"author":{"id":"86141a663c2eb7543d1a51ec6253a1d54de912fd"},"timestamp":1235170288,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDMwMzM=","github-url":"https://github.com/parrot/parrot/issues/408#issuecomment-3503033"},"message":"\u003cp\u003e\nbinary safe 22 byte UUID (base_64)\n\u003c/p\u003e","files":null},{"type":3,"author":{"id":"86141a663c2eb7543d1a51ec6253a1d54de912fd"},"timestamp":1235325770,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDMwMzQ=","github-url":"https://github.com/parrot/parrot/issues/408#issuecomment-3503034"},"message":"\u003cp\u003e\nI have two questions and a proposal about our pbc policy, when we encounter a bc version mismatch and with this path a UUID mismatch.\n\u003c/p\u003e\n\n\u003cp\u003e\nProposal: use the Parrot_pbc_read() options to seperate parrot from the pbc_utils.\n\u003c/p\u003e\n\n\u003cul\u003e\u003cli\u003eparrot, pbc_to_exe and pbc_merge should fail with a \"Incompatible packfile\" error, when we know that it will fail: UUID and bc version mismatch. option=0\n\u003c/li\u003e\u003c/ul\u003e\u003cul\u003e\u003cli\u003ehowever, the other parrot_utils, pbc_dump, pbc_info, pbc_disassembler, parrot_debugger should only warn when reading old pbc's, esp. on a UUID mismatch.\noption=1\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e\nShould we be strict, as currently, or relaxed as promised as original pbc design goals? It was even designed to be more cross-version portable as I remember.\n\u003c/p\u003e\n\n\u003cp\u003e\nShould our deprecation policies handle this in the code? - change the uuid and bc version but keep portability for two releases.\n\u003c/p\u003e","files":null},{"type":3,"author":{"id":"86141a663c2eb7543d1a51ec6253a1d54de912fd"},"timestamp":1235530241,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDMwMzU=","github-url":"https://github.com/parrot/parrot/issues/408#issuecomment-3503035"},"message":"\u003cp\u003e\nWith the tt359-pbc_uuid.2.patch I misunderstood the original purpose of uuid.\nIt should be the md5 of the pbc which is created. I'll have to update this in a new patch.\n\u003c/p\u003e\n\n\u003cp\u003e\nHowever, we still have the open problem of cmdline configured sets --ops and --pmc. Should we handle this also with a custome UUID as I did in the patch above?\nOr get rid of this feature.\n\u003c/p\u003e","files":null}]}