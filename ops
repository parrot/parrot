{"version":1,"ops":[{"type":3,"author":{"id":"646f0669ead6eaf64196bebf3884a5eff162357a"},"timestamp":1302659784,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDI1Nzg=","github-url":"https://github.com/parrot/parrot/issues/275#issuecomment-3502578"},"message":"\u003cp\u003e\nMore than \"a leftover historical artifact\", I can't find any evidence that the \u003ctt\u003e:base_core\u003c/tt\u003e flag has ever done anything in the code.\n\u003c/p\u003e","files":null},{"type":3,"author":{"id":"c1086893059ddff06f8ec7681ac42d5c862a00e1"},"timestamp":1302822049,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDI1Nzk=","github-url":"https://github.com/parrot/parrot/issues/275#issuecomment-3502579"},"message":"46900 byte attachment from soh-cah-toa\nat http://trac.parrot.org/parrot/raw-attachment/ticket/2093/tt2093.patch\n\n```diff --git a/src/ops/bit.ops b/src/ops/bit.ops\nindex 24a63c5..c0c27ec 100644\n--- a/src/ops/bit.ops\n+++ b/src/ops/bit.ops\n@@ -52,11 +52,11 @@ from $2 and $3.\n\n =cut\n\n-inline op band(inout INT, in INT) :base_core {\n+inline op band(inout INT, in INT) {\n     $1 \u0026= $2;\n }\n\n-inline op band(out INT, in INT, in INT) :base_core {\n+inline op band(out INT, in INT, in INT) {\n     $1 = $2 \u0026 $3;\n }\n\n@@ -74,11 +74,11 @@ from $2 and $3.\n\n =cut\n\n-inline op bor(inout INT, in INT) :base_core {\n+inline op bor(inout INT, in INT) {\n     $1 |= $2;\n }\n\n-inline op bor(out INT, in INT, in INT) :base_core {\n+inline op bor(out INT, in INT, in INT) {\n     $1 = $2 | $3;\n }\n\n@@ -94,11 +94,11 @@ Set $1 to the value of $2 shifted left by $3 bits.\n\n =cut\n\n-inline op shl(inout INT, in INT) :base_core {\n+inline op shl(inout INT, in INT) {\n     $1 = bit_shift_left($1, $2);\n }\n\n-inline op shl(out INT, in INT, in INT) :base_core {\n+inline op shl(out INT, in INT, in INT) {\n     $1 = bit_shift_left($2, $3);\n }\n\n@@ -114,12 +114,12 @@ Set $1 to the value of $2 shifted right by $3 bits.\n\n =cut\n\n-inline op shr(inout INT, in INT) :base_core {\n+inline op shr(inout INT, in INT) {\n     const INTVAL signed_shift = -$2;\n     $1 = bit_shift_left($1, signed_shift);\n }\n\n-inline op shr(out INT, in INT, in INT) :base_core {\n+inline op shr(out INT, in INT, in INT) {\n     const INTVAL signed_shift = -$3;\n     $1 = bit_shift_left($2, signed_shift);\n }\n@@ -136,13 +136,13 @@ Set $1 to the value of $2 logically shifted right by $3 bits.\n\n =cut\n\n-inline op lsr(out INT, in INT) :base_core {\n+inline op lsr(out INT, in INT) {\n     const UINTVAL a = (UINTVAL)$1;\n     const UINTVAL b = a \u003e\u003e $2;\n     $1 = (INTVAL)b;\n }\n\n-inline op lsr(out INT, in INT, in INT) :base_core {\n+inline op lsr(out INT, in INT, in INT) {\n     $1 = (INTVAL)((UINTVAL)$2 \u003e\u003e $3);\n }\n\n@@ -160,11 +160,11 @@ from $2 and $3.\n\n =cut\n\n-inline op bxor(inout INT, in INT) :base_core {\n+inline op bxor(inout INT, in INT) {\n     $1 ^= $2;\n }\n\n-inline op bxor(out INT, in INT, in INT) :base_core {\n+inline op bxor(out INT, in INT, in INT) {\n     $1 = $2 ^ $3;\n }\n\ndiff --git a/src/ops/cmp.ops b/src/ops/cmp.ops\nindex 7702267..7638f7c 100644\n--- a/src/ops/cmp.ops\n+++ b/src/ops/cmp.ops\n@@ -64,31 +64,31 @@ B\u003ceq_addr\u003e compares the address of the objects or strings.\n\n =cut\n\n-inline op eq(in INT, in INT, inconst LABEL) :base_core {\n+inline op eq(in INT, in INT, inconst LABEL) {\n     if ($1 == $2) {\n         goto OFFSET($3);\n     }\n }\n\n-inline op eq(in NUM, in NUM, inconst LABEL) :base_core {\n+inline op eq(in NUM, in NUM, inconst LABEL) {\n     if ($1 == $2) {\n         goto OFFSET($3);\n     }\n }\n\n-op eq(in STR, in STR, inconst LABEL) :base_core {\n+op eq(in STR, in STR, inconst LABEL) {\n     if (STRING_equal(interp, $1, $2)) {\n         goto OFFSET($3);\n     }\n }\n\n-op eq(invar PMC, invar PMC, inconst LABEL) :base_core {\n+op eq(invar PMC, invar PMC, inconst LABEL) {\n     if (VTABLE_is_equal(interp, $1, $2)) {\n         goto OFFSET($3);\n     }\n }\n\n-op eq(invar PMC, in INT, inconst LABEL) :base_core {\n+op eq(invar PMC, in INT, inconst LABEL) {\n     PMC \\* const temp = Parrot_pmc_new_temporary(interp, enum_class_Integer);\n     VTABLE_set_integer_native(interp, temp, $2);\n\n@@ -100,7 +100,7 @@ op eq(invar PMC, in INT, inconst LABEL) :base_core {\n     Parrot_pmc_free_temporary(interp, temp);\n }\n\n-op eq(invar PMC, in NUM, inconst LABEL) :base_core {\n+op eq(invar PMC, in NUM, inconst LABEL) {\n     /*\n      \\* the get_number and get_string should probably\n      \\* be also replaced with code like above, as\n@@ -112,31 +112,31 @@ op eq(invar PMC, in NUM, inconst LABEL) :base_core {\n     }\n }\n\n-op eq(invar PMC, in STR, inconst LABEL) :base_core {\n+op eq(invar PMC, in STR, inconst LABEL) {\n     if (STRING_equal(interp, VTABLE_get_string(interp, $1), $2)) {\n         goto OFFSET($3);\n     }\n }\n\n-op eq_str(invar PMC, invar PMC, inconst LABEL) :base_core {\n+op eq_str(invar PMC, invar PMC, inconst LABEL) {\n     if (VTABLE_is_equal_string(interp, $1, $2)) {\n         goto OFFSET($3);\n     }\n }\n\n-op eq_num(invar PMC, invar PMC, inconst LABEL) :base_core {\n+op eq_num(invar PMC, invar PMC, inconst LABEL) {\n     if (VTABLE_is_equal_num(interp, $1, $2)) {\n         goto OFFSET($3);\n     }\n }\n\n-op eq_addr(in STR, in STR, inconst LABEL) :base_core {\n+op eq_addr(in STR, in STR, inconst LABEL) {\n     if ($1 == $2) {\n         goto OFFSET($3);\n     }\n }\n\n-op eq_addr(invar PMC, invar PMC, inconst LABEL) :base_core {\n+op eq_addr(invar PMC, invar PMC, inconst LABEL) {\n     if ($1 == $2) {\n         goto OFFSET($3);\n     }\n@@ -170,31 +170,31 @@ Branch if $1 is not equal to $2.\n\n =cut\n\n-inline op ne(in INT, in INT, inconst LABEL) :base_core {\n+inline op ne(in INT, in INT, inconst LABEL) {\n     if ($1 != $2) {\n         goto OFFSET($3);\n     }\n }\n\n-inline op ne(in NUM, in NUM, inconst LABEL) :base_core {\n+inline op ne(in NUM, in NUM, inconst LABEL) {\n     if ($1 != $2) {\n         goto OFFSET($3);\n     }\n }\n\n-op ne(in STR, in STR, inconst LABEL) :base_core {\n+op ne(in STR, in STR, inconst LABEL) {\n     if (!STRING_equal(interp, $1, $2)) {\n         goto OFFSET($3);\n     }\n }\n\n-op ne(invar PMC, invar PMC, inconst LABEL) :base_core {\n+op ne(invar PMC, invar PMC, inconst LABEL) {\n     if (!VTABLE_is_equal(interp, $1, $2)) {\n         goto OFFSET($3);\n     }\n }\n\n-op ne(invar PMC, in INT, inconst LABEL) :base_core {\n+op ne(invar PMC, in INT, inconst LABEL) {\n     PMC \\* const temp = Parrot_pmc_new_temporary(interp, enum_class_Integer);\n     VTABLE_set_integer_native(interp, temp, $2);\n\n@@ -206,37 +206,37 @@ op ne(invar PMC, in INT, inconst LABEL) :base_core {\n     Parrot_pmc_free_temporary(interp, temp);\n }\n\n-op ne(invar PMC, in NUM, inconst LABEL) :base_core {\n+op ne(invar PMC, in NUM, inconst LABEL) {\n     if (VTABLE_get_number(interp, $1) != $2) {\n         goto OFFSET($3);\n     }\n }\n\n-op ne(invar PMC, in STR, inconst LABEL) :base_core {\n+op ne(invar PMC, in STR, inconst LABEL) {\n     if (!STRING_equal(interp, VTABLE_get_string(interp, $1), $2)) {\n         goto OFFSET($3);\n     }\n }\n\n-op ne_str(invar PMC, invar PMC, inconst LABEL) :base_core {\n+op ne_str(invar PMC, invar PMC, inconst LABEL) {\n     if (VTABLE_cmp_string(interp, $1, $2) != 0) {\n         goto OFFSET($3);\n     }\n }\n\n-op ne_num(invar PMC, invar PMC, inconst LABEL) :base_core {\n+op ne_num(invar PMC, invar PMC, inconst LABEL) {\n     if (VTABLE_cmp_num(interp, $1, $2) != 0) {\n         goto OFFSET($3);\n     }\n }\n\n-op ne_addr(in STR, in STR, inconst LABEL) :base_core {\n+op ne_addr(in STR, in STR, inconst LABEL) {\n     if ($1 != $2) {\n         goto OFFSET($3);\n     }\n }\n\n-op ne_addr(invar PMC, invar PMC, inconst LABEL) :base_core {\n+op ne_addr(invar PMC, invar PMC, inconst LABEL) {\n     if ($1 != $2) {\n         goto OFFSET($3);\n     }\n@@ -266,31 +266,31 @@ Branch if $1 is less than $2.\n\n =cut\n\n-inline op lt(in INT, in INT, inconst LABEL) :base_core {\n+inline op lt(in INT, in INT, inconst LABEL) {\n     if ($1 \u003c $2) {\n         goto OFFSET($3);\n     }\n }\n\n-inline op lt(in NUM, in NUM, inconst LABEL) :base_core {\n+inline op lt(in NUM, in NUM, inconst LABEL) {\n     if ($1 \u003c $2) {\n         goto OFFSET($3);\n     }\n }\n\n-op lt(in STR, in STR, inconst LABEL) :base_core {\n+op lt(in STR, in STR, inconst LABEL) {\n     if (STRING_compare(interp, $1, $2) \u003c 0) {\n         goto OFFSET($3);\n     }\n }\n\n-op lt(invar PMC, invar PMC, inconst LABEL) :base_core {\n+op lt(invar PMC, invar PMC, inconst LABEL) {\n     if (VTABLE_cmp(interp, $1, $2) \u003c 0) {\n         goto OFFSET($3);\n     }\n }\n\n-op lt(invar PMC, in INT, inconst LABEL) :base_core {\n+op lt(invar PMC, in INT, inconst LABEL) {\n     PMC \\* const temp = Parrot_pmc_new_temporary(interp, enum_class_Integer);\n     VTABLE_set_integer_native(interp, temp, $2);\n\n@@ -302,25 +302,25 @@ op lt(invar PMC, in INT, inconst LABEL) :base_core {\n     Parrot_pmc_free_temporary(interp, temp);\n }\n\n-op lt(invar PMC, in NUM, inconst LABEL) :base_core {\n+op lt(invar PMC, in NUM, inconst LABEL) {\n     if (VTABLE_get_number(interp, $1) \u003c $2) {\n         goto OFFSET($3);\n     }\n }\n\n-op lt(invar PMC, in STR, inconst LABEL) :base_core {\n+op lt(invar PMC, in STR, inconst LABEL) {\n     if (STRING_compare(interp, VTABLE_get_string(interp, $1), $2) \u003c 0) {\n         goto OFFSET($3);\n     }\n }\n\n-op lt_str(invar PMC, invar PMC, inconst LABEL) :base_core {\n+op lt_str(invar PMC, invar PMC, inconst LABEL) {\n     if (VTABLE_cmp_string(interp, $1, $2) \u003c 0) {\n         goto OFFSET($3);\n     }\n }\n\n-op lt_num(invar PMC, invar PMC, inconst LABEL) :base_core {\n+op lt_num(invar PMC, invar PMC, inconst LABEL) {\n     if (VTABLE_cmp_num(interp, $1, $2) \u003c 0) {\n         goto OFFSET($3);\n     }\n@@ -350,31 +350,31 @@ Branch if $1 is less than or equal to $2.\n\n =cut\n\n-inline op le(in INT, in INT, inconst LABEL) :base_core {\n+inline op le(in INT, in INT, inconst LABEL) {\n     if ($1 \u003c= $2) {\n         goto OFFSET($3);\n     }\n }\n\n-inline op le(in NUM, in NUM, inconst LABEL) :base_core {\n+inline op le(in NUM, in NUM, inconst LABEL) {\n     if ($1 \u003c= $2) {\n         goto OFFSET($3);\n     }\n }\n\n-op le(in STR, in STR, inconst LABEL) :base_core {\n+op le(in STR, in STR, inconst LABEL) {\n     if (STRING_compare(interp, $1, $2) \u003c= 0) {\n         goto OFFSET($3);\n     }\n }\n\n-op le(invar PMC, invar PMC, inconst LABEL) :base_core {\n+op le(invar PMC, invar PMC, inconst LABEL) {\n     if (VTABLE_cmp(interp, $1, $2) \u003c= 0) {\n         goto OFFSET($3);\n     }\n }\n\n-op le(invar PMC, in INT, inconst LABEL) :base_core {\n+op le(invar PMC, in INT, inconst LABEL) {\n     PMC \\* const temp = Parrot_pmc_new_temporary(interp, enum_class_Integer);\n     VTABLE_set_integer_native(interp, temp, $2);\n\n@@ -386,25 +386,25 @@ op le(invar PMC, in INT, inconst LABEL) :base_core {\n     Parrot_pmc_free_temporary(interp, temp);\n }\n\n-op le(invar PMC, in NUM, inconst LABEL) :base_core {\n+op le(invar PMC, in NUM, inconst LABEL) {\n     if (VTABLE_get_number(interp, $1) \u003c= $2) {\n         goto OFFSET($3);\n     }\n }\n\n-op le(invar PMC, in STR, inconst LABEL) :base_core {\n+op le(invar PMC, in STR, inconst LABEL) {\n     if (STRING_compare(interp, VTABLE_get_string(interp, $1), $2) \u003c= 0) {\n         goto OFFSET($3);\n     }\n }\n\n-op le_str(invar PMC, invar PMC, inconst LABEL) :base_core {\n+op le_str(invar PMC, invar PMC, inconst LABEL) {\n     if (VTABLE_cmp_string(interp, $1, $2) \u003c= 0) {\n         goto OFFSET($3);\n     }\n }\n\n-op le_num(invar PMC, invar PMC, inconst LABEL) :base_core {\n+op le_num(invar PMC, invar PMC, inconst LABEL) {\n     if (VTABLE_cmp_num(interp, $1, $2) \u003c= 0) {\n         goto OFFSET($3);\n     }\n@@ -428,13 +428,13 @@ Branch if $1 is greater than $2.\n\n =cut\n\n-op gt(invar PMC, invar PMC, inconst LABEL) :base_core {\n+op gt(invar PMC, invar PMC, inconst LABEL) {\n     if (VTABLE_cmp(interp, $1, $2) \u003e 0) {\n         goto OFFSET($3);\n     }\n }\n\n-op gt(invar PMC, in INT, inconst LABEL) :base_core {\n+op gt(invar PMC, in INT, inconst LABEL) {\n     PMC \\* const temp = Parrot_pmc_new_temporary(interp, enum_class_Integer);\n     VTABLE_set_integer_native(interp, temp, $2);\n\n@@ -446,25 +446,25 @@ op gt(invar PMC, in INT, inconst LABEL) :base_core {\n     Parrot_pmc_free_temporary(interp, temp);\n }\n\n-op gt(invar PMC, in NUM, inconst LABEL) :base_core {\n+op gt(invar PMC, in NUM, inconst LABEL) {\n     if (VTABLE_get_number(interp, $1) \u003e $2) {\n         goto OFFSET($3);\n     }\n }\n\n-op gt(invar PMC, in STR, inconst LABEL) :base_core {\n+op gt(invar PMC, in STR, inconst LABEL) {\n     if (STRING_compare(interp, VTABLE_get_string(interp, $1), $2) \u003e 0) {\n         goto OFFSET($3);\n     }\n }\n\n-op gt_str(invar PMC, invar PMC, inconst LABEL) :base_core {\n+op gt_str(invar PMC, invar PMC, inconst LABEL) {\n     if (VTABLE_cmp_string(interp, $1, $2) \u003e 0) {\n         goto OFFSET($3);\n     }\n }\n\n-op gt_num(invar PMC, invar PMC, inconst LABEL) :base_core {\n+op gt_num(invar PMC, invar PMC, inconst LABEL) {\n     if (VTABLE_cmp_num(interp, $1, $2) \u003e 0) {\n         goto OFFSET($3);\n     }\n@@ -488,13 +488,13 @@ Branch if $1 is greater than or equal to $2.\n\n =cut\n\n-op ge(invar PMC, invar PMC, inconst LABEL) :base_core {\n+op ge(invar PMC, invar PMC, inconst LABEL) {\n     if (VTABLE_cmp(interp, $1, $2) \u003e= 0) {\n         goto OFFSET($3);\n     }\n }\n\n-op ge(invar PMC, in INT, inconst LABEL) :base_core {\n+op ge(invar PMC, in INT, inconst LABEL) {\n     PMC \\* const temp = Parrot_pmc_new_temporary(interp, enum_class_Integer);\n     VTABLE_set_integer_native(interp, temp, $2);\n\n@@ -506,25 +506,25 @@ op ge(invar PMC, in INT, inconst LABEL) :base_core {\n     Parrot_pmc_free_temporary(interp, temp);\n }\n\n-op ge(invar PMC, in NUM, inconst LABEL) :base_core {\n+op ge(invar PMC, in NUM, inconst LABEL) {\n     if (VTABLE_get_number(interp, $1) \u003e= $2) {\n         goto OFFSET($3);\n     }\n }\n\n-op ge(invar PMC, in STR, inconst LABEL) :base_core {\n+op ge(invar PMC, in STR, inconst LABEL) {\n     if (STRING_compare(interp, VTABLE_get_string(interp, $1), $2) \u003e= 0) {\n         goto OFFSET($3);\n     }\n }\n\n-op ge_str(invar PMC, invar PMC, inconst LABEL) :base_core {\n+op ge_str(invar PMC, invar PMC, inconst LABEL) {\n     if (VTABLE_cmp_string(interp, $1, $2) \u003e= 0) {\n         goto OFFSET($3);\n     }\n }\n\n-op ge_num(invar PMC, invar PMC, inconst LABEL) :base_core {\n+op ge_num(invar PMC, invar PMC, inconst LABEL) {\n     if (VTABLE_cmp_num(interp, $1, $2) \u003e= 0) {\n         goto OFFSET($3);\n     }\n@@ -613,50 +613,50 @@ Sets $1 to -1 if $2 \u003c $3, +1 if $2 \u003e $3, and 0 otherwise.\n\n =cut\n\n-inline op cmp(out INT, in INT, in INT) :base_core {\n+inline op cmp(out INT, in INT, in INT) {\n     $1 = $2 \u003c $3 ? -1 :\n          $2 \u003e $3 ? +1 :\n          0;\n }\n\n-inline op cmp(out INT, in NUM, in NUM) :base_core {\n+inline op cmp(out INT, in NUM, in NUM) {\n     $1 = $2 \u003c $3 ? -1 :\n          $2 \u003e $3 ? +1 :\n          0;\n }\n\n-inline op cmp(out INT, in STR, in STR) :base_core {\n+inline op cmp(out INT, in STR, in STR) {\n     $1 = STRING_compare(interp, $2, $3);\n }\n\n-inline op cmp(out INT, invar PMC, invar PMC) :base_core {\n+inline op cmp(out INT, invar PMC, invar PMC) {\n     $1 = VTABLE_cmp(interp, $2, $3);\n }\n\n-inline op cmp(out INT, invar PMC, in INT) :base_core {\n+inline op cmp(out INT, invar PMC, in INT) {\n     const INTVAL l = VTABLE_get_integer(interp, $2);\n     $1 = l \u003c $3 ? -1 :\n          l \u003e $3 ? +1 :\n          0;\n }\n\n-inline op cmp(out INT, invar PMC, in NUM) :base_core {\n+inline op cmp(out INT, invar PMC, in NUM) {\n     const FLOATVAL l = VTABLE_get_number(interp, $2);\n     $1 = l \u003c $3 ? -1 :\n          l \u003e $3 ? +1 :\n          0;\n }\n\n-inline op cmp(out INT, invar PMC, in STR) :base_core {\n+inline op cmp(out INT, invar PMC, in STR) {\n     STRING\\* const l = VTABLE_get_string(interp, $2);\n     $1 = STRING_compare(interp, l, $3);\n }\n\n-inline op cmp_str(out INT, invar PMC, invar PMC) :base_core {\n+inline op cmp_str(out INT, invar PMC, invar PMC) {\n     $1 = VTABLE_cmp_string(interp, $2, $3);\n }\n\n-inline op cmp_num(out INT, invar PMC, invar PMC) :base_core {\n+inline op cmp_num(out INT, invar PMC, invar PMC) {\n     $1 = VTABLE_cmp_num(interp, $2, $3);\n }\n\n@@ -668,7 +668,7 @@ are not always comparable.\n\n =cut\n\n-inline op cmp_pmc(out PMC, invar PMC, invar PMC) :base_core {\n+inline op cmp_pmc(out PMC, invar PMC, invar PMC) {\n     $1 = VTABLE_cmp_pmc(interp, $2, $3);\n }\n\n@@ -922,11 +922,11 @@ Short-circuiting logical and.  Returns $2 if it's false, else returns $3.\n\n =cut\n\n-inline op and(out INT, in INT, in INT) :base_core {\n+inline op and(out INT, in INT, in INT) {\n     $1 = $2 ? $3 : $2;\n }\n\n-inline op and(invar PMC, invar PMC, invar PMC) :base_core {\n+inline op and(invar PMC, invar PMC, invar PMC) {\n     $1 = VTABLE_get_bool(interp, $2) ? $3 : $2;\n }\n\n@@ -944,19 +944,19 @@ Set the boolean state of $1 to the opposite of the boolean state from $1.\n\n =cut\n\n-inline op not(inout INT) :base_core {\n+inline op not(inout INT) {\n     $1 = ! $1;\n }\n\n-inline op not(out INT, in INT) :base_core {\n+inline op not(out INT, in INT) {\n     $1 = ! $2;\n }\n\n-inline op not(invar PMC) :base_core {\n+inline op not(invar PMC) {\n     VTABLE_set_bool(interp, $1, !VTABLE_get_bool(interp, $1));\n }\n\n-inline op not(out PMC, invar PMC) :base_core {\n+inline op not(out PMC, invar PMC) {\n     const INTVAL a = ! VTABLE_get_bool(interp, $2);\n     if (PMC_IS_NULL($1))\n         $1 = Parrot_pmc_new(interp, Parrot_hll_get_ctx_HLL_type(interp, enum_class_Boolean));\n@@ -973,11 +973,11 @@ Short-circuiting logical or.  Returns $2 if it's true, else returns $3.\n\n =cut\n\n-inline op or(out INT, in INT, in INT) :base_core {\n+inline op or(out INT, in INT, in INT) {\n     $1 = $2 ? $2 : $3;\n }\n\n-inline op or(invar PMC, invar PMC, invar PMC) :base_core {\n+inline op or(invar PMC, invar PMC, invar PMC) {\n     $1 = VTABLE_get_bool(interp, $2) ? $2 : $3;\n }\n\n@@ -992,11 +992,11 @@ returns $3 if it's true and $2 isn't, else returns false.\n\n =cut\n\n-inline op xor(out INT, in INT, in INT) :base_core {\n+inline op xor(out INT, in INT, in INT) {\n     $1 = ($2 \u0026\u0026 ! $3) ? $2 : ($3 \u0026\u0026 ! $2) ? $3 : 0;\n }\n\n-inline op xor(invar PMC, invar PMC, invar PMC) :base_core {\n+inline op xor(invar PMC, invar PMC, invar PMC) {\n     const INTVAL a = VTABLE_get_bool(interp, $2);\n     const INTVAL b = VTABLE_get_bool(interp, $3);\n     if (a \u0026\u0026 ! b)\ndiff --git a/src/ops/core.ops b/src/ops/core.ops\nindex 22c298f..27f268a 100644\n--- a/src/ops/core.ops\n+++ b/src/ops/core.ops\n@@ -54,7 +54,7 @@ Halts the interpreter. See also B\u003cexit\u003e.\n\n =cut\n\n-inline op end() :base_core :check_event :flow {\n+inline op end() :check_event :flow {\n     goto ADDRESS(0);\n }\n\n@@ -83,10 +83,10 @@ file.\n\n =cut\n\n-inline op noop() :base_core {\n+inline op noop() {\n }\n\n-inline op check_events() :base_core :flow {\n+inline op check_events() :flow {\n     opcode_t \\* const next = expr NEXT();\n     Parrot_cx_check_tasks(interp, interp-\u003escheduler);\n     goto ADDRESS(next);   /\\* force this being a branch op */\n@@ -151,7 +151,7 @@ the stack passed in $1 for later returning.\n\n =cut\n\n-inline op local_branch(invar PMC, in LABEL) :base_core :check_event :flow {\n+inline op local_branch(invar PMC, in LABEL) :check_event :flow {\n     INTVAL return_addr;\n     opcode_t \\* const dest = expr NEXT();\n\ndiff --git a/src/ops/experimental.ops b/src/ops/experimental.ops\nindex 88a7c89..be84031 100644\n--- a/src/ops/experimental.ops\n+++ b/src/ops/experimental.ops\n@@ -110,7 +110,7 @@ uses the type in $4 to create and return a new PMC.\n\n =cut\n\n-inline op fetch(out PMC, in PMC, in PMC, in PMC) :base_core {\n+inline op fetch(out PMC, in PMC, in PMC, in PMC) {\n     $1 = VTABLE_get_pmc_keyed(interp, $2, $3);\n\n```\n if (PMC_IS_NULL($1)) {\n```\n\n@@ -118,7 +118,7 @@ inline op fetch(out PMC, in PMC, in PMC, in PMC) :base_core {\n     }\n }\n\n-inline op fetch(out PMC, in PMC, in INT, in PMC) :base_core {\n+inline op fetch(out PMC, in PMC, in INT, in PMC) {\n     $1 = VTABLE_get_pmc_keyed_int(interp, $2, $3);\n\n```\n if (PMC_IS_NULL($1)) {\n```\n\n@@ -126,7 +126,7 @@ inline op fetch(out PMC, in PMC, in INT, in PMC) :base_core {\n     }\n }\n\n-inline op fetch(out PMC, in PMC, in STR, in PMC) :base_core {\n+inline op fetch(out PMC, in PMC, in STR, in PMC) {\n     $1 = VTABLE_get_pmc_keyed_str(interp, $2, $3);\n\n```\n if (PMC_IS_NULL($1)) {\n```\n\n@@ -145,7 +145,7 @@ uses the type in $4 to create and return a new PMC.\n\n =cut\n\n-inline op vivify(out PMC, in PMC, in PMC, in PMC) :base_core {\n+inline op vivify(out PMC, in PMC, in PMC, in PMC) {\n     $1 = VTABLE_get_pmc_keyed(interp, $2, $3);\n\n```\n if (PMC_IS_NULL($1)) {\n```\n\n@@ -155,7 +155,7 @@ inline op vivify(out PMC, in PMC, in PMC, in PMC) :base_core {\n     }\n }\n\n-inline op vivify(out PMC, in PMC, in INT, in PMC) :base_core {\n+inline op vivify(out PMC, in PMC, in INT, in PMC) {\n     $1 = VTABLE_get_pmc_keyed_int(interp, $2, $3);\n\n```\n if (PMC_IS_NULL($1)) {\n```\n\n@@ -165,7 +165,7 @@ inline op vivify(out PMC, in PMC, in INT, in PMC) :base_core {\n     }\n }\n\n-inline op vivify(out PMC, in PMC, in STR, in PMC) :base_core {\n+inline op vivify(out PMC, in PMC, in STR, in PMC) {\n     $1 = VTABLE_get_pmc_keyed_str(interp, $2, $3);\n\n```\n if (PMC_IS_NULL($1)) {\n```\n\ndiff --git a/src/ops/math.ops b/src/ops/math.ops\nindex 1a0825c..6bdadfa 100644\n--- a/src/ops/math.ops\n+++ b/src/ops/math.ops\n@@ -45,27 +45,27 @@ Set $1 to absolute value of $2.\n\n =cut\n\n-inline op abs(inout INT) :base_core {\n+inline op abs(inout INT) {\n     $1 = abs($1);\n }\n\n-inline op abs(inout NUM) :base_core {\n+inline op abs(inout NUM) {\n     $1 = fabs($1);\n }\n\n-inline op abs(out INT, in INT) :base_core {\n+inline op abs(out INT, in INT) {\n     $1 = abs($2);\n }\n\n-inline op abs(out NUM, in NUM) :base_core {\n+inline op abs(out NUM, in NUM) {\n     $1 = fabs($2);\n }\n\n-inline op abs(invar PMC) :base_core {\n+inline op abs(invar PMC) {\n     VTABLE_i_absolute(interp, $1);\n }\n\n-inline op abs(out PMC, invar PMC) :base_core {\n+inline op abs(out PMC, invar PMC) {\n     $1 = VTABLE_absolute(interp, $2, $1);\n }\n\n@@ -97,43 +97,43 @@ Set $1 to the sum of $2 and $3.\n\n =cut\n\n-inline op add(inout INT, in INT) :base_core {\n+inline op add(inout INT, in INT) {\n     $1 += $2;\n }\n\n-inline op add(inout NUM, in NUM) :base_core {\n+inline op add(inout NUM, in NUM) {\n     $1 += $2;\n }\n\n-inline op add(invar PMC, invar PMC) :base_core {\n+inline op add(invar PMC, invar PMC) {\n     VTABLE_i_add(interp, $1, $2);\n }\n\n-inline op add(invar PMC, in INT) :base_core {\n+inline op add(invar PMC, in INT) {\n     VTABLE_i_add_int(interp, $1, $2);\n }\n\n-inline op add(invar PMC, in NUM) :base_core {\n+inline op add(invar PMC, in NUM) {\n     VTABLE_i_add_float(interp, $1, $2);\n }\n\n-inline op add(out INT, in INT, in INT) :base_core {\n+inline op add(out INT, in INT, in INT) {\n     $1 = $2 + $3;\n }\n\n-inline op add(out NUM, in NUM, in NUM) :base_core {\n+inline op add(out NUM, in NUM, in NUM) {\n     $1 = $2 + $3;\n }\n\n-inline op add(invar PMC, invar PMC, invar PMC) :base_core {\n+inline op add(invar PMC, invar PMC, invar PMC) {\n     $1 = VTABLE_add(interp, $2, $3, $1);\n }\n\n-inline op add(invar PMC, invar PMC, in INT) :base_core {\n+inline op add(invar PMC, invar PMC, in INT) {\n     $1 = VTABLE_add_int(interp, $2, $3, $1);\n }\n\n-inline op add(invar PMC, invar PMC, in NUM) :base_core {\n+inline op add(invar PMC, invar PMC, in NUM) {\n     $1 = VTABLE_add_float(interp, $2, $3, $1);\n }\n\n@@ -149,15 +149,15 @@ Decrease $1 by one.\n\n =cut\n\n-inline op dec(inout INT) :base_core {\n+inline op dec(inout INT) {\n     $1--;\n }\n\n-inline op dec(inout NUM) :base_core {\n+inline op dec(inout NUM) {\n     $1--;\n }\n\n-inline op dec(invar PMC) :base_core {\n+inline op dec(invar PMC) {\n     VTABLE_decrement(interp, $1);\n }\n\n@@ -191,7 +191,7 @@ If the denominator is zero, a 'Divide by zero' exception is thrown.\n\n =cut\n\n-inline op div(inout INT, in INT) :base_core {\n+inline op div(inout INT, in INT) {\n     const INTVAL den = $2;\n     if (den == 0) {\n         opcode_t \\* const handler = Parrot_ex_throw_from_op_args(interp, expr NEXT(),\n@@ -202,7 +202,7 @@ inline op div(inout INT, in INT) :base_core {\n     $1 /= den;\n }\n\n-inline op div(inout NUM, in NUM) :base_core {\n+inline op div(inout NUM, in NUM) {\n     const FLOATVAL den = $2;\n     if (FLOAT_IS_ZERO(den)) {\n         opcode_t \\* const handler = Parrot_ex_throw_from_op_args(interp, expr NEXT(),\n@@ -213,18 +213,18 @@ inline op div(inout NUM, in NUM) :base_core {\n     $1 /= den;\n }\n\n-inline op div(invar PMC, invar PMC) :base_core {\n+inline op div(invar PMC, invar PMC) {\n     VTABLE_i_divide(interp, $1, $2);\n }\n\n-inline op div(invar PMC, in INT) :base_core {\n+inline op div(invar PMC, in INT) {\n     VTABLE_i_divide_int(interp, $1, $2);\n }\n\n-inline op div(invar PMC, in NUM) :base_core {\n+inline op div(invar PMC, in NUM) {\n     VTABLE_i_divide_float(interp, $1, $2);\n }\n-inline op div(out INT, in INT, in INT) :base_core {\n+inline op div(out INT, in INT, in INT) {\n     const INTVAL den = $3;\n     if (den == 0) {\n         opcode_t \\* const handler = Parrot_ex_throw_from_op_args(interp, expr NEXT(),\n@@ -235,7 +235,7 @@ inline op div(out INT, in INT, in INT) :base_core {\n     $1 = $2 / den;\n }\n\n-inline op div(out NUM, in NUM, in NUM) :base_core {\n+inline op div(out NUM, in NUM, in NUM) {\n     const FLOATVAL den = $3;\n     if (FLOAT_IS_ZERO(den)) {\n         opcode_t \\* const handler = Parrot_ex_throw_from_op_args(interp, expr NEXT(),\n@@ -246,15 +246,15 @@ inline op div(out NUM, in NUM, in NUM) :base_core {\n     $1 = $2 / den;\n }\n\n-inline op div(invar PMC, invar PMC, invar PMC) :base_core {\n+inline op div(invar PMC, invar PMC, invar PMC) {\n     $1 = VTABLE_divide(interp, $2, $3, $1);\n }\n\n-inline op div(invar PMC, invar PMC, in INT) :base_core {\n+inline op div(invar PMC, invar PMC, in INT) {\n     $1 = VTABLE_divide_int(interp, $2, $3, $1);\n }\n\n-inline op div(invar PMC, invar PMC, in NUM) :base_core {\n+inline op div(invar PMC, invar PMC, in NUM) {\n     $1 = VTABLE_divide_float(interp, $2, $3, $1);\n }\n\n@@ -287,7 +287,7 @@ If the denominator is zero, a 'Divide by zero' exception is thrown.\n\n =cut\n\n-inline op fdiv(inout INT, in INT) :base_core {\n+inline op fdiv(inout INT, in INT) {\n     const INTVAL den = $2;\n     FLOATVAL f;\n\n@@ -302,7 +302,7 @@ inline op fdiv(inout INT, in INT) :base_core {\n     $1 = (INTVAL)f;\n }\n\n-inline op fdiv(inout NUM, in NUM) :base_core {\n+inline op fdiv(inout NUM, in NUM) {\n     const FLOATVAL den = $2;\n\n```\n if (FLOAT_IS_ZERO(den)) {\n```\n\n@@ -314,19 +314,19 @@ inline op fdiv(inout NUM, in NUM) :base_core {\n     $1 = floor($1 / den);\n }\n\n-inline op fdiv(invar PMC, invar PMC) :base_core {\n+inline op fdiv(invar PMC, invar PMC) {\n     VTABLE_i_floor_divide(interp, $1, $2);\n }\n\n-inline op fdiv(invar PMC, in INT) :base_core {\n+inline op fdiv(invar PMC, in INT) {\n     VTABLE_i_floor_divide_int(interp, $1, $2);\n }\n\n-inline op fdiv(invar PMC, in NUM) :base_core {\n+inline op fdiv(invar PMC, in NUM) {\n     VTABLE_i_floor_divide_float(interp, $1, $2);\n }\n\n-inline op fdiv(out INT, in INT, in INT) :base_core {\n+inline op fdiv(out INT, in INT, in INT) {\n     const INTVAL den = $3;\n     FLOATVAL f;\n\n@@ -341,7 +341,7 @@ inline op fdiv(out INT, in INT, in INT) :base_core {\n     $1 = (INTVAL)f;\n }\n\n-inline op fdiv(out NUM, in NUM, in NUM) :base_core {\n+inline op fdiv(out NUM, in NUM, in NUM) {\n     FLOATVAL den = $3;\n     if (FLOAT_IS_ZERO(den)) {\n         opcode_t \\* const handler = Parrot_ex_throw_from_op_args(interp, expr NEXT(),\n@@ -352,15 +352,15 @@ inline op fdiv(out NUM, in NUM, in NUM) :base_core {\n     $1 = floor($2 / den);\n }\n\n-inline op fdiv(invar PMC, invar PMC, invar PMC) :base_core {\n+inline op fdiv(invar PMC, invar PMC, invar PMC) {\n     $1 = VTABLE_floor_divide(interp, $2, $3, $1);\n }\n\n-inline op fdiv(invar PMC, invar PMC, in INT) :base_core {\n+inline op fdiv(invar PMC, invar PMC, in INT) {\n     $1 = VTABLE_floor_divide_int(interp, $2, $3, $1);\n }\n\n-inline op fdiv(invar PMC, invar PMC, in NUM) :base_core {\n+inline op fdiv(invar PMC, invar PMC, in NUM) {\n     $1 = VTABLE_floor_divide_float(interp, $2, $3, $1);\n }\n\n@@ -378,16 +378,16 @@ Set $1 to the smallest integral value greater than or equal to $2.\n\n =cut\n\n-inline op ceil(inout NUM) :base_core {\n+inline op ceil(inout NUM) {\n     $1 = ceil($1);\n }\n\n-inline op ceil(out INT, in NUM) :base_core {\n+inline op ceil(out INT, in NUM) {\n     const FLOATVAL f = ceil($2);\n     $1 = (INTVAL)f;\n }\n\n-inline op ceil(out NUM, in NUM) :base_core {\n+inline op ceil(out NUM, in NUM) {\n     $1 = ceil($2);\n }\n\n@@ -405,16 +405,16 @@ Set $1 to the largest integral value less than or equal to $2.\n\n =cut\n\n-inline op floor(inout NUM) :base_core {\n+inline op floor(inout NUM) {\n     $1 = floor($1);\n }\n\n-inline op floor(out INT, in NUM) :base_core {\n+inline op floor(out INT, in NUM) {\n     const FLOATVAL f = floor($2);\n     $1 = (INTVAL)f;\n }\n\n-inline op floor(out NUM, in NUM) :base_core {\n+inline op floor(out NUM, in NUM) {\n     $1 = floor($2);\n }\n\n@@ -430,15 +430,15 @@ Increase $1 by one.\n\n =cut\n\n-inline op inc(inout INT) :base_core {\n+inline op inc(inout INT) {\n     $1++;\n }\n\n-inline op inc(inout NUM) :base_core {\n+inline op inc(inout NUM) {\n     $1++;\n }\n\n-inline op inc(invar PMC) :base_core {\n+inline op inc(invar PMC) {\n     VTABLE_increment(interp, $1);\n }\n\n@@ -490,43 +490,43 @@ References:\n\n =cut\n\n-op mod(inout INT, in INT) :base_core {\n+op mod(inout INT, in INT) {\n     $1 = Parrot_util_intval_mod($1, $2);\n }\n\n-op mod(inout NUM, in NUM) :base_core {\n+op mod(inout NUM, in NUM) {\n     $1 = Parrot_util_floatval_mod($1, $2);\n }\n\n-inline op mod(invar PMC, invar PMC) :base_core {\n+inline op mod(invar PMC, invar PMC) {\n     VTABLE_i_modulus(interp, $1, $2);\n }\n\n-inline op mod(invar PMC, in INT) :base_core {\n+inline op mod(invar PMC, in INT) {\n     VTABLE_i_modulus_int(interp, $1, $2);\n }\n\n-inline op mod(invar PMC, in NUM) :base_core {\n+inline op mod(invar PMC, in NUM) {\n     VTABLE_i_modulus_float(interp, $1, $2);\n }\n\n-op mod(out INT, in INT, in INT) :base_core {\n+op mod(out INT, in INT, in INT) {\n     $1 = Parrot_util_intval_mod($2, $3);\n }\n\n-op mod(out NUM, in NUM, in NUM) :base_core {\n+op mod(out NUM, in NUM, in NUM) {\n     $1 = Parrot_util_floatval_mod($2, $3);\n }\n\n-inline op mod(invar PMC, invar PMC, invar PMC) :base_core {\n+inline op mod(invar PMC, invar PMC, invar PMC) {\n     $1 = VTABLE_modulus(interp, $2, $3, $1);\n }\n\n-inline op mod(invar PMC, invar PMC, in INT) :base_core {\n+inline op mod(invar PMC, invar PMC, in INT) {\n     $1 = VTABLE_modulus_int(interp, $2, $3, $1);\n }\n\n-inline op mod(invar PMC, invar PMC, in NUM) :base_core {\n+inline op mod(invar PMC, invar PMC, in NUM) {\n     $1 = VTABLE_modulus_float(interp, $2, $3, $1);\n }\n\n@@ -558,43 +558,43 @@ Set $1 to the product of $2 and $3.\n\n =cut\n\n-inline op mul(inout INT, in INT) :base_core {\n+inline op mul(inout INT, in INT) {\n     $1 *= $2;\n }\n\n-inline op mul(inout NUM, in NUM) :base_core {\n+inline op mul(inout NUM, in NUM) {\n     $1 *= $2;\n }\n\n-inline op mul(invar PMC, invar PMC) :base_core {\n+inline op mul(invar PMC, invar PMC) {\n     VTABLE_i_multiply(interp, $1, $2);\n }\n\n-inline op mul(invar PMC, in INT) :base_core {\n+inline op mul(invar PMC, in INT) {\n     VTABLE_i_multiply_int(interp, $1, $2);\n }\n\n-inline op mul(invar PMC, in NUM) :base_core {\n+inline op mul(invar PMC, in NUM) {\n     VTABLE_i_multiply_float(interp, $1, $2);\n }\n\n-inline op mul(out INT, in INT, in INT) :base_core {\n+inline op mul(out INT, in INT, in INT) {\n     $1 = $2 \\* $3;\n }\n\n-inline op mul(out NUM, in NUM, in NUM) :base_core {\n+inline op mul(out NUM, in NUM, in NUM) {\n     $1 = $2 \\* $3;\n }\n\n-inline op mul(invar PMC, invar PMC, invar PMC) :base_core {\n+inline op mul(invar PMC, invar PMC, invar PMC) {\n     $1 = VTABLE_multiply(interp, $2, $3, $1);\n }\n\n-inline op mul(invar PMC, invar PMC, in INT) :base_core {\n+inline op mul(invar PMC, invar PMC, in INT) {\n     $1 = VTABLE_multiply_int(interp, $2, $3, $1);\n }\n\n-inline op mul(invar PMC, invar PMC, in NUM) :base_core {\n+inline op mul(invar PMC, invar PMC, in NUM) {\n     $1 = VTABLE_multiply_float(interp, $2, $3, $1);\n }\n\n@@ -618,27 +618,27 @@ Set $1 to the negative of $2.\n\n =cut\n\n-inline op neg(inout INT) :base_core {\n+inline op neg(inout INT) {\n     $1 = - $1;\n }\n\n-inline op neg(inout NUM) :base_core {\n+inline op neg(inout NUM) {\n     $1 = - $1;\n }\n\n-inline op neg(invar PMC) :base_core {\n+inline op neg(invar PMC) {\n     VTABLE_i_neg(interp, $1);\n }\n\n-inline op neg(out INT, in INT) :base_core {\n+inline op neg(out INT, in INT) {\n     $1 = - $2;\n }\n\n-inline op neg(out NUM, in NUM) :base_core {\n+inline op neg(out NUM, in NUM) {\n     $1 = - $2;\n }\n\n-inline op neg(out PMC, invar PMC) :base_core {\n+inline op neg(out PMC, invar PMC) {\n     $1 = VTABLE_neg(interp, $2, $1);\n }\n\n@@ -670,43 +670,43 @@ Set $1 to $2 minus $3.\n\n =cut\n\n-inline op sub(inout INT, in INT) :base_core {\n+inline op sub(inout INT, in INT) {\n     $1 -= $2;\n }\n\n-inline op sub(inout NUM, in NUM) :base_core {\n+inline op sub(inout NUM, in NUM) {\n     $1 -= $2;\n }\n\n-inline op sub(invar PMC, invar PMC) :base_core {\n+inline op sub(invar PMC, invar PMC) {\n     VTABLE_i_subtract(interp, $1, $2);\n }\n\n-inline op sub(invar PMC, in INT) :base_core {\n+inline op sub(invar PMC, in INT) {\n     VTABLE_i_subtract_int(interp, $1, $2);\n }\n\n-inline op sub(invar PMC, in NUM) :base_core {\n+inline op sub(invar PMC, in NUM) {\n     VTABLE_i_subtract_float(interp, $1, $2);\n }\n\n-inline op sub(out INT, in INT, in INT) :base_core {\n+inline op sub(out INT, in INT, in INT) {\n     $1 = $2 - $3;\n }\n\n-inline op sub(out NUM, in NUM, in NUM) :base_core {\n+inline op sub(out NUM, in NUM, in NUM) {\n     $1 = $2 - $3;\n }\n\n-inline op sub(invar PMC, invar PMC, invar PMC) :base_core {\n+inline op sub(invar PMC, invar PMC, invar PMC) {\n     $1 = VTABLE_subtract(interp, $2, $3, $1);\n }\n\n-inline op sub(invar PMC, invar PMC, in INT) :base_core {\n+inline op sub(invar PMC, invar PMC, in INT) {\n     $1 = VTABLE_subtract_int(interp, $2, $3, $1);\n }\n\n-inline op sub(invar PMC, invar PMC, in NUM) :base_core {\n+inline op sub(invar PMC, invar PMC, in NUM) {\n     $1 = VTABLE_subtract_float(interp, $2, $3, $1);\n }\n\n@@ -718,7 +718,7 @@ Set $1 to the square root of $2.\n\n =cut\n\n-inline op sqrt(out NUM, in NUM) :base_core {\n+inline op sqrt(out NUM, in NUM) {\n     $1 = sqrt((FLOATVAL)$2);\n }\n\ndiff --git a/src/ops/pmc.ops b/src/ops/pmc.ops\nindex b366adb..54e5efa 100644\n--- a/src/ops/pmc.ops\n+++ b/src/ops/pmc.ops\n@@ -669,7 +669,7 @@ Return a new Iterator PMC $1 for aggregate $2.\n\n =cut\n\n-inline op iter(out PMC, invar PMC) :base_core {\n+inline op iter(out PMC, invar PMC) {\n     $1 = VTABLE_get_iter(interp, $2);\n }\n\ndiff --git a/src/ops/set.ops b/src/ops/set.ops\nindex c63c52b..2a8a15e 100644\n--- a/src/ops/set.ops\n+++ b/src/ops/set.ops\n@@ -82,78 +82,78 @@ Set $1 to $2.\n\n =cut\n\n-inline op set(out INT, in INT) :base_core {\n+inline op set(out INT, in INT) {\n     $1 = $2;\n }\n\n-inline op set(out INT, in NUM) :base_core {\n+inline op set(out INT, in NUM) {\n     $1 = (INTVAL)($2);\n }\n\n-inline op set(out INT, in STR) :base_core {\n+inline op set(out INT, in STR) {\n     $1 = Parrot_str_to_int(interp, $2);\n }\n\n-inline op set(out NUM, in NUM) :base_core {\n+inline op set(out NUM, in NUM) {\n     $1 = $2;\n }\n\n-inline op set(out NUM, in INT) :base_core {\n+inline op set(out NUM, in INT) {\n     $1 = (FLOATVAL)$2;\n }\n\n-inline op set(out NUM, in STR) :base_core {\n+inline op set(out NUM, in STR) {\n     $1 = Parrot_str_to_num(interp, $2);\n }\n\n-inline op set(out NUM, invar PMC) :base_core {\n+inline op set(out NUM, invar PMC) {\n     $1 = VTABLE_get_number(interp, $2);\n }\n\n-inline op set(out STR, invar PMC) :base_core {\n+inline op set(out STR, invar PMC) {\n     $1 = VTABLE_get_string(interp, $2);\n }\n\n-inline op set(out STR, invar STR) :base_core {\n+inline op set(out STR, invar STR) {\n     $1 = $2;\n }\n\n-inline op set(out STR, inconst STR) :base_core {\n+inline op set(out STR, inconst STR) {\n     $1 = $2;\n }\n\n-inline op set(out STR, in INT) :base_core {\n+inline op set(out STR, in INT) {\n     $1 = Parrot_str_from_int(interp, $2);\n }\n\n-inline op set(out STR, in NUM) :base_core {\n+inline op set(out STR, in NUM) {\n     $1 = Parrot_str_from_num(interp, $2);\n }\n\n-inline op set(out PMC, inconst PMC) :base_core {\n+inline op set(out PMC, inconst PMC) {\n     $1 = $2;\n }\n\n-inline op set(out PMC, invar PMC) :base_core {\n+inline op set(out PMC, invar PMC) {\n     $1 = $2;\n }\n\n-inline op set(invar PMC, in INT) :base_core {\n+inline op set(invar PMC, in INT) {\n     VTABLE_set_integer_native(interp, $1, $2);\n }\n\n-inline op set(invar PMC, in NUM) :base_core {\n+inline op set(invar PMC, in NUM) {\n     VTABLE_set_number_native(interp, $1, $2);\n }\n\n-inline op set(invar PMC, invar STR) :base_core {\n+inline op set(invar PMC, invar STR) {\n     VTABLE_set_string_native(interp, $1, $2);\n }\n\n-inline op set(invar PMC, inconst STR) :base_core {\n+inline op set(invar PMC, inconst STR) {\n     VTABLE_set_string_native(interp, $1, $2);\n }\n-inline op set(out INT, invar PMC) :base_core {\n+inline op set(out INT, invar PMC) {\n     $1 = VTABLE_get_integer(interp, $2);\n }\n\n@@ -194,27 +194,27 @@ reference PMC $2 refers to.\n\n =cut\n\n-inline op assign(invar PMC, invar PMC) :base_core {\n+inline op assign(invar PMC, invar PMC) {\n     VTABLE_assign_pmc(interp, $1, $2);\n }\n\n-inline op assign(invar PMC, in INT) :base_core {\n+inline op assign(invar PMC, in INT) {\n     VTABLE_set_integer_native(interp, $1, $2);\n }\n\n-inline op assign(invar PMC, in NUM) :base_core {\n+inline op assign(invar PMC, in NUM) {\n     VTABLE_set_number_native(interp, $1, $2);\n }\n\n-inline op assign(invar PMC, in STR) :base_core {\n+inline op assign(invar PMC, in STR) {\n     VTABLE_assign_string_native(interp, $1, $2);\n }\n\n-inline op assign(out STR, in STR) :base_core {\n+inline op assign(out STR, in STR) {\n     $1 = $2;\n }\n\n-inline op setref(invar PMC, invar PMC) :base_core {\n+inline op setref(invar PMC, invar PMC) {\n     VTABLE_set_pmc(interp, $1, $2);\n }\n\n@@ -242,19 +242,19 @@ inline op deref(out PMC, invar PMC) :base_ref {\n\n =cut\n\n-inline op set(invar PMC, in INTKEY, in INT) :base_core {\n+inline op set(invar PMC, in INTKEY, in INT) {\n     VTABLE_set_integer_keyed_int(interp, $1, $2, $3);\n }\n\n-inline op set(invar PMC, in INTKEY, in NUM) :base_core {\n+inline op set(invar PMC, in INTKEY, in NUM) {\n     VTABLE_set_number_keyed_int(interp, $1, $2, $3);\n }\n\n-inline op set(invar PMC, in INTKEY, in STR) :base_core {\n+inline op set(invar PMC, in INTKEY, in STR) {\n     VTABLE_set_string_keyed_int(interp, $1, $2, $3);\n }\n\n-inline op set(invar PMC, in INTKEY, invar PMC) :base_core {\n+inline op set(invar PMC, in INTKEY, invar PMC) {\n     VTABLE_set_pmc_keyed_int(interp, $1, $2, $3);\n }\n\n@@ -278,19 +278,19 @@ inline op set(invar PMC, in INTKEY, invar PMC) :base_core {\n\n =cut\n\n-inline op set(out INT, invar PMC, in INTKEY) :base_core {\n+inline op set(out INT, invar PMC, in INTKEY) {\n     $1 = VTABLE_get_integer_keyed_int(interp, $2, $3);\n }\n\n-inline op set(out NUM, invar PMC, in INTKEY) :base_core {\n+inline op set(out NUM, invar PMC, in INTKEY) {\n     $1 = VTABLE_get_number_keyed_int(interp, $2, $3);\n }\n\n-inline op set(out STR, invar PMC, in INTKEY) :base_core {\n+inline op set(out STR, invar PMC, in INTKEY) {\n     $1 = VTABLE_get_string_keyed_int(interp, $2, $3);\n }\n\n-inline op set(out PMC, invar PMC, in INTKEY) :base_core {\n+inline op set(out PMC, invar PMC, in INTKEY) {\n     $1 = VTABLE_get_pmc_keyed_int(interp, $2, $3);\n }\n\n@@ -314,19 +314,19 @@ inline op set(out PMC, invar PMC, in INTKEY) :base_core {\n\n =cut\n\n-inline op set(invar PMC, in KEY, in INT) :base_core {\n+inline op set(invar PMC, in KEY, in INT) {\n     VTABLE_set_integer_keyed(interp, $1, $2, $3);\n }\n\n-inline op set(invar PMC, in KEY, in NUM) :base_core {\n+inline op set(invar PMC, in KEY, in NUM) {\n     VTABLE_set_number_keyed(interp, $1, $2, $3);\n }\n\n-inline op set(invar PMC, in KEY, in STR) :base_core {\n+inline op set(invar PMC, in KEY, in STR) {\n     VTABLE_set_string_keyed(interp, $1, $2, $3);\n }\n\n-inline op set(invar PMC, in KEY, invar PMC) :base_core {\n+inline op set(invar PMC, in KEY, invar PMC) {\n     VTABLE_set_pmc_keyed(interp, $1, $2, $3);\n }\n\n@@ -350,19 +350,19 @@ inline op set(invar PMC, in KEY, invar PMC) :base_core {\n\n =cut\n\n-inline op set(out INT, invar PMC, in KEY) :base_core {\n+inline op set(out INT, invar PMC, in KEY) {\n     $1 = VTABLE_get_integer_keyed(interp, $2, $3);\n }\n\n-inline op set(out NUM, invar PMC, in KEY) :base_core {\n+inline op set(out NUM, invar PMC, in KEY) {\n     $1 = VTABLE_get_number_keyed(interp, $2, $3);\n }\n\n-inline op set(out STR, invar PMC, in KEY) :base_core {\n+inline op set(out STR, invar PMC, in KEY) {\n     $1 = VTABLE_get_string_keyed(interp, $2, $3);\n }\n\n-inline op set(out PMC, invar PMC, in KEY) :base_core {\n+inline op set(out PMC, invar PMC, in KEY) {\n     $1 = VTABLE_get_pmc_keyed(interp, $2, $3);\n }\n\n@@ -466,19 +466,19 @@ Set register $1 to PMCNULL.\n\n =cut\n\n-inline op null(out STR) :base_core {\n+inline op null(out STR) {\n     $1 = STRINGNULL;\n }\n\n-inline op null(out INT) :base_core {\n+inline op null(out INT) {\n     $1 = 0;\n }\n\n-inline op null(out PMC) :base_core {\n+inline op null(out PMC) {\n     $1 = PMCNULL;\n }\n\n-inline op null(out NUM) :base_core {\n+inline op null(out NUM) {\n     $1 = 0;\n }\n\ndiff --git a/src/ops/string.ops b/src/ops/string.ops\nindex d3ce85f..84b7e03 100644\n--- a/src/ops/string.ops\n+++ b/src/ops/string.ops\n@@ -46,11 +46,11 @@ If $3 is less than the negative of the length of $2, an exception is thrown.\n\n =cut\n\n-inline op ord(out INT, in STR) :base_core {\n+inline op ord(out INT, in STR) {\n     $1 = STRING_ord(interp, $2, 0);\n }\n\n-inline op ord(out INT, in STR, in INT) :base_core {\n+inline op ord(out INT, in STR, in INT) {\n     $1 = STRING_ord(interp, $2, $3);\n }\n\n@@ -61,7 +61,7 @@ The character specified by codepoint integer $2 is returned in string $1.\n\n =cut\n\n-inline op chr(out STR, in INT) :base_core {\n+inline op chr(out STR, in INT) {\n     STRING \\* const s = Parrot_str_chr(interp, (UINTVAL)$2);\n     $1 = s;\n }\n@@ -75,7 +75,7 @@ If $3 is negative, cut the string after -$3 characters.\n\n =cut\n\n-inline op chopn(out STR, in STR, in INT) :base_core {\n+inline op chopn(out STR, in STR, in INT) {\n     $1 = Parrot_str_chopn(interp, $2, $3);\n }\n\n@@ -96,11 +96,11 @@ Append string $3 to string $2 and place the result into string $1.\n\n =cut\n\n-inline op concat(invar PMC, invar PMC) :base_core {\n+inline op concat(invar PMC, invar PMC) {\n     VTABLE_i_concatenate(interp, $1, $2);\n }\n\n-inline op concat(invar PMC, in STR) :base_core {\n+inline op concat(invar PMC, in STR) {\n     VTABLE_i_concatenate_str(interp, $1, $2);\n }\n\n@@ -108,11 +108,11 @@ inline op concat(out STR, in STR, in STR) :base_mem {\n     $1 = Parrot_str_concat(interp, $2, $3);\n }\n\n-inline op concat(invar PMC, invar PMC, in STR) :base_core {\n+inline op concat(invar PMC, invar PMC, in STR) {\n     $1 = VTABLE_concatenate_str(interp, $2, $3, $1);\n }\n\n-inline op concat(invar PMC, invar PMC, invar PMC) :base_core {\n+inline op concat(invar PMC, invar PMC, invar PMC) {\n     $1 = VTABLE_concatenate(interp, $2, $3, $1);\n }\n\n@@ -137,7 +137,7 @@ inline op repeat(out STR, in STR, in INT) :base_mem {\n     $1 = Parrot_str_repeat(interp, $2, (UINTVAL)$3);\n }\n\n-inline op repeat(invar PMC, invar PMC, in INT) :base_core {\n+inline op repeat(invar PMC, invar PMC, in INT) {\n     if ($3 \u003c 0) {\n         opcode_t \\* const handler = Parrot_ex_throw_from_op_args(interp, NULL,\n                 EXCEPTION_NEG_REPEAT,\n@@ -147,7 +147,7 @@ inline op repeat(invar PMC, invar PMC, in INT) :base_core {\n     $1 = VTABLE_repeat_int(interp, $2, $3, $1);\n }\n\n-inline op repeat(invar PMC, invar PMC, invar PMC) :base_core {\n+inline op repeat(invar PMC, invar PMC, invar PMC) {\n     if (VTABLE_get_integer(interp, $3) \u003c 0) {\n         opcode_t \\* const handler = Parrot_ex_throw_from_op_args(interp, NULL,\n                 EXCEPTION_NEG_REPEAT,\n@@ -166,11 +166,11 @@ The C\u003cPMC\u003e versions are MMD operations.\n\n =cut\n\n-inline op repeat(invar PMC, in INT) :base_core {\n+inline op repeat(invar PMC, in INT) {\n     VTABLE_i_repeat_int(interp, $1, $2);\n }\n\n-inline op repeat(invar PMC, invar PMC) :base_core {\n+inline op repeat(invar PMC, invar PMC) {\n     VTABLE_i_repeat(interp, $1, $2);\n }\n\n@@ -251,20 +251,20 @@ New $1 string returned.\n\n =cut\n\n-inline op substr(out STR, in STR, in INT) :base_core {\n+inline op substr(out STR, in STR, in INT) {\n     const INTVAL len = Parrot_str_byte_length(interp, $2);\n     $1 = STRING_substr(interp, $2, $3, len);\n }\n\n-inline op substr(out STR, in STR, in INT, in INT) :base_core {\n+inline op substr(out STR, in STR, in INT, in INT) {\n     $1 = STRING_substr(interp, $2, $3, $4);\n }\n\n-inline op substr(out STR, invar PMC, in INT, in INT) :base_core {\n+inline op substr(out STR, invar PMC, in INT, in INT) {\n     $1 = VTABLE_substr_str(interp, $2, $3, $4);\n }\n\n-inline op replace(out STR, in STR, in INT, in INT, in STR) :base_core {\n+inline op replace(out STR, in STR, in INT, in INT, in STR) {\n     $1 = Parrot_str_replace(interp, $2, $3, $4, $5);\n }\n\n@@ -284,11 +284,11 @@ B\u003cindex\u003e returns \"-1\".\n\n =cut\n\n-inline op index(out INT, in STR, in STR) :base_core {\n+inline op index(out INT, in STR, in STR) {\n     $1 = ($2 \u0026\u0026 $3) ? STRING_index(interp, $2, $3, 0) : -1;\n }\n\n-inline op index(out INT, in STR, in STR, in INT) :base_core {\n+inline op index(out INT, in STR, in STR, in INT) {\n     $1 = ($2 \u0026\u0026 $3) ? STRING_index(interp, $2, $3, $4) : -1;\n }\n\n@@ -308,11 +308,11 @@ see F\u003cmisc.c\u003e for details.\n\n =cut\n\n-inline op sprintf(out STR, in STR, invar PMC) :base_core {\n+inline op sprintf(out STR, in STR, invar PMC) {\n     $1=Parrot_psprintf(interp, $2, $3);\n }\n\n-inline op sprintf(out PMC, invar PMC, invar PMC) :base_core {\n+inline op sprintf(out PMC, invar PMC, invar PMC) {\n     VTABLE_set_string_native(interp, $1,\n         Parrot_psprintf(interp, VTABLE_get_string(interp, $2), $3));\n }\n@@ -362,7 +362,7 @@ Possible values for $3 are:\n\n =cut\n\n-inline op stringinfo(out INT, in STR, in INT) :base_core {\n+inline op stringinfo(out INT, in STR, in INT) {\n     if ($2 == NULL)\n         $1 = 0;\n     else {\n@@ -403,7 +403,7 @@ Uppercase $2 and put the result in $1\n\n =cut\n\n-inline op upcase(out STR, in STR) :base_core {\n+inline op upcase(out STR, in STR) {\n     $1 = Parrot_str_upcase(interp, $2);\n }\n\n@@ -413,7 +413,7 @@ Downcase $2 and put the result in $1\n\n =cut\n\n-inline op downcase(out STR, in STR) :base_core {\n+inline op downcase(out STR, in STR) {\n     $1 = Parrot_str_downcase(interp, $2);\n }\n\n@@ -423,7 +423,7 @@ Titlecase $2 and put the result in $1\n\n =cut\n\n-inline op titlecase(out STR, in STR) :base_core {\n+inline op titlecase(out STR, in STR) {\n     $1 = Parrot_str_titlecase(interp, $2);\n }\n\n@@ -445,11 +445,11 @@ on regular expression, use CPGE::Util's split from the standard library.\n\n =cut\n\n-op join(out STR, in STR, invar PMC) :base_core {\n+op join(out STR, in STR, invar PMC) {\n     $1 = Parrot_str_join(interp, $2, $3);\n }\n\n-op split(out PMC, in STR, in STR) :base_core {\n+op split(out PMC, in STR, in STR) {\n     $1 = Parrot_str_split(interp, $2, $3);\n }\n\n@@ -476,15 +476,15 @@ Both functions may throw an exception on information loss.\n\n =cut\n\n-op encoding(out INT, in STR) :base_core {\n+op encoding(out INT, in STR) {\n     $1 = Parrot_encoding_number_of_str(interp, $2);\n }\n\n-op encodingname(out STR, in INT) :base_core {\n+op encodingname(out STR, in INT) {\n     $1 = Parrot_encoding_name(interp, $2);\n }\n\n-op find_encoding(out INT, in STR) :base_core {\n+op find_encoding(out INT, in STR) {\n     const INTVAL n = Parrot_encoding_number(interp, $2);\n     if (n \u003c 0) {\n         opcode_t \\* const handler = Parrot_ex_throw_from_op_args(interp, NULL,\ndiff --git a/src/ops/var.ops b/src/ops/var.ops\nindex 212ca34..840eef4 100644\n--- a/src/ops/var.ops\n+++ b/src/ops/var.ops\n@@ -472,7 +472,7 @@ found.\n\n =cut\n\n-inline op find_sub_not_null(out PMC, in STR) :base_core {\n+inline op find_sub_not_null(out PMC, in STR) {\n     opcode_t *dest = expr NEXT();\n     PMC *sub = Parrot_ns_find_named_item(interp, $2, dest);\n\n```\n```","files":null},{"type":4,"author":{"id":"aef4977f5ea786238d7c9581a2f192f4adc3f39d"},"timestamp":1336431109,"metadata":{"github-id":"MDExOkNsb3NlZEV2ZW50MTQ5NDg4NzI="},"status":2}]}