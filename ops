{"version":1,"ops":[{"type":3,"author":{"id":"8c86ede03c8e80b0dad5131138f96e957a4ee66b"},"timestamp":1380988767,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDI1NzUxMTA5","github-url":"https://github.com/parrot/parrot/issues/995#issuecomment-25751109"},"message":"I (zefram@fysh.org) wrote:\n\n\u003e typeof_p_p on a namespace object produces a null PMC rather than the\n\u003e expected PMCProxy.\n\nFrom looking at the implementation I see why this happens. The typeof_p_p op (and class_p_p, which is a duplicate of typeof_p_p) calls the \"get_class\" vtable entry. default.pmc defines this to look up the appropriate PMCProxy object, via the cache in the NameSpace associated with the PMC class. Thus typeof works for most PMCs, such as ResizablePMCArray PMCs. But namespace.pmc overrides this default behaviour: it defines the \"get_class\" vtable method to _read the class-metaobject-cache slot_ of the NameSpace PMC. So if nothing has previously populated that slot, it yields null. If the cache slot has been populated by some previous class lookup operation, then typeof_p_p on a NameSpace will yield the PMCProxy for _the class associated with that namespace_, not the PMCProxy describing the NameSpace class.\n\nThis strange use of the \"get_class\" vtable entry on the NameSpace PMC class is actually relied on elsewhere. In fact, the \"get_class\" in default.pmc uses it to get access to the cache slot. The \"get_class\" definition in default.pmc looks absurd, because it defines one meaning of the method name by using an incompatible meaning of it.\n\nThese two meanings of the \"get_class\" vtable entry cannot be successfully conflated. Access to the class-metaobject-cache slot in NameSpace must change to use a different mechanism.\n\n-zefram","files":null}]}