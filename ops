{"version":1,"ops":[{"type":1,"author":{"id":"8c86ede03c8e80b0dad5131138f96e957a4ee66b"},"timestamp":1383419635,"metadata":{"github-id":"MDU6SXNzdWUyMjAwNzU2NQ==","github-url":"https://github.com/parrot/parrot/issues/1026","origin":"github"},"title":"Inconsistent morphability","message":"Reported by: zefram@fysh.org\n\nThe basic built-in PMC classes have some behaviour whereby a PMC object can switch type with some freedom, but it's not consistent. The morphing seems to be based on a concept of the PMC object (really, its head) being a variable that can hold values of many types, with the assign_p_p op copying the value (necessarily including its type) from one variable to another. If that model were consistently followed, a PMC would be able to morph from any participating type to any other. In fact, only a few assignment combinations work like that, while others perform unrelated operations that modify the target, or generate exceptions.\n\nExample of a few assignments:\n\n```\n$ cat t53.pir\n.sub main :main\n        $P0 = box 3\n        $S0 = typeof $P0\n        say $S0\n        $P1 = box \"foo\"\n        assign $P0, $P1\n        $S0 = typeof $P0\n        say $S0\n        $P2 = box 5\n        assign $P0, $P2\n        $S0 = typeof $P0\n        say $S0\n        $P3 = new \"ResizablePMCArray\"\n        assign $P0, $P3\n        $S0 = typeof $P0\n        say $S0\n        $P4 = box 7\n        assign $P0, $P4\n        $S0 = typeof $P1\n        say $S0\n.end\n```\n\n```\n$ ./parrot t53.pir\nInteger\nString\nString\nResizablePMCArray\nCan't set self from this type\ncurrent instr.: 'main' pc 44 (t53.pir:18)\n```\n\nThis sequence shows first that an Integer can morph into a String, following the untyped variable/assignment model. But a String won't morph back into an Integer; it turns into a string representation of the integer. So this morphability isn't a symmetric arrangement. The String will morph into a ResizablePMCArray, suggesting that ResizablePMCArray is a class of value that can appear in these morphable variables, but ResizablePMCArray then won't morph back into an Integer, rejecting the operation entirely.\n\nIf assign_p_p is to be a useful operator in the general case, it needs to have a consistent meaning. There are two main possibilities that could be used. Firstly, it could mean that the target is to be morphed to have identical content to the source operand. If that's the meaning, then such assignment should consistently work between all pairs of PMC classes that support it at all. (PMC classes that don't have cloneable content, or whose content isn't mutable, can't be the source or target of such an assignment.)\n\nThe other main possibility is that assignment means to modify the target, within its existing class, to reflect some aspect of the source. This is essentially a coercion operation, with the target operand being a more strictly typed variable. In this case it is sensible for the operations actually performed to be more diverse than with the untyped-variable model, but one wouldn't expect any morphing between PMC classes. The set of coercions that's possible can sensibly be asymmetric: for example, PMC classes whose content isn't mutable can be the source of a coercing assignment even though they can't be the destination of any.\n\nAs these two kinds of assignment are both somewhat useful, it may make more sense to support both, with separate opcodes and separate vtable entries.\n\n-zefram\n\n```\nSummary of my parrot 5.7.0 configuration:\n  configdate='Sat Oct  5 12:42:43 2013 GMT'\n  Platform:\n    osname=linux, archname=x86_64-linux-gnu-thread-multi\n    perl=/usr/bin/perl\n```","files":null}]}