{"version":1,"ops":[{"type":3,"author":{"id":"4277d85693ce7ae3559eb0a94f3b50be93446600"},"timestamp":1380989516,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDI1NzUxMzQ3","github-url":"https://github.com/parrot/parrot/issues/1002#issuecomment-25751347"},"message":"I won't comment on the original issue, but the bug report contains another inaccuarcy:\n\n\u003e The compiler might consider whether strlen might initialise c through its pointer parameter. The const qualification means that it cannot, and therefore c is indeed used uninitialised when being copied to d.\n\nThis is actually not guaranteed by C language semantics - casting `const` away to initialize the value is perfectly fine and will only result in undefined behaviour if the memory location itself were declared `const`, ie\n\n```\nconst char c;\n```\n\nIf the compiler can't see the body of `strlen()`, it may _not_ optimize on the assumption that the object will not be modified just because the pointer argument was `const`-qualified.\n\nEven adding `restrict` does not help - while a `restrict`-qualified pointer-to-`const` does indeed guarantee immutability callee-side, calling code may not rely on this as `restrict` semantics only apply if the argument is actually accessed, which the caller cannot know without inspecting the function body.","files":null}]}