{"version":1,"ops":[{"type":1,"author":{"id":"8c86ede03c8e80b0dad5131138f96e957a4ee66b"},"timestamp":1380772770,"metadata":{"github-id":"MDU6SXNzdWUyMDQzNjI1NA==","github-url":"https://github.com/parrot/parrot/issues/1000","origin":"github"},"title":"Aliasing vs cloning doc unclarity","message":"Reported by: zefram@fysh.org\n\nThe op documentation is often unclear about whether an op performs aliasing or cloning of PMCs. That is, whether the op changes which PMC object a $Pn register points to or changes the content of the PMC object that the register already points to. For example, set_p_p aliases, but set_p_s mutates (cloning the string), despite both being documented as just \"Set $1 to $2.\".\n\nDemonstration:\n\n```\n$ cat t25.pir\n.sub main :main\n        $P0 = new \"String\"\n        assign $P0, \"foo\"\n        $P1 = new \"String\"\n        set $P1, $P0\n        set $P0, \"bar\"\n        say $P1\n.end\n$ ./parrot t25.pir\nbar\n```\n\nGetting \"bar\" out of $P1 there shows that (a) $P1 was aliased to $P0 by 'set $P1, $P0' _and_ (b) 'set $P0, \"bar\"' mutated the PMC referenced by $P0 rather than making $P0 refer to a new PMC.\n\nThings are made worse by having \"assign\" opcodes separate from \"set\", which appear to be making an aliasing/cloning distinction but in most cases don't. Also made worse by the use of \"$P0 = ...\" syntax in PIR for both kinds of operation. If you can countenance some incompatible change here, you could make things much clearer by using \"set\" and \"=\" only for alias-type operations and \"assign\" only for clone-type operations.\n\nWith so much mutability in the system, it's vitally important to be clear about which things are aliased and which are not.\n\n-zefram","files":null}]}