{"version":1,"ops":[{"type":3,"author":{"id":"96fb2e2e33b59677e3a85ec74746c085275c50d1"},"timestamp":1278219693,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDM1OTY=","github-url":"https://github.com/parrot/parrot/issues/564#issuecomment-3503596"},"message":"\u003cp\u003e\njust to confirm this\n\u003c/p\u003e\n\n\u003cp\u003e\nI extracted the example from the pir book - chapter 6:\n\u003c/p\u003e\n\n\u003cpre class=\"wiki\"\u003e# example from pir book - chapter 6\n#\n  .sub 'MyCoro'\n    .yield(1)\n    .yield(2)\n    .yield(3)\n    .return(4)\n  .end\n  .sub 'main' :main\n    $I0 = MyCoro()    # 1\n    $I0 = MyCoro()    # 2\n    $I0 = MyCoro()    # 3\n    $I0 = MyCoro()    # 4\n    $I0 = MyCoro()    # 1\n    $I0 = MyCoro()    # 2\n    $I0 = MyCoro()    # 3\n    $I0 = MyCoro()    # 4\n    $I0 = MyCoro()    # 1\n    $I0 = MyCoro()    # 2\n    $I0 = MyCoro()    # 3\n    $I0 = MyCoro()    # 4\n  .end\n\u003c/pre\u003e\u003cp\u003e\nI ran it against my latest parrot build - r47979 - Ubuntu 9.10 amd64 (g++ with --optimize)\n\u003c/p\u003e\n\u003cpre class=\"wiki\"\u003emhb@mhb-desktop:~/parrot$ parrot -t test_coroutine.pir\n0010 set_args PC10\n0012 set P0, PC7                                        P0=PMCNULL PC7=Coroutine=PMC(0x10cf3f0)\n0015 invokecc P0                                        P0=Coroutine=PMC(0x10cf3f0)\n0000 set_returns PC1 (1), 1\n0003 yield\n0017 get_results PC8 (1), I0                                        PC8=FixedIntegerArray=PMC(0x11140d0) I0=0\n001a set_args PC10\n001c set P1, PC7                                        P1=PMCNULL PC7=Coroutine=PMC(0x10cf3f0)\n001f invokecc P1                                        P1=Coroutine=PMC(0x10cf3f0)\n0004 set_returns PC1 (1), 2\n0007 yield\n0021 get_results PC8 (1), I0                                        PC8=FixedIntegerArray=PMC(0x11140d0) I0=1\n0024 set_args PC10\n0026 set P2, PC7                                        P2=PMCNULL PC7=Coroutine=PMC(0x10cf3f0)\n0029 invokecc P2                                        P2=Coroutine=PMC(0x10cf3f0)\n0008 set_returns PC1 (1), 3\n000b yield\n002b get_results PC8 (1), I0                                        PC8=FixedIntegerArray=PMC(0x11140d0) I0=2\n002e set_args PC10\n0030 set P3, PC7                                        P3=PMCNULL PC7=Coroutine=PMC(0x10cf3f0)\n0033 invokecc P3                                        P3=Coroutine=PMC(0x10cf3f0)\n000c set_returns PC1 (1), 4\n000f returncc\n0017 get_results PC8 (1), I0                                        PC8=FixedIntegerArray=PMC(0x11140d0) I0=3\n001a set_args PC10\n001c set P1, PC7                                        P1=Coroutine=PMC(0x10cf3f0) PC7=Coroutine=PMC(0x10cf3f0)\n001f invokecc P1                                        P1=Coroutine=PMC(0x10cf3f0)\nCannot resume dead coroutine.\ncurrent instr.: 'main' pc 33 (test_coroutine.pir:12)\nFileHandle objects (like stdout and stderr)are about to be closed, so clearing trace flags.\n\u003c/pre\u003e","files":null},{"type":3,"author":{"id":"0c1ee4af33970ee80260d659da672a9306b51181"},"timestamp":1279492140,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDM1OTc=","github-url":"https://github.com/parrot/parrot/issues/564#issuecomment-3503597"},"message":"\u003cp\u003e\nTalked with NotFound about this on IRC. To summarize:\n\u003c/p\u003e\n\n\u003cp\u003e\nAny call to a coroutine will have to know if it is the initial call (where arguments are passed) or a subsequent call (where arguments are not passed). So, the best default behavior is to allow the coroutine to \"die\", rather than to implicitly \"ressurect\" it and start from the beginning. But, we do need a way to restart a dead coroutine (and possibly even to restart one that is currently active). The two best suggestions were a 'restart' method on the coroutine object, and an optional named argument 'restart'=\u0026gt;1 passed in with the other arguments to the coroutine. The method is simplest, and so could be implemented first. The optional named argument is a possible future refinement.\n\u003c/p\u003e","files":null},{"type":3,"author":{"id":"0c9c62332064205b2d799407019fa3e7e2f43862"},"timestamp":1279642561,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDM1OTg=","github-url":"https://github.com/parrot/parrot/issues/564#issuecomment-3503598"},"message":"\u003cpre class=\"wiki\"\u003eOn Sun, Jul 18, 2010 at 03:29:00PM -0000, Parrot wrote:\n\u0026gt; #1702: Cannot resume dead coroutine\n\u0026gt; Comment(by allison):\n\u0026gt;\n\u0026gt;  Talked with NotFound about this on IRC. To summarize:\nFWIW, the way that PGE managed this issue was to clone\nCoroutines prior to making the initial call, and never\ninvoke the original Coroutine directly.  Then it became\nrelatively easy to \"restart a coroutine\" from the beginning\nby making a new clone of the original.\nPm\n\u003c/pre\u003e","files":null},{"type":3,"author":{"id":"0c9c62332064205b2d799407019fa3e7e2f43862"},"timestamp":1279721696,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDM1OTk=","github-url":"https://github.com/parrot/parrot/issues/564#issuecomment-3503599"},"message":"\u003cp\u003e\nSee also TT \u003ca class=\"new ticket\" href=\"http://trac.parrot.org/parrot/ticket/1710\" title=\"bug: [BUG]  exit of a Coroutine affects all of its sister clones (new)\"\u003e#1710\u003c/a\u003e, which likely has some strong correlation with the items mentioned here.\n\u003c/p\u003e\n\n\u003cp\u003e\nPm\n\u003c/p\u003e","files":null},{"type":3,"author":{"id":"86141a663c2eb7543d1a51ec6253a1d54de912fd"},"timestamp":1412611033,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDU4MDM5NDAz","github-url":"https://github.com/parrot/parrot/issues/564#issuecomment-58039403"},"message":"Not a bug IMHO.\n\nparrot coros and yield is designed after lua. If all the yield states are exhausted, the coro is dead. All other implementations I know also behave the same, even with the exact same error message. Do you want a generator/iterator suddenly restart at the beginning when the end of the lazy list is reached?\n\nOnly the parrot book talks otherwise (automatic restart) and I have no idea, why it was written that way.\n\nThe trick with clone to restore a coro state seems great. The somewhat related \"sister bug\" #585 is also not a bug, every clone is dead when the yield states are exhausted, independently. There's no connection between the sisters in the #585  example.\nAnd some testcases talk about the wrong thing. I'll add state diagrams to those tests","files":null},{"type":3,"author":{"id":"86141a663c2eb7543d1a51ec6253a1d54de912fd"},"timestamp":1413545007,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDU5NDk5NTE5","github-url":"https://github.com/parrot/parrot/issues/564#issuecomment-59499519"},"message":"Merged into 6.9.0 with c0692efe39039dd2a4ea42dd68f41ca2a429658f\n\nNote that there's still a one-off bug with coro states, one invoke too many TT 1003\nwhich is now more trouble-some when coros are changed to autoreset.","files":null},{"type":4,"author":{"id":"86141a663c2eb7543d1a51ec6253a1d54de912fd"},"timestamp":1413545007,"metadata":{"github-id":"MDExOkNsb3NlZEV2ZW50MTc5OTYwNDMx"},"status":2}]}