{"version":1,"ops":[{"type":1,"author":{"id":"8c86ede03c8e80b0dad5131138f96e957a4ee66b"},"timestamp":1383419288,"metadata":{"github-id":"MDU6SXNzdWUyMjAwNzQ2Nw==","github-url":"https://github.com/parrot/parrot/issues/1018","origin":"github"},"title":"Threads cripple mutability of shared data","message":"Reported by: zefram@fysh.org\n\nWhere threads run in parallel, threads other than the main thread can't write to shared data structures:\n\n```\n$ cat t61.pir\n.sub foo\n        $P0 = new \"ResizablePMCArray\"\n        push_eh carp\n        set_global \"wibble\", $P0\n        pop_eh\n        say \"ok\"\n        .return ()\n        carp:\n        pop_eh\n        $P1 = peek_exception\n        say $P1\n        .return ()\n.end\n.sub main :main\n        .const \"Sub\" foo = \"foo\"\n        $P1 = new \"Task\", foo\n        schedule $P1\n        sleep 0.1\n.end\n```\n\n```\n$ ./parrot t61.pir\nset_pmc_keyed_str() in read-only proxy of 'NameSpace'\n```\n\nAt a guess, it looks like this is intended to prevent race conditions that come from mutation of shared data. But it won't actually achieve that end, because there are plenty of race conditions that arise with just one mutator (the owner of the data structure) and an asynchronous reader.\n\n-zefram\n\n```\nSummary of my parrot 5.7.0 configuration:\n  configdate='Sat Oct  5 12:42:43 2013 GMT'\n  Platform:\n    osname=linux, archname=x86_64-linux-gnu-thread-multi\n    perl=/usr/bin/perl\n```","files":null}]}