{"version":1,"ops":[{"type":3,"author":{"id":"0c9c62332064205b2d799407019fa3e7e2f43862"},"timestamp":1249590672,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDMxNDc=","github-url":"https://github.com/parrot/parrot/issues/446#issuecomment-3503147"},"message":"\u003cp\u003e\nReplying to \u003ca class=\"new ticket\" href=\"http://trac.parrot.org/parrot/ticket/903\" title=\"RFC: [RFC] Deprecate Keys at all. (new)\"\u003ebacek\u003c/a\u003e:\n\u003c/p\u003e\n\n\u003cblockquote class=\"citation\"\u003e\n\u003cp\u003e\n ...\n Actually NamespaceKey can be is-a RSA. Then creating it in pir will be something like\n {{{\n    $P0 = split ';', 'foo;bar;baz'\n    $P1 = new [NamespaceKey]\n    $P1 = $P0\n }}}\n\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e\nNote that this last statement cannot be correct -- it would simply create a NamespaceKey and then throw it away as $P1 is set to the RSA returned from the split.\n\u003c/p\u003e\n\n\u003cp\u003e\nI suspect you mean   \"assign $P1, $P0\" here.\n\u003c/p\u003e\n\n\u003cp\u003e\nAlso, I hope this is only intended as a mechanism for creating NamespaceKey objects at runtime -- clearly we would expect ['foo';'bar';'baz'] to work as a constant namespace key in PIR.\n\u003c/p\u003e\n\n\u003cp\u003e\nPm\n\u003c/p\u003e\n\n\u003cp\u003e\nNo.  If you require this then you're taking something that is currently a compile-time constant and turning it into a runtime operation (and creating N+2 GCables).\n\u003c/p\u003e\n\n\u003cp\u003e\nPlease make sure that we can continue to do\n\u003c/p\u003e","files":null},{"type":3,"author":{"id":"099af60226e2576bd4ff0f5c2614b710c745cab6"},"timestamp":1249621456,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDMxNDg=","github-url":"https://github.com/parrot/parrot/issues/446#issuecomment-3503148"},"message":"\u003cp\u003e\nReplying to \u003ca href=\"http://trac.parrot.org/parrot/ticket/903#comment:1\" title=\"Comment 1 for Ticket #903\"\u003epmichaud\u003c/a\u003e:\n\u003c/p\u003e\n\n\u003cblockquote class=\"citation\"\u003e\n\u003cp\u003e\n Note that this last statement cannot be correct -- it would simply create a NamespaceKey and then throw it away as $P1 is set to the RSA returned from the split.\n I suspect you mean   \"assign $P1, $P0\" here.\n\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e\nAh. yes. My mistake.\n\u003c/p\u003e\n\n\u003cblockquote class=\"citation\"\u003e\n\u003cp\u003e\n Also, I hope this is only intended as a mechanism for creating NamespaceKey objects at runtime -- clearly we would expect ['foo';'bar';'baz'] to work as a constant namespace key in PIR.\n\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e\nCorrect. Example PIR is additional mechanism for creating NamespaceKeys in run-time. IMCC/PIRC/* will emit constant PMC during compilation.\n\u003c/p\u003e\n\n\u003cblockquote class=\"citation\"\u003e\n\u003cp\u003e\n No.  If you require this then you're taking something that is currently a compile-time constant and turning it into a runtime operation (and creating N+2 GCables).\n Please make sure that we can continue to do\n\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e\nYes.\n\u003c/p\u003e\n\n\u003cp\u003e\nMain idea to remove Keys for navigating over ordinary Hashes/Arrays. Namespace will stay almost same. Keys became NamespaceKeys but with string parts only.\n\u003c/p\u003e\n\n\u003cp\u003e\n--\nBacek\n\u003c/p\u003e","files":null},{"type":3,"author":{"id":"0c1ee4af33970ee80260d659da672a9306b51181"},"timestamp":1249875137,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDMxNDk=","github-url":"https://github.com/parrot/parrot/issues/446#issuecomment-3503149"},"message":"\u003cp\u003e\nI'm okay with eliminating the Key PMC, but not the ['foo';'bar';'baz'] syntax. It's too useful. And, a custom NamespaceKey PMC is unnecessary, when all we really need is a FixedStringArray. This will have to wait until after 2.0, since it's a substantial deprecation.\n\u003c/p\u003e\n\n\u003cul\u003e\u003cli\u003eContinue to parse ['foo';'bar';'baz'] everywhere it's currently parsed, but generate a FSA instead of a Key.\n\u003c/li\u003e\u003c/ul\u003e\u003cul\u003e\u003cli\u003eWhen used with and array or hash, ($I0 = $P0['foo';'bar'] or $P0['foo';'bar'] = $I0) they still call get_*_keyed' or 'set_*_keyed', but they pass it a simple FSA. Each PMC is free to decide how to handle array PMC keys internally (even flattening them into a single string \"foo\\0bar\\0baz\", if it wants to).\n\u003c/li\u003e\u003c/ul\u003e\u003cul\u003e\u003cli\u003eThe NameSpace PMCs will continue to treat them as they currently treat keys and arrays, as multi-level access to the namespace tree. But, it can simplify the code, since all complex keys will be arrays.\n\u003c/li\u003e\u003c/ul\u003e\u003cul\u003e\u003cli\u003eDo away with KEY types in opcodes (they're just PMCs). Any op that can be called with a key can be called equally well with another array PMC.\n\u003c/li\u003e\u003c/ul\u003e\u003cul\u003e\u003cli\u003eMake it possible to use key syntax on the LHS of assignment, as a cheap way to create a constant FSA:\n\u003cpre class=\"wiki\"\u003e$P0 = ['foo';'bar';'baz']\n\u003c/pre\u003e\u003c/li\u003e\u003c/ul\u003e\u003cul\u003e\u003cli\u003eThese could be used to initialize PMCs:\n\u003cpre class=\"wiki\"\u003e$P0 = ['key1';'value1';'key2';'value2']\n$P1 = new \"Frobisher\", $P0\n# or even:\n$P1 = new \"Frobisher\", ['key1';'value1';'key2';'value2']\n\u003c/pre\u003e\u003c/li\u003e\u003c/ul\u003e","files":null},{"type":3,"author":{"id":"0c1ee4af33970ee80260d659da672a9306b51181"},"timestamp":1249886106,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDMxNTA=","github-url":"https://github.com/parrot/parrot/issues/446#issuecomment-3503150"},"message":"\u003cp\u003e\ns/and/an/\ns/LHS/RHS/\n\u003c/p\u003e","files":null},{"type":3,"author":{"id":"099af60226e2576bd4ff0f5c2614b710c745cab6"},"timestamp":1250055209,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDMxNTE=","github-url":"https://github.com/parrot/parrot/issues/446#issuecomment-3503151"},"message":"\u003cp\u003e\nReplying to \u003ca href=\"http://trac.parrot.org/parrot/ticket/903#comment:3\" title=\"Comment 3 for Ticket #903\"\u003eallison\u003c/a\u003e:\n\u003c/p\u003e\n\n\u003cblockquote class=\"citation\"\u003e\n\u003cp\u003e\n I'm okay with eliminating the Key PMC, but not the ['foo';'bar';'baz'] syntax. It's too useful. And, a custom NamespaceKey PMC is unnecessary, when all we really need is a FixedStringArray. This will have to wait until after 2.0, since it's a substantial deprecation.\n\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e\nYes. We have to wait until after 2.0.\n\u003c/p\u003e\n\n\u003cblockquote class=\"citation\"\u003e\n\u003cp\u003e\n  * Continue to parse ['foo';'bar';'baz'] everywhere it's currently parsed, but generate a FSA instead of a Key.\n\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e\nAgreed.\n\u003c/p\u003e\n\n\u003cblockquote class=\"citation\"\u003e\n\u003cp\u003e\n  * When used with and array or hash, ($I0 = $P0['foo';'bar'] or $P0['foo';'bar'] = $I0) they still call get_*_keyed' or 'set_*_keyed', but they pass it a simple FSA. Each PMC is free to decide how to handle array PMC keys internally (even flattening them into a single string \"foo\\0bar\\0baz\", if it wants to).\n\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e\nSlightly disagree. We can deprecate current handling of \"Keys\" in Hashes/Arrays and add \u003ctt\u003eget_hashvalue\u003c/tt\u003e VTABLE function to unified support of non-string keys.\n\u003c/p\u003e\n\n\u003cblockquote class=\"citation\"\u003e\n\u003cp\u003e\n  * The NameSpace PMCs will continue to treat them as they currently treat keys and arrays, as multi-level access to the namespace tree. But, it can simplify the code, since all complex keys will be arrays.\n\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e\nIndeed.\n\u003c/p\u003e\n\n\u003cblockquote class=\"citation\"\u003e\n\u003cp\u003e\n  * Do away with KEY types in opcodes (they're just PMCs). Any op that can be called with a key can be called equally well with another array PMC.\n\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e\nAgreed.\n\u003c/p\u003e\n\n\u003cblockquote class=\"citation\"\u003e\n\u003cp\u003e\n  * Make it possible to use key syntax on the LHS of assignment, as a cheap way to create a constant FSA:\n {{{\n $P0 = ['foo';'bar';'baz']\n }}}\n  * These could be used to initialize PMCs:\n {{{\n $P0 = ['key1';'value1';'key2';'value2']\n $P1 = new \"Frobisher\", $P0\n # or even:\n $P1 = new \"Frobisher\", ['key1';'value1';'key2';'value2']\n }}}\n\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e\nWhy swap arguments in \u003ctt\u003enew\u003c/tt\u003e?\n\u003c/p\u003e\n\n\u003cp\u003e\n--\nBacek\n\u003c/p\u003e","files":null},{"type":3,"author":{"id":"aef4977f5ea786238d7c9581a2f192f4adc3f39d"},"timestamp":1250104118,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDMxNTI=","github-url":"https://github.com/parrot/parrot/issues/446#issuecomment-3503152"},"message":"\u003cp\u003e\nas a general note, not even entirely related to this ticket, if we are parsing ['foo','bar','baz'] as an FSA, I think it might be a good opportunity to consider using similar syntax to specify multiple types of PMC aggregate literals also. So [1,2,3,4] could be an FIA, etc.\n\u003c/p\u003e","files":null},{"type":3,"author":{"id":"0782f66a529ccd24e18226f5eebab20a90bea166"},"timestamp":1250109907,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDMxNTM=","github-url":"https://github.com/parrot/parrot/issues/446#issuecomment-3503153"},"message":"\u003cp\u003e\nReplying to \u003ca href=\"http://trac.parrot.org/parrot/ticket/903#comment:6\" title=\"Comment 6 for Ticket #903\"\u003ewhiteknight\u003c/a\u003e:\n\u003c/p\u003e\n\n\u003cblockquote class=\"citation\"\u003e\n\u003cp\u003e\n as a general note, not even entirely related to this ticket, if we are parsing ['foo','bar','baz'] as an FSA, I think it might be a good opportunity to consider using similar syntax to specify multiple types of PMC aggregate literals also. So [1,2,3,4] could be an FIA, etc.\n\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e\nIf we're going down that route, what about [1,'2',3.0], etc.\n\u003c/p\u003e","files":null},{"type":3,"author":{"id":"d9b4aee65ce8c18d4a43eced1eecb0d154e1eebb"},"timestamp":1298271182,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDMxNTQ=","github-url":"https://github.com/parrot/parrot/issues/446#issuecomment-3503154"},"message":"\u003cp\u003e\nMy naive impression, when reviewing this ticket which has gone untouched in 19 months, is that we're not going to make any changes in this functionality in the near- to medium-term future.\n\u003c/p\u003e\n\n\u003cp\u003e\nCan we close the ticket?\n\u003c/p\u003e\n\n\u003cp\u003e\nThank you very much.\n\u003c/p\u003e\n\n\u003cp\u003e\nkid51\n\u003c/p\u003e","files":null},{"type":3,"author":{"id":"099af60226e2576bd4ff0f5c2614b710c745cab6"},"timestamp":1298271577,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDMxNTU=","github-url":"https://github.com/parrot/parrot/issues/446#issuecomment-3503155"},"message":"\u003cp\u003e\nHello.\n\u003c/p\u003e\n\n\u003cp\u003e\nI still want to deprecate current Keys. This is decision for The Architect.\n\u003c/p\u003e\n\n\u003cp\u003e\n--\nBacek\n\u003c/p\u003e","files":null},{"type":3,"author":{"id":"2da6485217cbb88ff96be8f3dcc7f9ae44cf6bf0"},"timestamp":1298565059,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDMxNTY=","github-url":"https://github.com/parrot/parrot/issues/446#issuecomment-3503156"},"message":"\u003cp\u003e\n24% of the vtables in src/extend_vtable.c are key-related, as a data point.\n\u003c/p\u003e","files":null},{"type":3,"author":{"id":"aef4977f5ea786238d7c9581a2f192f4adc3f39d"},"timestamp":1336525562,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDU1OTA2NDM=","github-url":"https://github.com/parrot/parrot/issues/446#issuecomment-5590643"},"message":"We cannot get rid of Keys entirely, because Keys are used in PCC (and maybe elsewhere) to create relatively efficient references to registers. I wouldn't want to make any change that makes PCC less efficient.","files":null}]}