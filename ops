{"version":1,"ops":[{"type":3,"author":{"id":"d9b4aee65ce8c18d4a43eced1eecb0d154e1eebb"},"timestamp":1247935448,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDI5MTM=","github-url":"https://github.com/parrot/parrot/issues/376#issuecomment-3502913"},"message":"13848 byte attachment from jkeenan\nat http://trac.parrot.org/parrot/raw-attachment/ticket/850/loadlib_dots.patch\n\n# ```Index: src/call_list.txt\n\n--- src/call_list.txt   (revision 9297)\n+++ src/call_list.txt   (working copy)\n@@ -319,3 +319,7 @@\n\n # crypt\n t       tt\n+\n+v  ip\n+v  pt\n+i  ptpPPi\n\n# Index: src/dynext.c\n\n--- src/dynext.c    (revision 9297)\n+++ src/dynext.c    (working copy)\n@@ -122,147 +122,202 @@\n\n /*\n\n-=item C\u003cstatic STRING *\n-get_path(Interp *interpreter, STRING *lib, void **handle, char **lib_name)\u003e\n+=item C\u003cstatic char *\n+filestem(char * full_name)\u003e\n\n-Return path and handle of a dynamic lib, setting lib_name to just the filestem\n-(i.e. without path or extension) as a freshly-allocated C string.\n+Returns the file stem, no path and no ext of the parameter full_name. stem is a\n+freshly allocated c string.\n\n =cut\n\n */\n\n-static STRING *\n-get_path(Interp _interpreter, STRING *lib, void *_handle, char **lib_name)\n+static char *\n+filestem(char \\* full_name)\n {\n-    STRING *path;\n-    char *full_name, *file_name, *file_w_ext = NULL;\n-    char *tmp_lib_name, *path_end, *ext_start;\n-    const char *err;\n-    char \\* stem;\n-    char \\* path_end;\n-    char \\* extension_loc;\n-    /\\* Find the pure library name, without path or extension.  */\n-    file_name = string_to_cstring(interpreter, lib);\n-    tmp_lib_name = file_name;\n-    path_end = strrchr(tmp_lib_name, '/');\n-    /\\* if there's path, remove it */\n-    path_end = strrchr(full_name, '/');\n   if (! path_end)\n-        path_end = strrchr(tmp_lib_name, '\\');\n-    if (path_end)\n-        tmp_lib_name = path_end+1;\n-    *lib_name = malloc(strlen(tmp_lib_name)+1);\n-    strcpy(*lib_name, tmp_lib_name);\n-    ext_start = strrchr(*lib_name, '.');\n-    if (ext_start)\n-        *ext_start = '\\0';\n-        path_end = strrchr(full_name, '\\');\n-    if (! path_end)\n-        path_end = full_name;\n-    else\n-        path_end++;\n-    /\\* path_end now points at the first part of full_name that isn't path */\n-    /*\n-     \\* first, try to add an extension to the file if it has none.\n-     */\n-    if (! ext_start) {\n-        file_w_ext = malloc(strlen(file_name) +\n-                strlen(PARROT_LOAD_EXT) + 1);\n-        strcpy(file_w_ext, file_name);\n-        strcat(file_w_ext, PARROT_LOAD_EXT);\n-        full_name = Parrot_locate_runtime_file(interpreter, file_w_ext,\n-    stem = strdup(path_end);\n  +\n-    /\\* remove extension if there is one */\n-    extension_loc = strrchr(stem, '.');\n-    if (extension_loc)\n-        *extension_loc = '\\0';\n-   \n-    return stem;\n  +}\n  +\n  +/*\n  +\n  +=item C\u003cstatic const char *\n  +try_load(Interp *interpreter, char *clib, void **handle, STRING **path, char **lib_name)\u003e\n  +\n  +Try loading a the library in clib out of library path or Parrot's runtime\n  +paths. Returns a pointer to err on failure, except not found and path is passed\n  +by reference and used to return path.  Otherwise behavior is the same as\n  +get_path\n  +\n  +=cut\n  +\n  +_/\n  +\n  +static const char *\n  +try_load(Interp *interpreter, char *clib, void *_handle, STRING *\\* path, char **lib_name)\n  +{\n-    char *runtime;\n  +\n-    *handle = Parrot_dlopen(clib);\n-    if (*handle) {\n-        *path = string_from_cstring(interpreter, clib, 0);\n-        *lib_name = filestem(clib);\n-    }\n-    else\n-    {\n-        const char *err = Parrot_dlerror();\n-        /\\* FIXME rm: need better way to ignore not found errors */\n-        if (err \u0026\u0026 !strstr(err, \"No such file or directory\"))\n-            return err;\n  +\n-        runtime = Parrot_locate_runtime_file(interpreter, clib,\n               PARROT_RUNTIME_FT_DYNEXT);\n-        if (full_name) {\n-            *handle = Parrot_dlopen(full_name);\n-        if (runtime)\n-        {\n-            _handle = Parrot_dlopen(runtime);\n           if (_handle) {\n-                path = string_from_cstring(interpreter, full_name, 0);\n-                string_cstring_free(file_name);\n-                string_cstring_free(full_name);\n-                string_cstring_free(file_w_ext);\n-                return path;\n-                *path = string_from_cstring(interpreter, runtime, 0);\n-                *lib_name = filestem(runtime);\n           }\n-            err = Parrot_dlerror();\n-            fprintf(stderr, \"Couldn't load '%s': %s\\n\",\n-                    full_name, err ? err : \"unknown reason\");\n-            string_cstring_free(file_name);\n-            string_cstring_free(full_name);\n-            string_cstring_free(file_w_ext);\n-            return NULL;\n-        }\n-        /*\n-         \\* then file.extension w/o prefix\n-         */\n-        *handle = Parrot_dlopen(file_w_ext);\n-        if (*handle) {\n-            path = string_from_cstring(interpreter, file_w_ext, 0);\n-            string_cstring_free(file_name);\n-            string_cstring_free(file_w_ext);\n-            return path;\n-        }\n-        string_cstring_free(file_w_ext);\n-        if (strcmp(PARROT_LOAD_EXT, PARROT_SHARE_EXT)) {\n-            file_w_ext = malloc(strlen(file_name) +\n-                    strlen(PARROT_SHARE_EXT) + 1);\n-            strcpy(file_w_ext, file_name);\n-            strcat(file_w_ext, PARROT_SHARE_EXT);\n-            full_name = Parrot_locate_runtime_file(interpreter, file_w_ext,\n-                    PARROT_RUNTIME_FT_DYNEXT);\n-            if (full_name) {\n-                *handle = Parrot_dlopen(full_name);\n-                if (*handle) {\n-                    path = string_from_cstring(interpreter, full_name, 0);\n-                    string_cstring_free(file_name);\n-                    string_cstring_free(file_w_ext);\n-                    return path;\n-                }\n-            else\n-            {\n               err = Parrot_dlerror();\n-                fprintf(stderr, \"Couldn't load '%s': %s\\n\",\n-                        full_name, err ? err : \"unknown reason\");\n-                string_cstring_free(file_name);\n-                string_cstring_free(file_w_ext);\n-                return NULL;\n-                /\\* FIXME rm: need better way to ignore not found errors */\n-                if (err \u0026\u0026 !strstr(err, \"No such file or directory\"))\n-                    return err;\n           }\n-            /*\n-             \\* then file.extension w/o prefix\n-             */\n-            *handle = Parrot_dlopen(file_w_ext);\n-            if (*handle) {\n-                path = string_from_cstring(interpreter, file_w_ext, 0);\n-                string_cstring_free(file_name);\n-                string_cstring_free(file_w_ext);\n-                return path;\n-            }\n-            string_cstring_free(file_w_ext);\n       }\n-        string_cstring_free(runtime);\n   }\n-    /*\n-     \\* finally, try the given file name as is.  we still use\n-     \\* Parrot_locate_runtime_file so that (a) relative pathnames are searched in\n-     \\* the standard locations, and (b) the angle of the slashes are adjusted as\n-     \\* required for non-Unix systems.\n-     */\n-    full_name = Parrot_locate_runtime_file(interpreter, file_name,\n-                                           PARROT_RUNTIME_FT_DYNEXT);\n-    if (full_name) {\n-        *handle = Parrot_dlopen(full_name);\n-        if (*handle) {\n-            path = string_from_cstring(interpreter, full_name, 0);\n-            string_cstring_free(file_name);\n-            string_cstring_free(full_name);\n-            return path;\n  +\n-    return NULL;\n  +}\n  +\n  +/*\n  +\n  +=item C\u003cstatic STRING *\n  +get_path(Interp *interpreter, STRING *lib, void **handle, char **lib_name)\u003e\n  +\n  +Return path and handle of a dynamic lib, setting lib_name to just the filestem\n  +(i.e. without path or extension) as a freshly-allocated C string.\n  +\n  +=cut\n  +\n  +_/\n  +\n  +static STRING *\n  +get_path(Interp *interpreter, STRING *lib, void *_handle, char **lib_name)\n  +{\n-    STRING *path = NULL;\n-    char *clib = NULL;\n-    char *clib_mod = NULL;\n-    char *clib_no_ext = NULL;\n-    unsigned int i;\n-    const char \\* err;\n  +\n-    clib = string_to_cstring(interpreter, lib);\n  +\n-    /\\* clear out dlerror in case it hasn't been */\n-    Parrot_dlerror();\n-   \n-    /\\* swap slashes if they're backwards */\n-    for (i = 0; i \u003c strlen(clib); i++)\n  +#ifdef WIN32\n-        if (clib[i] == '/')\n-            clib[i] = '\\';\n  +#else\n-        if (clib[i] == '\\')\n-            clib[i] = '/';\n  +#endif\n  +\n-    /\\* try to load unmodified */\n-    err = try_load(interpreter, clib, handle, \u0026path, lib_name);\n-    if (err)\n-    {\n-        fprintf(stderr, \"Couldn't load '%s': %s\\n\", clib, err);\n-        goto done;\n-    }\n-    if (path)\n-        goto done;\n  +\n-    /\\* FIXME rm: check for mem_sys_allocate failures and handle them the parrot\n-     \\* way */\n-   \n-    /\\* try to add extension */\n-    clib_mod = mem_sys_allocate(strlen(clib) + strlen(PARROT_LOAD_EXT) + 1);\n-    strcpy(clib_mod, clib);\n-    strcat(clib_mod, PARROT_LOAD_EXT);\n-    err = try_load(interpreter, clib_mod, handle, \u0026path, lib_name);\n-    if (err)\n-    {\n-        fprintf(stderr, \"Couldn't load '%s': %s\\n\", clib_mod, err);\n-        goto done;\n-    }\n-    if (path)\n-        goto done;\n  +\n-    /\\* if ext, remove it (since it's apparently wrong) and put right one on */\n-    string_cstring_free(clib_mod);\n-    clib_mod = NULL;\n-    clib_no_ext = strdup(clib);\n-    char *ext_loc = strrchr(clib_no_ext, '.');\n-    if (ext_loc) {\n-        *ext_loc = '\\0';\n-        clib_mod = mem_sys_allocate(strlen(clib_no_ext) +\n-                strlen(PARROT_LOAD_EXT) + 1);\n-        strcpy(clib_mod, clib_no_ext);\n-        strcat(clib_mod, PARROT_LOAD_EXT);\n-        err = try_load(interpreter, clib_mod, handle, \u0026path, lib_name);\n-        if (err)\n-        {\n-            fprintf(stderr, \"Couldn't load '%s': %s\\n\", clib_mod, err);\n-            goto done;\n       }\n-        if (path)\n-            goto done;\n   }\n-    /*\n-     \\* and on windows strip a leading \"lib\"\n-     \\* [shouldn't this happen in Parrot_locate_runtime_file instead?]\n-     */\n  -#ifdef WIN32\n-    if (memcmp(file_name, \"lib\", 3) == 0) {\n-        *handle = Parrot_dlopen(file_name + 3);\n-        if (*handle) {\n-            path = string_from_cstring(interpreter, file_name + 3, 0);\n-            string_cstring_free(file_name);\n-            return path;\n  +\n-    /\\* this doesn't work for lib's with path info or the wrong ext, but it's\n-     \\* just duplicating old behavior. it used to be wrapped in win32 ifdef's\n-     \\* but it doesn't hurt to try it */\n-    if (memcmp(clib, \"lib\", 3) == 0) {\n-        err = try_load(interpreter, clib + 3, handle, \u0026path, lib_name);\n-        if (err)\n-        {\n-            fprintf(stderr, \"Couldn't load '%s': %s\\n\", clib + 3, err);\n-            goto done;\n       }\n-        if (path)\n-            goto done;\n   }\n  -#endif\n-    err = Parrot_dlerror();\n-    fprintf(stderr, \"Couldn't load '%s': %s\\n\",\n-            file_name, err ? err : \"unknown reason\");\n-    string_cstring_free(file_name);\n-    return NULL;\n  +\n-    fprintf(stderr, \"Couldn't load '%s': No such file or directory\\n\", clib);\n  +\n  +done:\n-    string_cstring_free(clib);\n-    string_cstring_free(clib_mod);\n-    string_cstring_free(clib_no_ext);\n-    return path;\n  }\n  \n  /*\n  \n  # Index: t/pmc/nci_loadlib.t\n  \n  --- t/pmc/nci_loadlib.t (revision 0)\n  +++ t/pmc/nci_loadlib.t (revision 0)\n  @@ -0,0 +1,125 @@\n  +#! perl -w\n  +# Copyright: 2005 The Perl Foundation.  All Rights Reserved.\n  +# $Id: foo.t 8254 2005-06-02 14:20:39Z leo $\n  +\n  +=head1 NAME\n  +\n  +t/pmc/nci_loadlib.t - Test loadlib ability to load a library specified in\n  +various maners (name, file, w/extension, w/wrong extension, ...)\n  +\n  +=head1 SYNOPSIS\n  +\n-   % perl -Ilib t/pmc/nci_loadlib.t\n  +\n  +=head1 DESCRIPTION\n  +\n  +Tests loadlib library loading\n  +\n  +=cut\n  +\n  +use Parrot::Test;\n  +use Parrot::Config;\n  +\n  +# known exts\n  +my @exts = qw/.so .dll .dynlib .nothing/;\n  +# no ext\n  +push @exts, '';\n  +\n  +my @perms = ();\n  +\n  +# foo out of runtime and with rel win/unix paths (always runs)\n  +foreach (@exts)\n  +{\n-    push @perms, 'foo'.$_, 'runtime/parrot/dynext/foo'.$_,\n-        \"runtime\\parrot\\dynext\\foo\".$_;\n  +};\n  +\n  +# if libm is around use it from path and with full win/unix paths\n  +if (-e '/usr/lib/libm.so')\n  +{\n-    foreach (@exts)\n-    {\n-        push @perms, 'libm'.$_, '/usr/lib/libm'.$_, \"\\usr\\lib\\libm\".$_;\n-    };\n  +}\n  +\n  +# if gtk's lib happens to be around go ahead and test with it for the '.' tests\n  +# path and full win/unix\n  +if (-e '/usr/lib/libgtk-x11-2.0.so')\n  +{\n-    foreach (@exts)\n-    {\n-        push @perms, 'libgtk-x11-2.0'.$_, '/usr/lib/libgtk-x11-2.0'.$_,\n-            \"\\usr\\lib\\libgtk-x11-2.0\".$_;\n-    };\n  +}\n  +\n  +# +2 for the lib removal test, below\n  +plan tests =\u003e scalar (@perms) + 2;\n  +\n  +# run each of the above permutations constrcuted above\n  +foreach (@perms)\n  +{\n  +pir_output_is(\"\n  +\n  +.sub main\n-    .local pmc dynlib\n-    dynlib = loadlib '$_'\n-    unless dynlib goto FAILED\n-    print '42'\n-    goto DONE\n  +FAILED:\n-    print 'failed to load $_'\n  +DONE:\n-    end\n  +.end\n  +\n  +\", '42', 'load '.$_);\n  +}\n  +\n  +# test out leading lib removal, special b/c we have to have the correct ext\n  +pir_output_is(\"\n  +\n  +.sub main\n-    .local pmc dynlib\n-    .local pmc interp\n-    .local pmc conf\n-    .local string ext\n-    .local string libname\n  +\n-    .include 'iglobals.pasm'\n-    interp = getinterp\n-    conf = interp[.IGLOBALS_CONFIG_HASH]\n-    ext = conf['load_ext']\n  +\n-    libname = concat 'libfoo', ext\n-    dynlib = loadlib libname\n-    unless dynlib goto FAILED\n-    print '42'\n-    goto DONE\n  +FAILED:\n-    print 'failed to load '\n-    print libname\n  +DONE:\n-    end\n  +.end\n  +\n  +\", '42', 'load libfoo, lib removal');\n  +\n  +pir_output_is(\"\n  +\n  +.sub main\n-    .local pmc dynlib\n-    dynlib = loadlib 'something_that_should_never_exist'\n-    unless dynlib goto FAILED\n-    print '42'\n-    goto DONE\n  +FAILED:\n-    print 'failed to load something_that_should_never_exist'\n  +DONE:\n-    end\n  +.end\n  +\n  +\", \"Couldn't load 'something_that_should_never_exist': No such file or directory\n  +failed to load something_that_should_never_exist\",\n  +'fail to load non-existent');\n\n```\n```","files":null},{"type":3,"author":{"id":"d9b4aee65ce8c18d4a43eced1eecb0d154e1eebb"},"timestamp":1247953448,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDI5MTQ=","github-url":"https://github.com/parrot/parrot/issues/376#issuecomment-3502914"},"message":"\u003cp\u003e\nFinal (?) version of patch submitted by Ross McFarland in Sept 2005\n\u003c/p\u003e","files":null},{"type":3,"author":{"id":"d9b4aee65ce8c18d4a43eced1eecb0d154e1eebb"},"timestamp":1261211975,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDI5MTU=","github-url":"https://github.com/parrot/parrot/issues/376#issuecomment-3502915"},"message":"\u003cp\u003e\nReplying to \u003ca class=\"new ticket\" href=\"http://trac.parrot.org/parrot/ticket/850\" title=\"patch: Handle loadlib and libraries with '.' in the name (new)\"\u003ejkeenan\u003c/a\u003e:\n\u003c/p\u003e\n\n\u003cpre class=\"wiki\"\u003e\u0026gt;\n\u0026gt; Could someone -- particularly someone on Win32 --\ntake a look at this and determine:\n\u0026gt;\n\u0026gt; 1.  Is there still a problem needing resolution?\n\u0026gt;\n\u0026gt; 2.  Can the patch be reworked to provide a solution?\n\u003c/pre\u003e\u003cp\u003e\nCan anyone comment?  Thanks.\n\u003c/p\u003e","files":null},{"type":3,"author":{"id":"aef4977f5ea786238d7c9581a2f192f4adc3f39d"},"timestamp":1264477308,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDI5MTY=","github-url":"https://github.com/parrot/parrot/issues/376#issuecomment-3502916"},"message":"\u003cp\u003e\nBefore I start monkeying with this patch, do we even know for certain that there is still a problem with loading libraries that have a dot in the file name? Can we get a test case?\n\u003c/p\u003e","files":null},{"type":3,"author":{"id":"d9b4aee65ce8c18d4a43eced1eecb0d154e1eebb"},"timestamp":1264487129,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDI5MTc=","github-url":"https://github.com/parrot/parrot/issues/376#issuecomment-3502917"},"message":"\u003cp\u003e\nReplying to \u003ca href=\"http://trac.parrot.org/parrot/ticket/850#comment:3\" title=\"Comment 3 for Ticket #850\"\u003ewhiteknight\u003c/a\u003e:\n\u003c/p\u003e\n\n\u003cpre class=\"wiki\"\u003e\u0026gt; Before I start monkeying with this patch, do we even know\n\u0026gt; for certain that there is still a problem with loading\n\u0026gt; libraries that have a dot in the file name? Can we get a test case?\n\u003c/pre\u003e\u003cp\u003e\nMy thinking is:  If you have to ask that question, and if no one has complained about this in a long time, then we don't have a problem that needs addressing now.\n\u003c/p\u003e\n\n\u003cp\u003e\nRecommendation: closing the ticket and having whoever experiences this problem open up a new one.\n\u003c/p\u003e\n\n\u003cp\u003e\nThank you very much.\u003cbr /\u003e\nkid51\n\u003c/p\u003e","files":null},{"type":3,"author":{"id":"0782f66a529ccd24e18226f5eebab20a90bea166"},"timestamp":1264489361,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1MDI5MTg=","github-url":"https://github.com/parrot/parrot/issues/376#issuecomment-3502918"},"message":"\u003cpre class=\"wiki\"\u003eOn Mon, Jan 25, 2010 at 5:25 PM, Parrot \u0026lt;parrot-tickets@lists.parrot.org\u0026gt; wrote:\n\u0026gt; #850: Handle loadlib and libraries with '.' in the name\n\u0026gt; ---------------------+------------------------------------------------------\n\u0026gt;  Reporter:  jkeenan  |       Owner:  whiteknight\n\u0026gt;     Type:  patch    |      Status:  new\n\u0026gt;  Priority:  normal   |   Milestone:\n\u0026gt; Component:  library  |     Version:  1.3.0\n\u0026gt;  Severity:  medium   |    Keywords:\n\u0026gt;     Lang:           |       Patch:  new\n\u0026gt;  Platform:           |\n\u0026gt; ---------------------+------------------------------------------------------\n\u0026gt;\n\u0026gt; Comment(by jkeenan):\n\u0026gt;\n\u0026gt;  Replying to [comment:3 whiteknight]:\n\u0026gt;  {{{\n\u0026gt;  \u0026gt; Before I start monkeying with this patch, do we even know\n\u0026gt;  \u0026gt; for certain that there is still a problem with loading\n\u0026gt;  \u0026gt; libraries that have a dot in the file name? Can we get a test case?\n\u0026gt;  }}}\n\u0026gt;  My thinking is:  If you have to ask that question, and if no one has\n\u0026gt;  complained about this in a long time, then we don't have a problem that\n\u0026gt;  needs addressing now.\n\u0026gt;\n\u0026gt;  Recommendation: closing the ticket and having whoever experiences this\n\u0026gt;  problem open up a new one.\n\u0026gt;\n\u0026gt;  Thank you very much.[[BR]]\n\u0026gt;  kid51\n\u0026gt;\n\u0026gt; --\n\u0026gt; Ticket URL: \u0026lt;https://trac.parrot.org/parrot/ticket/850#comment:4\u0026gt;\n\u0026gt; Parrot \u0026lt;https://trac.parrot.org/parrot/\u0026gt;\n\u0026gt; Parrot Development\n\u0026gt; _______________________________________________\n\u0026gt; parrot-tickets mailing list\n\u0026gt; parrot-tickets@lists.parrot.org\n\u0026gt; http://lists.parrot.org/mailman/listinfo/parrot-tickets\n\u0026gt;\n-1: If someone opens a ticket, we shouldn't throw it out for the sole\nreason that it took us 4.5 years to get to it. (Sure, lots can happen\nin 4.5 years, but I don't see any of those mitigating factors here.)\nIf there isn't a test for this in the repository, we should add one to\navoid regressions. Then we can close the ticket as WFM.\n--\nWill \"Coke\" Coleda\n\u003c/pre\u003e","files":null}]}