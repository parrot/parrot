/*
** bit.ops
*/

VERSION = PARROT_VERSION;

=head1 NAME

bit.ops - Bitwise Operations

=head1 DESCRIPTION

Operations that deal with bits directly, either individually
or in groups.

The variant with an appended B<s> like B<bands> work on strings.

=over 4

=cut

###############################################################################

=item B<band>(inout INT, in INT)

=item B<band>(in PMC, in INT)

=item B<band>(in PMC, in PMC)

Set the bits of $1 according to the B<and> of the corresponding bits from $1 and $2.

=item B<band>(out INT, in INT, in INT)

=item B<band>(in PMC, in PMC, in INT)

=item B<band>(in PMC, in PMC, in PMC)

Set the bits of $1 according to the B<and> of the corresponding bits from $2 and $3.

=cut

inline op band(inout INT, in INT) :base_core {
  $1 &= $2;
  goto NEXT();
}

inline op band(in PMC, in INT) :base_core {
  $1->vtable->bitwise_and_int(interpreter, $1, $2, $1);
  goto NEXT();
}

inline op band(in PMC, in PMC) :base_core {
  mmd_dispatch_v_ppp(interpreter, $1, $2, $1, MMD_BAND);
/*  $1->vtable->bitwise_and(interpreter, $1, $2, $1);*/
  goto NEXT();
}

inline op band(out INT, in INT, in INT) :base_core {
  $1 = $2 & $3;
  goto NEXT();
}

inline op band(in PMC, in PMC, in INT) :base_core {
  $2->vtable->bitwise_and_int(interpreter, $2, $3, $1);
  goto NEXT();
}

inline op band(in PMC, in PMC, in PMC) :base_core {
  mmd_dispatch_v_ppp(interpreter, $2, $3, $1, MMD_BAND);
/*  $2->vtable->bitwise_and(interpreter, $2, $3, $1);*/
  goto NEXT();
}

=item B<bands>(inout STR, in STR)

=item B<bands>(in PMC, in STR)

=item B<bands>(in PMC, in PMC)

Set the bits of $1 according to the B<and> of the corresponding bits from $1 and $2.

=item B<bands>(out STR, in STR, in STR)

=item B<bands>(in PMC, in PMC, in STR)

=item B<bands>(in PMC, in PMC, in PMC)

Set the bits of $1 according to the B<and> of the corresponding bits from $2 and $3.

=cut

inline op bands(inout STR, in STR) :base_core {
  string_bitwise_and(interpreter, $1, $2, &$1);
  goto NEXT();
}

inline op bands(in PMC, in STR) :base_core {
  $1->vtable->bitwise_ands_str(interpreter, $1, $2, $1);
  goto NEXT();
}

inline op bands(in PMC, in PMC) :base_core {
  mmd_dispatch_v_ppp(interpreter, $1, $2, $1, MMD_SAND);
/*  $1->vtable->bitwise_ands(interpreter, $1, $2, $1);*/
  goto NEXT();
}

inline op bands(out STR, in STR, in STR) :base_core {
  $1 = string_bitwise_and(interpreter, $2, $3, NULL);
  goto NEXT();
}

inline op bands(in PMC, in PMC, in STR) :base_core {
  $2->vtable->bitwise_ands_str(interpreter, $2, $3, $1);
  goto NEXT();
}

inline op bands(in PMC, in PMC, in PMC) :base_core {
  mmd_dispatch_v_ppp(interpreter, $2, $3, $1, MMD_SAND);
/*  $2->vtable->bitwise_ands(interpreter, $2, $3, $1);*/
  goto NEXT();
}

########################################

=item B<bnot>(out INT, in INT)

=item B<bnot>(in PMC, in PMC)

Set the bits of $1 to the B<not> of the corresponding bits from $2.

=cut

inline op bnot(out INT, in INT) :base_core {
  $1 = ~ $2;
  goto NEXT();
}

inline op bnot(in PMC, in PMC) :base_core {
  $2->vtable->bitwise_not(interpreter, $2, $1);
  goto NEXT();
}

=item B<bnots>(out STR, in STR)

=item B<bnots>(in PMC, in PMC)

Set the bits of $1 to the B<not> of the corresponding bits from $2.

=cut

inline op bnots(out STR, in STR) :base_core {
  string_bitwise_not(interpreter, $2, &$1);
  goto NEXT();
}

inline op bnots(in PMC, in PMC) :base_core {
  $2->vtable->bitwise_nots(interpreter, $2, $1);
  goto NEXT();
}

########################################

=item B<bor>(inout INT, in INT)

=item B<bor>(in PMC, in INT)

=item B<bor>(in PMC, in PMC)

Set the bits of $1 according to the B<or> of the corresponding bits from $1 and $2.

=item B<bor>(out INT, in INT, in INT)

=item B<bor>(in PMC, in PMC, in INT)

=item B<bor>(in PMC, in PMC, in PMC)

Set the bits of $1 according to the B<or> of the corresponding bits from $2 and $3.

=cut

inline op bor(inout INT, in INT) :base_core {
  $1 |= $2;
  goto NEXT();
}

inline op bor(in PMC, in INT) :base_core {
  $1->vtable->bitwise_or_int(interpreter, $1, $2, $1);
  goto NEXT();
}

inline op bor(in PMC, in PMC) :base_core {
  mmd_dispatch_v_ppp(interpreter, $1, $2, $1, MMD_BOR);
/*  $1->vtable->bitwise_or(interpreter, $1, $2, $1);*/
  goto NEXT();
}

inline op bor(out INT, in INT, in INT) :base_core {
  $1 = $2 | $3;
  goto NEXT();
}

inline op bor(in PMC, in PMC, in INT) :base_core {
  $2->vtable->bitwise_or_int(interpreter, $2, $3, $1);
  goto NEXT();
}

inline op bor(in PMC, in PMC, in PMC) :base_core {
  mmd_dispatch_v_ppp(interpreter, $2, $3, $1, MMD_BOR);
/*  $2->vtable->bitwise_or(interpreter, $2, $3, $1);*/
  goto NEXT();
}

=item B<bors>(inout STR, in STR)

=item B<bors>(in PMC, in STR)

=item B<bors>(in PMC, in PMC)

Set the bits of $1 according to the B<or> of the corresponding bits from $1 and $2.

=item B<bors>(out STR, in STR, in STR)

=item B<bors>(in PMC, in PMC, in STR)

=item B<bors>(in PMC, in PMC, in PMC)

Set the bits of $1 according to the B<or> of the corresponding bits from $2 and $3.

=cut

inline op bors(inout STR, in STR) :base_core {
  string_bitwise_or(interpreter, $1, $2, &$1);
  goto NEXT();
}

inline op bors(in PMC, in STR) :base_core {
  $1->vtable->bitwise_ors_str(interpreter, $1, $2, $1);
  goto NEXT();
}

inline op bors(in PMC, in PMC) :base_core {
  mmd_dispatch_v_ppp(interpreter, $1, $2, $1, MMD_SOR);
/*  $1->vtable->bitwise_ors(interpreter, $1, $2, $1);*/
  goto NEXT();
}

inline op bors(out STR, in STR, in STR) :base_core {
  $1 = string_bitwise_or(interpreter, $2, $3, NULL);
  goto NEXT();
}

inline op bors(in PMC, in PMC, in STR) :base_core {
  $2->vtable->bitwise_ors_str(interpreter, $2, $3, $1);
  goto NEXT();
}

inline op bors(in PMC, in PMC, in PMC) :base_core {
  mmd_dispatch_v_ppp(interpreter, $2, $3, $1, MMD_SOR);
/*  $2->vtable->bitwise_ors(interpreter, $2, $3, $1);*/
  goto NEXT();
}
########################################

=item B<shl>(inout INT, in INT)

=item B<shl>(in PMC, in INT)

=item B<shl>(in PMC, in PMC)

Shift left $1 by $2 bits.

=item B<shl>(out INT, in INT, in INT)

=item B<shl>(in PMC, in PMC, in PMC)

=item B<shl>(in PMC, in PMC, in INT)

Set $1 to the value of $2 shifted left by $3 bits.

=cut

inline op shl(inout INT, in INT) :base_core {
  $1 <<= $2;
  goto NEXT();
}

inline op shl(in PMC, in PMC) :base_core {
  mmd_dispatch_v_ppp(interpreter, $1, $2, $1, MMD_BSL);
/*  $1->vtable->bitwise_shl(interpreter, $1, $2, $1);*/
  goto NEXT();
}

inline op shl(in PMC, in INT) :base_core {
  $1->vtable->bitwise_shl_int(interpreter, $1, $2, $1);
  goto NEXT();
}

inline op shl(out INT, in INT, in INT) :base_core {
  $1 = $2 << $3;
  goto NEXT();
}

inline op shl(in PMC, in PMC, in PMC) :base_core {
  mmd_dispatch_v_ppp(interpreter, $2, $3, $1, MMD_BSL);
/*  $2->vtable->bitwise_shl(interpreter, $2, $3, $1);*/
  goto NEXT();
}

inline op shl(in PMC, in PMC, in INT) :base_core {
  $2->vtable->bitwise_shl_int(interpreter, $2, $3, $1);
  goto NEXT();
}

########################################

=item B<shr>(inout INT, in INT)

=item B<shr>(in PMC, in INT)

=item B<shr>(in PMC, in PMC)

Shift right $1 by $2 bits.

=item B<shr>(out INT, in INT, in INT)

=item B<shr>(in PMC, in PMC, in PMC)

=item B<shr>(in PMC, in PMC, in INT)

Set $1 to the value of $2 shifted right by $3 bits.

=cut

inline op shr(inout INT, in INT) :base_core {
  $1 >>= $2;
  goto NEXT();
}

inline op shr(in PMC, in PMC) :base_core {
  mmd_dispatch_v_ppp(interpreter, $1, $2, $1, MMD_BSR);
/*  $1->vtable->bitwise_shr(interpreter, $1, $2, $1);*/
  goto NEXT();
}

inline op shr(in PMC, in INT) :base_core {
  $1->vtable->bitwise_shr_int(interpreter, $1, $2, $1);
  goto NEXT();
}

inline op shr(out INT, in INT, in INT) :base_core {
  $1 = $2 >> $3;
  goto NEXT();
}

inline op shr(in PMC, in PMC, in PMC) :base_core {
  mmd_dispatch_v_ppp(interpreter, $2, $3, $1, MMD_BSR);
/*  $2->vtable->bitwise_shr(interpreter, $2, $3, $1);*/
  goto NEXT();
}

inline op shr(in PMC, in PMC, in INT) :base_core {
  $2->vtable->bitwise_shr_int(interpreter, $2, $3, $1);
  goto NEXT();
}

########################################
=item B<lsr>(inout INT, in INT)

Logically shift $1 right by $2.

=item B<lsr>(out INT, in INT, in INT)

Set $1 to the value of $2 logically shifted right by $3 bits.

=cut

inline op lsr(out INT, in INT) :base_core {
  LVALUE_CAST(UINTVAL, $1) >>= $2;
  goto NEXT();
}

inline op lsr(out INT, in INT, in INT) :base_core {
  $1 = (INTVAL)((UINTVAL)$2 >> $3);
  goto NEXT();
}

########################################

=item B<bxor>(inout INT, in INT)

=item B<bxor>(in PMC, in INT)

=item B<bxor>(in PMC, in PMC)

Set the bits of $1 according to the B<xor> of the corresponding bits from $1 and $2.

=item B<bxor>(out INT, in INT, in INT)

=item B<bxor>(in PMC, in PMC, in INT)

=item B<bxor>(in PMC, in PMC, in PMC)

Set the bits of $1 according to the B<xor> of the corresponding bits from $2 and $3.

=cut

inline op bxor(inout INT, in INT) :base_core {
  $1 ^= $2;
  goto NEXT();
}

inline op bxor(in PMC, in INT) :base_core {
  mmd_dispatch_v_pip(interpreter, $1, $2, $1, MMD_BXOR_INT);
  /* $1->vtable->bitwise_xor_int(interpreter, $1, $2, $1); */
  goto NEXT();
}

inline op bxor(in PMC, in PMC) :base_core {
  mmd_dispatch_v_ppp(interpreter, $1, $2, $1, MMD_BXOR);
  /* $1->vtable->bitwise_xor(interpreter, $1, $2, $1); */
  goto NEXT();
}

inline op bxor(out INT, in INT, in INT) :base_core {
  $1 = $2 ^ $3;
  goto NEXT();
}

inline op bxor(in PMC, in PMC, in INT) :base_core {
  mmd_dispatch_v_pip(interpreter, $2, $3, $1, MMD_BXOR_INT);
  /* $2->vtable->bitwise_xor_int(interpreter, $2, $3, $1); */
  goto NEXT();
}

inline op bxor(in PMC, in PMC, in PMC) :base_core {
  mmd_dispatch_v_ppp(interpreter, $2, $3, $1, MMD_BXOR);
  /* $2->vtable->bitwise_xor(interpreter, $2, $3, $1); */
  goto NEXT();
}

=item B<bxors>(inout STR, in STR)

=item B<bxors>(in PMC, in STR)

=item B<bxors>(in PMC, in PMC)

Set the bits of $1 according to the B<xor> of the corresponding bits from $1 and $2.

=item B<bxors>(out STR, in STR, in STR)

=item B<bxors>(in PMC, in PMC, in STR)

=item B<bxors>(in PMC, in PMC, in PMC)

Set the bits of $1 according to the B<xor> of the corresponding bits from $2 and $3.

=cut

inline op bxors(inout STR, in STR) :base_core {
  string_bitwise_xor(interpreter, $1, $2, &$1);
  goto NEXT();
}

inline op bxors(in PMC, in STR) :base_core {
  $1->vtable->bitwise_xors_str(interpreter, $1, $2, $1);
  goto NEXT();
}

inline op bxors(in PMC, in PMC) :base_core {
  mmd_dispatch_v_ppp(interpreter, $1, $2, $1, MMD_SXOR);
/*  $1->vtable->bitwise_xors(interpreter, $1, $2, $1);*/
  goto NEXT();
}

inline op bxors(out STR, in STR, in STR) :base_core {
  $1 = string_bitwise_xor(interpreter, $2, $3, NULL);
  goto NEXT();
}

inline op bxors(in PMC, in PMC, in STR) :base_core {
  $2->vtable->bitwise_xors_str(interpreter, $2, $3, $1);
  goto NEXT();
}

inline op bxors(in PMC, in PMC, in PMC) :base_core { 
  mmd_dispatch_v_ppp(interpreter, $2, $3, $1, MMD_SXOR);
/* $2->vtable->bitwise_xors(interpreter, $2, $3, $1);*/
  goto NEXT();
}

=back

=cut

###############################################################################

=head1 COPYRIGHT

Copyright (C) 2001-2004 The Perl Foundation.  All rights reserved.

=head1 LICENSE

This program is free software. It is subject to the same license
as the Parrot interpreter itself.

=cut
