/*
Copyright: 2001-2003 The Perl Foundation.  All Rights Reserved.
$Id$

=head1 NAME

classes/pytype.pmc - Python Class

=head1 DESCRIPTION

These are the vtable functions for the Python Type base class (i.e.,
methods you would expect to see on Python Classes

=head2 Methods

=over 4

=cut

*/

#include "parrot/parrot.h"

/* cache of classes referenced */
static INTVAL dynclass_PyClass;
static INTVAL dynclass_PyString;
static INTVAL dynclass_PyType;
static STRING *BASES;
static STRING *CLASS;
static STRING *INIT;
static STRING *NAME;
static STRING *NEW;

struct parrot_regs_t *
Parrot_PyClass_runops_fromc(Parrot_Interp interpreter, PMC *sub);

pmclass PyType dynpmc group python_group {

/*

=item C<void class_init()>

Class initialization. Caches the type id of various PMCs because
they will be used frequently here.

=cut

*/

    void class_init() {
        if (pass) {
            dynclass_PyClass = Parrot_PMC_typenum(INTERP, "PyClass");
            dynclass_PyString = Parrot_PMC_typenum(INTERP, "PyString");
            dynclass_PyType = Parrot_PMC_typenum(INTERP, "PyType");
            BASES = const_string(INTERP, "__bases__");
            CLASS = const_string(INTERP, "__class__");
            INIT  = const_string(INTERP, "__init__");
            NAME  = const_string(INTERP, "__name__");
            NEW   = const_string(INTERP, "__new__");
        }
    }

/*

=item C<void add_method(STRING *method_name, PMC *sub)>

Store the method as a property of this class.

=cut

*/

    void add_method(STRING *method_name, PMC *sub_pmc) {
        VTABLE_setprop(INTERP, SELF, method_name, sub_pmc);
    }

/*

=item C<PMC *find_method(STRING *method_name)>

Looks up the method for C<*method_name> and returns it.

=cut

*/

    PMC* find_method(STRING* method_name) {
        PMC *parent;

        PMC *method = VTABLE_getprop(INTERP, SELF, method_name);
        if (method && VTABLE_defined(INTERP, method)) {
            if (Interp_flags_TEST(interpreter, PARROT_TRACE_FLAG)) {
                PIO_eprintf(interpreter, "# Found %Ss method %Ss on %Ss\n",
                   method->vtable->whoami, method_name, 
                   VTABLE_name(INTERP, SELF));
            }

            return method;
        }

        parent = VTABLE_getprop(INTERP, SELF, BASES);
        if (parent && VTABLE_defined(INTERP, parent)) {
            return VTABLE_find_method(INTERP, parent, method_name);
        }

        return 0;
    }

/*

=item C<PMC* get_attr_str(STRING *name)>

Return attribute named C<name>.

=cut

*/

    PMC* get_attr_str(STRING* idx) {
        PMC *parent;

        PMC *attr = VTABLE_getprop(INTERP, SELF, idx);
        if (attr && VTABLE_defined(INTERP, attr)) return attr;

        parent = VTABLE_getprop(INTERP, SELF, BASES);
        if (parent && VTABLE_defined(INTERP, parent)) {
            attr = VTABLE_get_attr_str(INTERP, parent, idx);
        }

        if (!attr || !VTABLE_defined(INTERP, attr)) {
            STRING *message;
            message = Parrot_sprintf_c(INTERP, "AttributeError: %s",
                string_to_cstring(INTERP, idx));
            real_exception(INTERP, NULL, E_AttributeError,
                string_to_cstring(INTERP, message));
        }

        return attr;
    }

/*

=item C<void* invoke(void* next)>

Pythonic object constructor.

=cut

*/

    void* invoke(void* next) {
        PMC *object, *init, *new;

        new = VTABLE_find_method(INTERP, SELF, NEW);
        init = VTABLE_find_method(INTERP, SELF, INIT);

        if (new || init) {
            int i = REG_INT(3)++;
            while (i--) 
                REG_PMC(6+i)=REG_PMC(5+i);
        }

        if (new) {
            struct parrot_regs_t *bp;
            struct Parrot_Context ctx;
            save_context(interpreter, &ctx);
            INTERP->ctx.current_object = SELF;
            REG_PMC(2) = REG_PMC(5) = SELF;
            REG_STR(0) = NEW;
            bp = Parrot_PyClass_runops_fromc(INTERP, new);
            object = BP_REG_PMC(bp,5);
            restore_context(interpreter, &ctx);
        }
        else {
            object = pmc_new(interpreter, dynclass_PyClass);
        }

        VTABLE_setprop(INTERP, object, CLASS, REG_PMC(0));

        if (init) {
            struct Parrot_Context ctx;
            save_context(interpreter, &ctx);
            INTERP->ctx.current_object = object;
            REG_PMC(2) = REG_PMC(5) = object;
            REG_STR(0) = INIT;
            Parrot_PyClass_runops_fromc(INTERP, init);
            restore_context(interpreter, &ctx);
        }

        REG_INT(0) = REG_INT(3) = 1;
        REG_INT(1) = REG_INT(2) = REG_INT(4) = 0;
        REG_PMC(5) = object;
        return next;
    }

/*

=item C<PMC* subclass(STRING *name)>

Create a subclass of the given class.  Note that this merely creates
a new PyType... all the interesting details that make it a subclass
need to be filled in.

=cut

*/

    PMC* subclass(STRING* name) {
        PMC *ret = pmc_new(INTERP, dynclass_PyType);
        PMC *nameprop = pmc_new(INTERP, dynclass_PyString);
        VTABLE_set_string_native(INTERP, nameprop, name);
        VTABLE_setprop(INTERP, ret, NAME, nameprop);
        VTABLE_setprop(INTERP, ret, BASES, SELF);
        return ret;
    }

/*

=item C<STRING *name()>

Returns the name of this class.

*/


    STRING* name() {
        PMC *name = VTABLE_getprop(INTERP, SELF, NAME);
        return VTABLE_get_string(INTERP, name);
    }

/*

=back

=cut

*/

}

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
 * vim: expandtab shiftwidth=4:
*/
