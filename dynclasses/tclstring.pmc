/* TclString.pmc
 *  Copyright: 2001-2003 The Perl Foundation.  All Rights Reserved.
 *  CVS Info
 *     $Id$
 *  Overview:
 *     These are the vtable functions for the TclString base class
 *  Data Structure and Algorithms:
 *  History:
 *  Notes:
 *     Please remove unneeded entries.
 *  References:
 */

#include "parrot/parrot.h"

static INTVAL dynclass_TclString;
static INTVAL dynclass_TclFloat;
static INTVAL dynclass_TclInt;
static STRING *true, *false, *yes, *no;

pmclass TclString extends TclObject dynpmc group tcl_group {

    void class_init () {
        PMC *string_anchor;
        INTVAL fixedstringarray_typenum;
        if (pass) {
            dynclass_TclString = Parrot_PMC_typenum(INTERP,"TclString");
            dynclass_TclInt    = Parrot_PMC_typenum(INTERP,"TclInt");
            dynclass_TclFloat  = Parrot_PMC_typenum(INTERP,"TclFloat");
            true  = string_from_const_cstring(INTERP, "true",4);
            false = string_from_const_cstring(INTERP, "false",5);
            yes   = string_from_const_cstring(INTERP, "yes",3);
            no    = string_from_const_cstring(INTERP, "no",2);
            fixedstringarray_typenum =
              Parrot_PMC_typenum(INTERP, "FixedStringArray");
            string_anchor = pmc_new(INTERP,fixedstringarray_typenum);
            VTABLE_set_integer_native(INTERP,string_anchor,4);
            VTABLE_set_string_keyed_int(INTERP,string_anchor,0,true);
            VTABLE_set_string_keyed_int(INTERP,string_anchor,1,false);
            VTABLE_set_string_keyed_int(INTERP,string_anchor,2,yes);
            VTABLE_set_string_keyed_int(INTERP,string_anchor,3,no);
	    dod_register_pmc(INTERP, string_anchor);
        }
    }

    void init () {
        PMC_str_val(SELF) = string_make_empty(INTERP,enum_stringrep_one,0);
        PObj_custom_mark_SET(SELF);
    }

    void mark () {
        if (PMC_str_val(SELF))
            pobject_lives(INTERP, (PObj *)PMC_str_val(SELF));
    }

    PMC* clone () {
        PMC* dest = pmc_new_noinit(INTERP, SELF->vtable->base_type);
        PObj_custom_mark_SET(dest);
        PMC_str_val(dest) = string_copy(INTERP,PMC_str_val(SELF));
        return dest;

    }

   STRING* get_repr() {
     return SELF.get_string();
   }

    STRING* get_string () {
	return (STRING*) PMC_str_val(SELF);
    }

    INTVAL get_integer () {
        STRING* s = (STRING*) PMC_str_val(SELF);
        return string_to_int(INTERP, s);
    }

    FLOATVAL get_number () {
        STRING* s = (STRING*) PMC_str_val(SELF);
        return string_to_num(INTERP, s);
    }


    INTVAL get_bool () {

        STRING* s = (STRING*) PMC_str_val(SELF);
        if (!string_compare(INTERP,s,true)) {
          return 1;
        } else if (!string_compare(INTERP,s,false)) {
          return 0;
        } else if (!string_compare(INTERP,s,yes)) {
          return 1;
        } else if (!string_compare(INTERP,s,no)) {
          return 0;
        }

        return 0; /* XXX Throw exception about invalid boolean type. */
    }

    INTVAL is_same (PMC* other) {
        STRING* s1 = (STRING*)PMC_str_val(SELF);
        STRING* s2 = (STRING*)PMC_str_val(other);
        return (INTVAL)( other->vtable == SELF->vtable &&
                          s1->bufused   == s2->bufused  &&
            (memcmp(s1->strstart,PObj_bufstart(s2),(size_t)s1->bufused)==0));
    }

    void set_integer_native (INTVAL value) {
        DYNSELF.morph(dynclass_TclInt);
        DYNSELF.set_integer_native(value);
    }

    void set_number_native (FLOATVAL value) {
        DYNSELF.morph(dynclass_TclFloat);
        DYNSELF.set_number_native(value);
    }

    void set_string_native (STRING * value) {
        PMC_str_val(SELF) = string_set(INTERP, PMC_str_val(SELF), value);
    }

    void set_string_same (PMC * value) {
        PMC_str_val(SELF) = string_set(INTERP, PMC_str_val(SELF),
        PMC_str_val(value));
    }

    # math ops? keep or kill?
    # bitwise ops

    void concatenate (PMC* value, PMC* dest) {
        STRING* s = PMC_str_val(SELF);
        VTABLE_morph(INTERP, dest, TclString_type);
        PMC_str_val(dest) =
            string_concat(INTERP, s, VTABLE_get_string(INTERP, value), 0);
    }


    voiid concatenate_native (STRING* value, PMC* dest) {
        STRING* s = PMC_str_val(SELF);
        VTABLE_morph(INTERP, dest, TclString_type);
        PMC_str_val(dest) = string_concat(INTERP, s, value, 0);
    }

    INTVAL is_equal (PMC* value) {
        return (INTVAL)( 0 == string_compare(INTERP,
                                             PMC_str_val(SELF),
                                             VTABLE_get_string(INTERP, value)
                                            ));
    }

    INTVAL cmp(PMC* value) {
        return string_compare(INTERP, PMC_str_val(SELF),
                  VTABLE_get_string(INTERP, value));
    }

    void repeat (PMC* value, PMC* dest) {
        DYNSELF.morph(TclString_type);
        VTABLE_morph(INTERP, dest, TclString_type);
        PMC_str_val(dest) =
           string_repeat(INTERP, PMC_str_val(SELF),
                         (UINTVAL)VTABLE_get_integer(INTERP, value), NULL
                        );
    }

    void repeat_int (INTVAL value, PMC* dest) {
        DYNSELF.morph(TclString_type);
        VTABLE_morph(INTERP, dest, TclString_type);
        PMC_str_val(dest) = string_repeat(INTERP,
        PMC_str_val(SELF), (UINTVAL)value, NULL);
    }


    void substr (INTVAL offset, INTVAL length, PMC* dest) {
        DYNSELF.morph(TclString_type);
        VTABLE_morph(INTERP, dest, TclString_type);
        PMC_str_val(dest) = string_substr(INTERP,
            PMC_str_val(SELF), offset, length, NULL, 0);
    }

    STRING* substr_str (INTVAL offset, INTVAL length) {
        return string_substr(INTERP, PMC_str_val(SELF), offset,
            length, NULL, 0);
    }

}
