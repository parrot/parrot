/*
Copyright: 2001-2003 The Perl Foundation.  All Rights Reserved.
$Id$

=head1 NAME

classes/pyfunc.pmc - Python Function

=head1 DESCRIPTION

This class implements a Python Function, i.e. a Parrot Closure.

=head2 Methods

=over 4

=cut

*/

#include "parrot/parrot.h"
#include "pyconsts.h"

static STRING *FUNC_ARGS;
static STRING *FUNC_DEFAULTS;
static STRING *FUNC_VARARGS;

pmclass PyFunc extends Closure dynpmc group python_group {

/*

=item C<void class_init()>

Class initialization. Caches the type id of various PMCs because
they will be used frequently here.

=cut

*/

    void class_init() {
        if (pass) {
            FUNC_ARGS = const_string(INTERP, "func_args");
            FUNC_VARARGS = const_string(INTERP, "func_varargs");
            FUNC_DEFAULTS = const_string(INTERP, "func_defaults");
        }
    }


/*

=item C<void init()>

Create an (empty) list of function arguments

=cut

*/

    void init () {
        PMC *func_args;
        SUPER();
        func_args = pmc_new(INTERP, PyBuiltin_PyList);
        VTABLE_setprop(INTERP, SELF, FUNC_ARGS, func_args);
    }

/*

=item C<PMC *find_method(STRING *method_name)>

Implement __call__ methods by redirecting to one's self, after having
resolved all of the parameters into a single positional list.  Note:
at this time, functions with a maximum of 11 arguments are supported.

=cut

TODO: error checking (e.g., missing, duplicate or extra arguments)

XXX: the __call__ support is bad, bad, bad.  Consider the following
conversation: Do you have a __call__ method?  Sure!  Meanwhile I hope
you don't mind me rearranging your registers.  I hope you are intending
to call the method real soon...  Have a nice day!

The right way to accomplish this would be to create a method-wrapper
object and return it.  And this overhead could be avoided in the normal
case if there were a VTABLE_call_method entry which unambiguously
involved a find_method in anticipation of an invoke.

*/

    PMC* find_method(STRING* method_name) {
        if (0 == string_compare(INTERP, method_name, PyString_call)) {
            PMC *args = REG_PMC(5);
            PMC *keywords = REG_PMC(6);
            PMC *func_args = VTABLE_getprop(INTERP, SELF, FUNC_ARGS);
            PMC *func_defaults = VTABLE_getprop(INTERP, SELF, FUNC_DEFAULTS);
            INTVAL j;

            INTVAL n = VTABLE_elements(INTERP, func_args);
            REG_INT(3) = n;

            /* fill in defaults */
            if (func_defaults && VTABLE_defined(INTERP, func_defaults)) {
                INTVAL nd = VTABLE_elements(INTERP, func_defaults);
                for (j=n-nd; j<n && j<11; j++) {
                    REG_PMC(5+j) = VTABLE_get_pmc_keyed_int(INTERP,
                        func_defaults, j+nd-n);
                }
            }

            /* fill in positional arguments */
            if (VTABLE_get_bool(INTERP, args)) {
                INTVAL np = VTABLE_elements(INTERP, args);
                for (j=0; j<np && j<11; j++) {
                    REG_PMC(5+j) = VTABLE_get_pmc_keyed_int(INTERP, args, j);
                }
            }

            /* fill in keyword arguments */
            if (VTABLE_get_bool(INTERP, keywords)) {
                for (j=0; j<n && j<11; j++) {
                    PMC *name = VTABLE_get_pmc_keyed_int(INTERP, func_args, j);
                    if (VTABLE_exists_keyed(INTERP, keywords, name)) {
                        REG_PMC(5+j) =
                            VTABLE_get_pmc_keyed(INTERP, keywords, name);
                    }
                }
            }

            return SELF;
        }

        return SUPER(method_name);
    }

/*

=item C<PMC* get_attr_str(STRING *name)>

Return attribute named C<name>.

=cut

*/

    PMC* get_attr_str(STRING* idx) {
        PMC *attr = VTABLE_getprop(INTERP, SELF, idx);
        if (attr && VTABLE_defined(INTERP, attr)) return attr;
        return VTABLE_find_method(INTERP, SELF, idx);
    }

/*

=item C<PMC *get_class()>

Return the class of this object.

=cut

*/

    PMC* get_class() {
        return PyBuiltin_PyFunc_class;
    }

/*

=item C<STRING *get_string()>

Return the representation of this object.

=cut

*/

    STRING* get_string() {
        STRING *res;

        STRING *name = const_string(INTERP, "(unnamed)");
        PMC *ret = VTABLE_getprop(INTERP, SELF, PyString_name);
        if (ret && VTABLE_defined(INTERP, ret))
            name = VTABLE_get_string(INTERP, ret);

        res = string_from_cstring(INTERP, "<function ", 0);
        res = string_append(INTERP, res, name, 0);
        res = string_append(INTERP, res, const_string(INTERP, " at "), 0);
        res = string_append(INTERP, res,
            Parrot_sprintf_c(INTERP, "%#x", (INTVAL) SELF), 0);
        res = string_append(INTERP, res, const_string(INTERP, ">"), 0);

        return res;
    }

/*

=item C<void* invoke(void* next)>

Invoke a function.  Defaults are filled in first.

=cut

*/

    void* invoke(void* next) {
        PMC *func_args = VTABLE_getprop(INTERP, SELF, FUNC_ARGS);
        PMC *func_varargs = VTABLE_getprop(INTERP, SELF, FUNC_VARARGS);
        INTVAL n = VTABLE_elements(INTERP, func_args);
        INTVAL j;

        if (n > REG_INT(3)) {
            PMC *func_defaults = VTABLE_getprop(INTERP,SELF,FUNC_DEFAULTS);

            if (func_defaults && VTABLE_defined(INTERP, func_defaults)) {
                INTVAL nd = VTABLE_elements(INTERP, func_defaults);
                for (j=n-nd; j<n && j<11; j++) {
                    if (j >= REG_INT(3)) {
                        REG_PMC(5+j) = VTABLE_get_pmc_keyed_int(INTERP, 
                            func_defaults, j+nd-n);
                    }
                }

                REG_INT(3) = n;
            }
        }

        if (func_varargs && VTABLE_defined(INTERP, func_varargs)) {
            PMC *varargs = pmc_new(INTERP, PyBuiltin_PyTuple);
            VTABLE_set_integer_native(INTERP, varargs, REG_INT(3)+1-n);
            for (j=n-1; j<REG_INT(3) && j<11; j++) {
                VTABLE_set_pmc_keyed_int(INTERP,varargs,j+1-n,REG_PMC(5+j));
            }

            if (n<11) {
                REG_PMC(5+n-1) = varargs;
                REG_INT(3) = n;
            }
        }

        return SUPER(next);
    }

/*

=item C<void set_integer_keyed_int(INTVAL key, INTVAL* value)>

Add an argument to the func_args list

=cut

*/

    void set_integer_keyed_int (INTVAL key, INTVAL value) {
        PMC *func_args = VTABLE_getprop(INTERP, SELF, FUNC_ARGS);
        VTABLE_set_integer_keyed_int(INTERP, func_args, key, value);
    }

/*

=item C<void set_string_keyed_int(INTVAL key, STRING* value)>

Add an argument to the func_args list

=cut

*/

    void set_string_keyed_int (INTVAL key, STRING* value) {
        PMC *func_args = VTABLE_getprop(INTERP, SELF, FUNC_ARGS);
        VTABLE_set_string_keyed_int(INTERP, func_args, key, value);
    }

/*

=item C<void set_string_native(STRING *value)>

Set the function name.

=cut

*/

    void set_string_native (STRING * value) {
        PMC *nameprop = pmc_new(INTERP, PyBuiltin_PyString);
        VTABLE_set_string_native(INTERP, nameprop, value);
        VTABLE_setprop(INTERP, SELF, PyString_name, nameprop);
    }

/*

=item C<void "__get__"()>

Return a bound method object.

=cut

*/

    METHOD PMC* __get__ (PMC *self, PMC *obj, PMC *type) {
        PMC *ret = pmc_new(INTERP, PyBuiltin_PyBoundMeth);
        VTABLE_set_pointer(INTERP, ret, self);
        VTABLE_set_pmc(INTERP, ret, obj);
        return ret;
    }

/*

=back

=cut

*/

}

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
 * vim: expandtab shiftwidth=4:
*/
