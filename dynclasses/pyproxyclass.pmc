/*
Copyright: 2001-2003 The Perl Foundation.  All Rights Reserved.
$Id$

=head1 NAME

classes/pyproxyclass.pmc - Python Proxy Class

=head1 DESCRIPTION

Forward method and attribute requests onto the object that is
being proxied.

=head2 Methods

=over 4

TODO: handle attributes.

=cut

*/

#include "parrot/parrot.h"
#include "pyconsts.h"

pmclass PyProxyClass extends PyType dynpmc group python_group {

/*

=item C<void init()>

Initializes the instance.

=cut

*/

    void init () {
        PObj_custom_mark_SET(SELF);
        PMC_struct_val(SELF) = 0;
    }

/*

=item C<void mark()>

Marks the hash as live.

=cut

*/

    void mark () {
        if (PMC_struct_val(SELF))   /* forwarder */
            pobject_lives(INTERP, (PObj *) PMC_struct_val(SELF));
    }

/*

=item C<PMC *find_method(STRING *method_name)>

Looks up the method for C<*method_name> and returns it.

=cut

*/

    PMC* find_method(STRING* method_name) {
        PMC *method = SUPER(method_name);

        if (method) {
            PMC *forwarder = pmc_new(INTERP, PyBuiltin_PyProxyClass);
            PMC_struct_val(forwarder) = method;
            method = forwarder;
        }

        return method;
    }

/*

=item C<void* invoke(void *next)>

Invoke the real method

=cut

*/

    void* invoke(void *next) {
        PMC *proxy = INTERP->ctx.current_object;

        if (!PMC_struct_val(SELF))
            internal_exception(1, "Invoke() called on a PyProxyClass object");

        INTERP->ctx.current_object = REG_PMC(2) =  REG_PMC(5) = 
            VTABLE_getprop(INTERP, proxy, PyString_proxy);

        if (Interp_flags_TEST(interpreter, PARROT_TRACE_FLAG)) {
            PIO_eprintf(interpreter, "# Invoking %Ss on %Ss via proxy\n",
               REG_STR(0), REG_PMC(2)->vtable->whoami); 
        }

        return VTABLE_invoke(INTERP, (PMC*)PMC_struct_val(SELF), next);
    }

 
/*

=back

=cut

*/

}

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
 * vim: expandtab shiftwidth=4:
*/
