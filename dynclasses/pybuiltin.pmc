/*
Copyright: 2001-2003 The Perl Foundation.  All Rights Reserved.
$Id$

=head1 NAME

classes/pybuiltin.pmc - Python "builtin" Functions

=head1 DESCRIPTION

This class implements the Python "builtin" Functions.

=head2 Methods

=over 4

=cut

*/

#include "parrot/parrot.h"

/* cache of classes referenced */
static INTVAL dynclass_PyObject;
static INTVAL dynclass_PyInt;
static INTVAL dynclass_PyFloat;

static STRING *HEX;
static STRING *OCT;

extern PMC* Parrot_PerlHash_get_iter(Interp* interpreter, PMC* pmc);

pmclass PyBuiltin dynpmc group python_group {
/*

=item C<void class_init()>

Class initialization. Caches the type id of various PMCs because
they will be used frequently here.

=cut

*/

    void class_init() {
        if (pass) {
            dynclass_PyObject  = Parrot_PMC_typenum(INTERP, "PyObject");
            dynclass_PyInt     = Parrot_PMC_typenum(INTERP, "PyInt");
            dynclass_PyFloat   = Parrot_PMC_typenum(INTERP, "PyFloat");

            HEX = string_from_cstring(INTERP, "__hex__", 0);
            OCT = string_from_cstring(INTERP, "__oct__", 0);
        }
    }

/*

=item C<PMC* "__load__"()>

This is unabashed hackery scaffolding.  It copies all the builtins 
functions from globals to lexicaly scoped variables.

=cut

The implementation is highly dependent on the internals of globals and 
ordered hashes, and will break should either of them change - of course,
any such breakage should show up quickly in the unit tests.

Longer term, either globals should expose an iterator by which one
can discover keys (needed to support a Python "dir" like function), or
enter_nci_method should create these as locals to begin with.

*/

    METHOD void __load__() {
        STRING *class;
        PMC *stash, *iter, *pad;
        HashBucket *b;
        INTVAL j, n;

        /* Find all PyBuiltin "nci" methods */
        class = string_from_cstring(INTERP, "PyBuiltin", 0);
        stash = interpreter->globals->stash_hash;
        b = hash_get_bucket(INTERP, (Hash*) PMC_struct_val(stash), class);
        if (!b) internal_exception(1, "Can't find PyBuiltins");

        /* For each, extract the key and item, and store in the scratchpad */
        stash = b->value;
        iter = Parrot_PerlHash_get_iter(INTERP, stash);
        n = VTABLE_elements(INTERP, stash);
        pad = scratchpad_get_current(interpreter);
        for (j = 0; j < n; ++j) {
            STRING *key = VTABLE_shift_string(INTERP, iter);
            PMC *item = VTABLE_get_pmc_keyed_str(INTERP, stash, key);
            scratchpad_store_by_name(INTERP, pad, 0, key, item);
        }

    }


/*

=item C<PMC* "abs"()>

Returns the absolute value of an object

=cut

*/

    METHOD PMC* abs(PMC *object) {
        PMC * ret = pmc_new(INTERP, dynclass_PyObject);
        VTABLE_absolute(INTERP, object, ret);
        return ret;
    }

/*

=item C<PMC* "cmp"(PMC *value1, PMC *value2)>

Returns the result of comparing C<*value1> with C<*value2).

=cut

*/

    METHOD PMC* cmp(PMC *value1, PMC *value2) {
        PMC * ret = pmc_new(INTERP, dynclass_PyInt);
        VTABLE_set_integer_native(INTERP, ret,
            mmd_dispatch_i_pp(INTERP, value1, value2, MMD_CMP));
        return ret;
    }

/*

=item C<PMC* "float"()>

Returns the float value of C<value>.

=cut

*/

    METHOD PMC* float(PMC *value) {
        PMC * ret = pmc_new(INTERP, dynclass_PyFloat);
        FLOATVAL fvalue = VTABLE_get_number(INTERP, value);
        VTABLE_set_number_native(INTERP, ret, fvalue);
        return ret;
    }

/*

=item C<PMC* "hex"(PMC *value)>

Returns the hex representation of C<value>.

=cut

*/

    METHOD PMC* hex(PMC *value) {
        PMC * meth = VTABLE_find_method(INTERP, value, HEX);
        REG_INT(3) = 0;
        REG_PMC(2) = value;
        VTABLE_invoke(INTERP, meth, REG_PMC(1));
        return REG_PMC(5);
    }

/*

=item C<PMC* "int"(PMC *value)>

Returns the integer value of C<value>.

=cut

*/

    METHOD PMC* int(PMC *value) {
        PMC * ret = pmc_new(INTERP, dynclass_PyInt);
        INTVAL ivalue = VTABLE_get_integer(INTERP, value);
        VTABLE_set_integer_native(INTERP, ret, ivalue);
        return ret;
    }

/*

=item C<PMC* "oct"(PMC *value)>

Returns the octal representation of C<value>.

=cut

*/

    METHOD PMC* oct(PMC *value) {
        PMC * meth = VTABLE_find_method(INTERP, value, OCT);
        REG_INT(3) = 0;
        REG_PMC(2) = value;
        VTABLE_invoke(INTERP, meth, REG_PMC(1));
        return REG_PMC(5);
    }

/*

=back

=cut

*/

}

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
 * vim: expandtab shiftwidth=4:
*/
