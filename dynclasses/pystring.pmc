/*
Copyright: 2001-2003 The Perl Foundation.  All Rights Reserved.
$Id$

=head1 NAME

classes/pystring.pmc - Python String

=head1 DESCRIPTION

C<PyString> extends C<PyObject> to provide Python string behaviour.

=head2 Methods

=over 4

=cut

*/

#include "parrot/parrot.h"

/* cache of classes referenced */
static INTVAL dynclass_PyIter;
static INTVAL dynclass_PyString;
static INTVAL dynclass_PyTuple;

pmclass PyString extends PyObject dynpmc group python_group {

/*

=item C<void class_init()>

Class initialization. Caches the type id of various PMCs because
they will be used frequently here.

=cut

*/

    void class_init() {
        if (pass) {
            dynclass_PyIter    = Parrot_PMC_typenum(INTERP, "PyIter");
            dynclass_PyString  = Parrot_PMC_typenum(INTERP, "PyString");
            dynclass_PyTuple   = Parrot_PMC_typenum(INTERP, "PyTuple");
        }
    }

/*

=item C<void add(PMC *value, PMC *dest)>

Concatenates C<*value> to the string and returns the result in C<*dest>.

=cut

*/

    void add (PMC * value, PMC* dest) {
        SELF.concatenate(value, dest);
    }

/*

=item C<INTVAL cmp(PMC *value)>

Returns the result of comparing the string with C<*value>.

=cut

*/

    INTVAL cmp(PMC* value) {
        return string_compare(INTERP, PMC_str_val(SELF),
                  VTABLE_get_string(INTERP, value));
    }

/*

=item C<void concatenate(PMC *value, PMC *dest)>

Concatenates the string and the stringified form of C<*value> and
return the result in C<*dest>, morphing it to a PyString if required.

=cut

*/

    void concatenate (PMC* value, PMC* dest) {
        STRING* s = PMC_str_val(SELF);
        VTABLE_morph(INTERP, dest, dynclass_PyString);
        PMC_str_val(dest) =
            string_concat(INTERP, s, VTABLE_get_string(INTERP, value), 0);
    }

/*

=item C<INTVAL elements ()>

Return length of the string.

=cut

*/

    INTVAL elements () {
        return string_length(INTERP, PMC_str_val(SELF));
    }

/*

=item C<INTVAL get_bool()>

Returns the pyboolean value of the string.

=cut

*/

    INTVAL get_bool () {
        return string_bool(INTERP, PMC_str_val(SELF));
    }

/*

=item C<PMC* get_iter (PMC *key)>

Return a new iterator for this string.

=cut

*/

    PMC* get_iter () {
        PMC *iter = pmc_new_init(interpreter, dynclass_PyIter, SELF);
        PMC *key =  pmc_new(interpreter, enum_class_Key);
        PMC_struct_val(iter) = key;
        PObj_get_FLAGS(key) |= KEY_integer_FLAG;
        PMC_int_val(key) = 0;
        if (!string_length(INTERP, PMC_str_val(SELF)))
            PMC_int_val(key) = -1;
        return iter;
    }

/*

=item C<INTVAL get_integer()>

Returns the integer representation of the string.

=cut

*/

    INTVAL get_integer () {
        STRING *s = (STRING*) PMC_str_val(SELF);
        return string_to_int(INTERP, s);
    }

/*

=item C<FLOATVAL get_number()>

Returns the floating-point representation of the string.

=cut

*/

    FLOATVAL get_number () {
        STRING *s = (STRING*) PMC_str_val(SELF);
        return string_to_num(INTERP, s);
    }

/*

=item C<PMC *get_pmc_keyed_int(INTVAL key)>

Extracts a given character from the string.

=cut

*/

    PMC* get_pmc_keyed (PMC *key) {
        if (key->vtable->base_type == enum_class_Slice) {
            PMC *slice = Parrot_py_make_slice(INTERP, SELF, key);
            parrot_range_t *range = PMC_struct_val(slice);
            INTVAL start = RVal_int(range->start);
            INTVAL end   = RVal_int(range->end);
            PMC * ret = pmc_new(INTERP, dynclass_PyString);
            PMC_str_val(ret) = string_substr(INTERP, PMC_str_val(SELF), 
                start, end-start, NULL, 0);
            return ret;
        }
        else
            return DYNSELF.get_pmc_keyed_int(PMC_int_val(key));
    }

/*

=item C<PMC *get_pmc_keyed_int(INTVAL key)>

Extracts a given character from the string.

=cut

*/

    PMC* get_pmc_keyed_int (INTVAL key) {
        PMC * ret = pmc_new(INTERP, dynclass_PyString);
        PMC_str_val(ret) =
            string_substr(INTERP, PMC_str_val(SELF), key, 1, NULL, 0);
        return ret;
    }

/*

=item C<STRING* get_repr()>

Returns pythons string repr (w/o any escaping, just single quotes around)

=cut

*/

    STRING* get_repr() {
        STRING *s = DYNSELF.get_string();
        STRING *repr;
        INTVAL start = 0;
        STRING *q = const_string(INTERP, "'");
        STRING *dq = const_string(INTERP, "\"");
        STRING *bs = const_string(INTERP, "\\");
        INTVAL i_q;
        INTVAL i_bs;

        i_q = string_str_index(INTERP, s, q, 0);
        i_bs = string_str_index(INTERP, s, bs, 0);

        if ((i_q > 0) && (string_str_index(INTERP, s, dq, 0) < 0)) {
            q = dq;
            i_q = -1;
        }

        if (PObj_get_FLAGS(s) & PObj_private7_FLAG)
            repr = string_copy(INTERP, const_string(INTERP, "u'"));
        else
            repr = string_copy(INTERP, q);

        if ((i_q < 0) && (i_bs < 0))
            string_append(INTERP, repr, s, 0);
        else {
           STRING *sub;
           while ((i_q >= 0) || (i_bs >= 0)) {
               if ((i_bs >= 0) && ((i_q < 0) || (i_bs < i_q))) {
                   sub = string_substr(INTERP, s, start, i_bs-start, NULL, 0);
                   start = i_bs;
                   i_bs = string_str_index(INTERP, s, bs, start+1);
               }
               else {
                   sub = string_substr(INTERP, s, start, i_q-start, NULL, 0);
                   start = i_q;
                   i_q = string_str_index(INTERP, s, q, start+1);
               }

               string_append(INTERP, repr, sub, 0);
               string_append(INTERP, repr, bs, 0);
           }

           i_q = string_length(INTERP, s);
           sub = string_substr(INTERP, s, start, i_q-start, NULL, 0);
           string_append(INTERP, repr, sub, 0);
        }

        repr = string_append(INTERP, repr, q, 0);
        return repr;
    }

/*
=item C<STRING *get_string()>

=cut
*/

    STRING* get_string () {
        return (STRING*) PMC_str_val(SELF);
    }

/*

=item C<INTVAL is_equal(PMC *value)>

The C<==> operation.

=cut

*/

    INTVAL is_equal (PMC* value) {
        return (INTVAL)( 0 == string_compare(INTERP,
            PMC_str_val(SELF),
            VTABLE_get_string(INTERP, value)
            ));
    }

/*

=item C<PMC* "lower"()>

downcase this string

=cut

*/

    METHOD PMC* lower() {
        STRING *s = string_downcase(INTERP, PMC_str_val(SELF));
        PMC *ret = pmc_new(INTERP, dynclass_PyString);
        VTABLE_set_string_native(INTERP, ret, s);
        return ret;
    }

/*

=item C<void modulus(PMC *value, PMC *dest)>

Interpolates a formatstring with a set of values.

=cut

*/

    void modulus (PMC* value, PMC* dest) {
        PMC *ar = value;
        /*
         * SELF is formatstring, value = argument array or item
         */
        /* TODO: figure out why C<DOES> doesn't work for dynclasses */
        if (value->vtable->base_type != enum_class_FixedPMCArray) {
            /* not a tuple - make one */
            ar = pmc_new(INTERP, dynclass_PyTuple);
            VTABLE_set_integer_native(INTERP, ar, 1);
            VTABLE_set_pmc_keyed_int( INTERP, ar, 0, value);
        }
        VTABLE_set_string_native(INTERP, dest,
                Parrot_psprintf(INTERP, PMC_str_val(SELF), ar));
    }

/*

=item C<void set_pmc(PMC *value)>

Sets the PMC C<*value>, calling the appropriate C<set_*> method
according to the type of C<*value>.

=cut

*/

    void set_pmc (PMC* value) {
        if (SELF->vtable->base_type == value->vtable->base_type) {
            DYNSELF.set_string_same(value);
        }
        else {
            DYNSELF.morph(value->vtable->base_type);
            DYNSELF.set_pmc(value);
        }
    }

/*

=item C<void set_string_native(STRING *value)>

Sets the string's value to the value of the specified Parrot string.

=cut

*/

    void set_string_native (STRING * value) {
        PMC_str_val(SELF) = value;
    }

/*

=item C<void set_string_same(PMC *value)>

Sets the string's value to the value of the specified C<PyString>.

=cut

*/

    void set_string_same (PMC * value) {
        PMC_str_val(SELF) = string_set(INTERP, PMC_str_val(SELF),
        PMC_str_val(value));
    }

/*

=back

=cut

*/

}

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
 * vim: expandtab shiftwidth=4:
*/
