/*
Copyright: 2001-2003 The Perl Foundation.  All Rights Reserved.
$Id$

=head1 NAME

classes/pyproxytype.pmc - Python Proxy Type

=head1 DESCRIPTION

This is the type that you get when you subclass a non-PyClass
(i.e., a builtin PyObject, like PyInt).

Invoking instances of this type (which is Python's way of
instantiating instances) actually causes two objects to be created:
one of type PyClass (the "proxy"), and one of intended class
(the "real object").

The one "trick" is that the an additional parent is inserted into
the inheritance hierarchy of type PyProxyClass.  The sole function of
PyProxyClass is to delegate of all method and attribute calls back onto
the real object.

The combination of PyClass, PyProxyClass, and PyObject allows subclasses
of builtins to redefine methods.  This is because PyClass knows how to
translate Parrot calls (like "get_string") into Python methods (like
"__str__"), find_method on PyClass knows how to look up the inheritance
chain, and having a PyProxyClass on the top of the chain knows how to
forward such method talls to a PyObject, which in turn knows how to
map Python method calls onto Parrot calls.

While this seems like a lot of work, lets consider all the cases:

  "pure" builtins (not subclassed by Python):
     * operations like indexing and addition are done at Parrot
       speeds with no lookaside to see if methods have been
       overridden.
     * explict calls to methods (such as __str__) are relatively
       rare, but are handled by an NCI method which maps between 
       Python and Parrot syntax and semantics.

  "pure" Python classes (base class is object):
     * operations like addition are relatively rare, but are
       accomplished by an NCI method which maps between Python
       and Parrot syntax and semantics.
     * explicit calls to methods directly check the set of
       properties (currently a hash) for each class.

  "mixed" classes (base class is builin - relatively rare):
     * operations like indexing and addition require a
       mapping to Python method names, an inheritance search,
       and mapping back to Parrot method names.
     * explicit calls to methods require only the ProxyClass and
       a mapping to Parrot methods.

=head2 Methods

=over 4

=cut

*/

#include "parrot/parrot.h"

static INTVAL dynclass_PyClass;
static INTVAL dynclass_PyString;
static INTVAL dynclass_PyProxyClass;
static INTVAL dynclass_PyProxyType;
static STRING *BASES;
static STRING *CLASS;
static STRING *INIT;
static STRING *NAME;
static STRING *NEW;
static STRING *PROXY;

struct parrot_regs_t *
Parrot_PyClass_runops_fromc(Parrot_Interp interpreter, PMC *sub);

pmclass PyProxyType extends PyType dynpmc group python_group {

/*

=item C<void class_init()>

Class initialization. Caches the type id of various PMCs because
they will be used frequently here.

=cut

*/

    void class_init() {
        if (pass) {
            dynclass_PyProxyClass = Parrot_PMC_typenum(INTERP, "PyProxyClass");
            dynclass_PyProxyType = Parrot_PMC_typenum(INTERP, "PyProxyType");
            dynclass_PyClass = Parrot_PMC_typenum(INTERP, "PyClass");
            dynclass_PyString = Parrot_PMC_typenum(INTERP, "PyString");
            BASES = const_string(INTERP, "__bases__");
            CLASS = const_string(INTERP, "__class__");
            INIT  = const_string(INTERP, "__init__");
            NAME  = const_string(INTERP, "__name__");
            NEW   = const_string(INTERP, "__new__");
            PROXY = const_string(INTERP, "__proxy__");
        }
    }


/*

=item C<void* invoke(void *next)>

Create a new object and proxy.  Note: invokes C<invoke> on the
object without touching any parrot registers... this enables
initializers with arguments to be run.

=cut

*/

    void* invoke(void *next) {
        PMC *object_class, *proxy, *object, *init, *new;

        object_class = VTABLE_getprop(INTERP, SELF, PROXY);
        if (!object_class || !VTABLE_defined(INTERP, object_class))
            object_class = SELF;

        new = VTABLE_find_method(INTERP, SELF, NEW);
        init = VTABLE_find_method(INTERP, SELF, INIT);
        if (new || init) {
            int i = REG_INT(3)++;
            while (i--)
                REG_PMC(6+i)=REG_PMC(5+i);
        }

        if (new) {
            struct parrot_regs_t *bp;
            struct Parrot_Context ctx;
            save_context(interpreter, &ctx);
            INTERP->ctx.current_object = SELF;
            REG_PMC(2) = REG_PMC(5) = SELF;
            REG_STR(0) = NEW;
            bp = Parrot_PyClass_runops_fromc(INTERP, new);
            object = BP_REG_PMC(bp,5);
            restore_context(interpreter, &ctx);
        }
        else {
            object = pmc_new(INTERP, object_class->vtable->base_type);
        }

        if (object_class == SELF)
            proxy = object;
        else {
            proxy = pmc_new(interpreter, dynclass_PyClass);
            VTABLE_setprop(INTERP, proxy, CLASS, REG_PMC(0));
            VTABLE_setprop(INTERP, proxy, PROXY, object);
        }

        if (init) {
            struct Parrot_Context ctx;
            save_context(interpreter, &ctx);
            INTERP->ctx.current_object = proxy;
            REG_PMC(2) = REG_PMC(5) = proxy;
            REG_STR(0) = INIT;
            Parrot_PyClass_runops_fromc(INTERP, init);
            restore_context(interpreter, &ctx);
        }

        REG_INT(0) = REG_INT(3) = 1;
        REG_INT(1) = REG_INT(2) = REG_INT(4) = 0;
        REG_PMC(5) = proxy;
        return next;
    }

/*

=item C<PMC* subclass(STRING *name)>

Create a subclass of the given class.  Note that this merely creates
a new PyType... all the interesting details that make it a subclass
need to be filled in.

=cut

*/

    PMC* subclass(STRING* name) {
        PMC *newclass = pmc_new(INTERP, dynclass_PyProxyType);
        PMC *proxy = VTABLE_getprop(INTERP, SELF, PROXY);
        PMC *nameprop = pmc_new(INTERP, dynclass_PyString);

        if (proxy && VTABLE_defined(INTERP, proxy)) {
            /* proxy is already set up */
            VTABLE_setprop(INTERP, newclass, BASES, SELF);
            VTABLE_setprop(INTERP, newclass, PROXY, proxy);
        }
        else {
            /* need to create a proxy class */
            PMC *proxy_class = pmc_new(INTERP, dynclass_PyProxyClass);
            VTABLE_setprop(INTERP, proxy_class, BASES, SELF);
            VTABLE_setprop(INTERP, newclass, BASES, proxy_class);
            VTABLE_setprop(INTERP, newclass, PROXY, SELF);
        }

        VTABLE_set_string_native(INTERP, nameprop, name);
        VTABLE_setprop(INTERP, newclass, NAME, nameprop);

        return newclass;
    }

/*

=back

=cut

*/

}

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
 * vim: expandtab shiftwidth=4:
*/
