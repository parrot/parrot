# Copyright: 2001-2005 The Perl Foundation.  All Rights Reserved.
# $Id$

=head1 NAME

dynclasses/build.pl - Build script for dynamic PMCs 

=head1 DESCRIPTION

This file is generated by F<config/gen/makefiles.pl> from
F<config/gen/makefiles/dynclasses_pl.in>. 
This script is used for building dynamic PMCs.

=cut

use strict;

use File::Copy qw(copy);

# qq[] isn't guaranteed to work, but it's safer than "" as some platforms
# (eg FreeBSD) have ""s embedded in their substution values. q[] is used in
# some places as Win32 paths have \'s in, which qq[] treats as escape sequences.
# Config stuff
our $CC = qq[${cc} -c];
our $LD = qq[${ld}];
our $LDFLAGS = qq[${ldflags} ${ld_debug}];
our $LD_LOAD_FLAGS = qq[${ld_load_flags}];
our $PERL = q[${perl}];
our $LOAD_EXT = qq[${load_ext}];
our $O = qq[${o}];
our $LIBPARROT = qq[../src/extend${o}];
    # XXX: ultimately, this should be replaced with:
    #  $LIBPARROT = qq[-L../blib/lib -lparrot];
our $CFLAGS = qq[${ccflags} ${cc_debug} ${ccwarn} ${cc_hasjit} ${cg_flag} ${gc_flag}];

# Here comes some stuff for Win32.
our $PATHQUOTE = '';
if ($^O eq 'MSWin32') {
    # Paths need quoting as they may contain spaces.
    $PATHQUOTE = '"';
    
    # Also need various libraries in the link line.
    my $extraLibs = '${blib_lib_libparrot_a} ${libs} ${icu_shared}';
    $extraLibs =~ s/blib/..\\blib/g;
    $extraLibs =~ s/\Q$(A)\E/.lib/g;
    $LD_LOAD_FLAGS =~ s/(-def:)/$extraLibs $1..\\/;
}

# PMC2C Config
our $PMC2C = "$PERL $PATHQUOTE" . q[${build_dir}${slash}classes${slash}pmc2c2.pl] . $PATHQUOTE;

# Actual commands
sub compile_cmd {
    my ($target, $source) = @_;

    return
        "$CC $CFLAGS " .
        "${cc_o_out}" . $target . " " .
        "-I" . $PATHQUOTE . '${build_dir}${slash}include' . $PATHQUOTE . " " .
        "-I" . $PATHQUOTE . '${build_dir}${slash}classes' . $PATHQUOTE . " " .
        $source;
};

sub partial_link_cmd {
    my ($target, $libs, $sources) = @_;

    my $liblist;
    if ($^O =~ /mswin32/i) {
      $liblist = join( ' ', map { "$_.lib" } keys %$libs );
    } else {
      $liblist = join( ' ', map { "-l$_" } keys %$libs );
    }

    return
        "$LD $LDFLAGS $LD_LOAD_FLAGS $liblist $LIBPARROT ".
        "${ld_out}" . $target . " " .
        join(" ", @$sources);
}

our $NOW = time();

################### MAIN PROGRAM ################

my ($mode, @pmcs) = @ARGV;

if ($mode eq 'generate') {
    # Convert X.pmc -> X.dump and X.c and also create any lib-GROUP.c files

    generate_dump($_) foreach (@pmcs);
    generate_c($_) foreach (@pmcs);

    my ($group_files, $group_libs, $pmc_group, $pmc_libs) = 
        gather_groups_and_libs(@pmcs);

    while (my ($group, $pmcs) = each %$group_files) {
        my @pmcfiles = map { "$_.pmc" } @$pmcs;
        if (needs_build("$group.c", @pmcfiles)) {
            run("$PMC2C --library $group --c " . join(" ",@pmcfiles))
              or die "pmc2c library creation failed ($?)\n";
        }
    }
} 
elsif ($mode eq 'compile') {
    my ($group_files, $group_libs, $pmc_group, $pmc_libs) = 
        gather_groups_and_libs(@pmcs);

    # Convert X.c -> X.o for all X.c
    compile($_) foreach (@pmcs);

    # lib-GROUP.c
    for my $group (keys %$group_files) {
        compile("$group", "lib-$group")
          or die "compile $group.c failed ($?)\n";
    }
} 
elsif ($mode eq 'linklibs') {
    my ($group_files, $group_libs, $pmc_group, $pmc_libs) = 
        gather_groups_and_libs(@pmcs);

    # Convert lib-GROUP.so + A.so + B.so ... -> GROUP.so
    while (my ($group, $pmcs) = each %$group_files) {
        partial_link($group, $group_libs->{$group}, [ "lib-$group", @$pmcs ] )
          or die "partial link of $group failed ($?)\n";
    }

    # Link non-grouped PMCs individually
    my @ungrouped_pmcs = grep { ! exists $pmc_group->{$_} } @pmcs;
    partial_link($_, $pmc_libs->{$_}, [ $_ ] ) foreach (@ungrouped_pmcs);
} 
elsif ($mode eq 'copy') {
    # Copy *.so -> destination, where destination is the first
    # argument, given as --destination=DIRECTORY
    shift(@pmcs) =~ /--destination=(.*)/
      or die "copy command requires destination";
    my $dest = $1;

    my ($group_files, $group_libs, $pmc_group, $pmc_libs) = 
        gather_groups_and_libs(@pmcs);
    my @ungrouped_pmcs = grep { ! exists $pmc_group->{$_} } @pmcs;

    foreach (@ungrouped_pmcs, keys %$group_files) {
        copy("$_$LOAD_EXT", $dest) or die "Copy $_$LOAD_EXT failed ($?)\n";
    }
}
else {
    die "invalid command '$mode'\nmust be one of generate, compile, linklibs, or copy\n";
}

sub run {
    print join(" ", @_), "\n";

    return system(@_) == 0;
}

# XXX: ordering of libs might be crucial
sub gather_groups_and_libs {
    my @pmcs = @_;

    my ( %group_files, %group_libs, %pmc_group, %pmc_libs );
    for my $pmc (@pmcs) {
        our $class;
        require "$pmc.dump";
 
        # there can be many libs
        my %libs = %{ $class->{flags}{lib} || {} };
        $pmc_libs{$pmc} = \%libs;

        # There should be at most a single group
        my $group = $class->{flags}{group}
          or next;
        ($group) = keys %$group;
        $pmc_group{$pmc} = $group;
        push @{ $group_files{$group} }, $pmc;
        $group_libs{$group} ||= {};
        foreach my $lib ( keys %libs ) {
            $group_libs{$group}->{lib} = 1;
        }
    }

    return (\%group_files, \%group_libs, \%pmc_group, \%pmc_libs);
}

sub modtime {
    my $ago = (-M shift);

    if (defined $ago) {
        return $NOW - $ago;
    } else {
        return;
    }
}

sub needs_build {
    my ($target, @sources) = @_;

    my $target_mod = modtime($target)
      or return 1;
    for my $source (@sources) {
        return 1 if modtime($source) > $target_mod;
    }

    return 0;
}

sub generate_dump {
    my ($pmc) = @_;

    if (needs_build("$pmc.dump", "$pmc.pmc")) {
        run("$PMC2C --dump $pmc.pmc")
          or die "pmc2c dump failed ($?)\n";
    }
}

sub generate_c {
    my ($pmc) = @_;

    if (needs_build("$pmc.c", "$pmc.pmc")) {
        run("$PMC2C --c $pmc.pmc")
          or die "pmc2c code generation failed ($?)\n";
    }
}

sub compile {
    my ($src_stem, $dest_stem) = @_;

    $dest_stem ||= $src_stem;
    if (needs_build("$dest_stem$O", "$src_stem.c")) {
        run(compile_cmd("$dest_stem$O", "$src_stem.c"))
          or die "compile $src_stem.c failed ($?)\n";
    }
    else {
        1;
    }
}

sub partial_link {
    my ($group, $libs, $stems) = @_;

    my @sources = map { "$_$O" } @$stems;
    if (needs_build("$group$LOAD_EXT", @sources)) {
        run(partial_link_cmd("$group$LOAD_EXT", $libs, \@sources))
          or die "partial link $group$LOAD_EXT failed ($?)\n";
    }
    else {
        1;
    }
}
