=head1 TITLE

sdl_types.imc - PIR interface to SDL types

=head1 SYNOPSIS

	.include "library/sdl.pasm"
	.include "library/sdl_types.imc"

	# create a new screen
	.sym pmc screen_settings
	new screen_settings, .PerlHash
	set screen_settings['width'],  640
	set screen_settings['height'], 480
	set screen_settings['bpp'],      0
	set screen_settings['flags'],    0

	.sym object screen
	screen = _new_SDL_Screen( screen_settings )

	# create a new rectangle
	.sym object rect
	rect   = _new_SDL_Rect()

	# create a new color
	.sym int color
	color  = _new_SDL_Color( 0, 0, 255 )

	# load an image into a new SDL Surface
	.sym object image
	image  = _new_SDL_Image( "my_image.png" )

	# create a new SDL Surface (not quite right yet)
	.sym pmc surface
	surface = _new_SDL_Surface()

	# query a surface (not quite right yet)
	.sym int width
	.sym int height

	width  = _SDL_Surface_width( surface )
	height = _SDL_Surface_height( surface )

	# loop over incoming events and call callbacks
	.include "library/sdl_constants.imc"

	.sym pmc event_handlers
	new event_handlers, .OrderedHash

	.sym pmc key_handlers
	new key_handlers, .OrderedHash

	.sym int event_type
	event_type = _sdl_constant( 'SDL_KEYDOWN' )

	.sym int key
	key = _sdl_constant( 'SDLK_SPACE' )

	.sym pmc callback
	newsub callback, .Sub, _callback_label

	set key_handlers[key], callback
	set event_handlers[event_type], key_handlers

	_SDL_loop( event_handlers )

=head1 DESCRIPTION

The functions in this library create, initialize, and return Parrot-compatible
SDL data structures.

B<Note:>  expect changes as there's lots of wrapper yet to write.

=cut

.include "datatypes.pasm"

=head1 FUNCTIONS

This library provides the following functions:

=over 4

=item _new_SDL_Screen( args )

Create and return a new object representing an SDL screen.  The single
argument, C<args>, should be a C<PerlHash> pmc containing the following keys:

=over 4

=item C<width>

the width of the screen to create, in pixels

=item C<height>

the height of the screen to create, in pixels

=item C<bpp>

the ideal bit depth of the screen to create.  Note that you may receive a
screen of lesser capabilities, as per SDL's normal behavior.

=item C<flags>

an ORd set of flags of the screen.  Note that since these bindings do not yet
expose any constants, you'll have to do math on your own or use zero.

=back

This function returns a C<ManagedStruct> pmc.

=cut

.pcc_sub _new_SDL_Screen prototyped
	.param pmc args

	.sym pmc SetVideoMode
	SetVideoMode = global "SDL::SetVideoMode"

	.sym int width
	.sym int height
	.sym int bpp
	.sym int flags

	width  = args['width']
	height = args['height']
	bpp    = args['bpp']
	flags  = args['flags']

	.sym pmc screen

	.pcc_begin prototyped
		.arg width
		.arg height
		.arg bpp
		.arg flags
		.nci_call SetVideoMode
		.result screen
	.pcc_end

	.pcc_begin_return
		.return screen
	.pcc_end_return
.end

=item _new_SDL_Rect()

Create and return a new object representing an SDL Rect.  This takes no
arguments.  It returns an C<UnManagedStruct> pmc.  You can access and modify
the following attributes of the Rect by key:

=over 4

=item x

the x position of the Rect, in pixels

=item y

the y position of the Rect, in pixels

=item width

the width of the Rect, in pixels

=item height

the height of the Rect, in pixels

=back

For example:

	.sym pmc rect
	rect           = _new_SDL_Rect()

	rect['x']      = 0
	rect['y']      = 0
	rect['height'] = 100
	rect['width']  = 100

=cut

.sub _SDL_Rect_layout prototyped
	.local pmc layout

	new layout, .OrderedHash
	set layout['x'], .DATATYPE_INT16
	push layout, 0
	push layout, 0
	set layout['y'], .DATATYPE_INT16
	push layout, 0
	push layout, 0
	set layout['width'], .DATATYPE_UINT16
	push layout, 0
	push layout, 0
	set layout['height'], .DATATYPE_UINT16
	push layout, 0
	push layout, 0

	.pcc_begin_return
		.return layout
	.pcc_end_return
.end

.sub _new_SDL_Rect prototyped
	.sym pmc layout
	layout = _SDL_Rect_layout()

	.sym pmc rect
	new rect, .ManagedStruct, layout

	.pcc_begin_return
		.return rect
	.pcc_end_return
.end

=item _new_SDL_Color( red, green, blue )

Create and return an I<integer> representing an SDL Color.  All three arguments
are required; they are the components of the color, as integers from 0 to 255.

B<Note:> this function may not currently play well with very low-depth screens
or very high-depth screens.

Do B<not> store the result of this function as a PMC, as it may exhibit strange
behavior.

=cut

.pcc_sub _new_SDL_Color prototyped
	.param int red
	.param int green
	.param int blue

	.local int color

	 color = 0
	 red   = red   << 16
	 green = green <<  8
	 blue  = blue  <<  0

	 add color, red
	 add color, green
	 add color, blue

	.pcc_begin_return
	.return color
	.pcc_end_return
.end

=item _new_SDL_Image( filename )

Create and return a new SDL Structure containing the named image.  This will
return a C<ManagedStruct> pmc.  The only parameter, C<filename> is required.
It should be the full path to a readable file.  If SDL cannot read this file,
the returned PMC will be null, in whatever sense that makes sense to SDL.

(Yes, that means there should be some sort of exception here eventually.)

=cut

.pcc_sub _new_SDL_Image prototyped
	.param string filename

	.sym pmc SDL_IMG_Load
	SDL_IMG_Load    = global "SDL::IMG_Load"

	.sym pmc image

	.pcc_begin prototyped
		.arg filename
		.nci_call SDL_IMG_Load
		.result image
	.pcc_end

	.pcc_begin_return
		.return image
	.pcc_end_return
.end

.pcc_sub _new_SDL_Event prototyped
	.sym pmc layout
	new layout, .OrderedHash

	.local int size
	.local int element_size

	# this is the only element in common in the SDL_Event union
	set layout['type'], .DATATYPE_UINT8
	push layout, 0
	push layout, 0

	# SDL_KeyboardEvent is the largest struct in the SDL_Event union
	set layout['which'], .DATATYPE_UINT8
	push layout, 0
	push layout, 0
	set layout['state'], .DATATYPE_UINT8
	push layout, 0
	push layout, 0
	set layout['padding'], .DATATYPE_UINT8
	push layout, 0
	push layout, 0
	set layout['scancode'], .DATATYPE_UINT8
	push layout, 0
	push layout, 0
	set layout['padding_a'], .DATATYPE_UINT8
	push layout, 0
	push layout, 0
	set layout['padding_b'], .DATATYPE_UINT8
	push layout, 0
	push layout, 0
	set layout['padding_c'], .DATATYPE_UINT8
	push layout, 0
	push layout, 0
	set layout['sym'], .DATATYPE_INT
	push layout, 0
	push layout, 0
	set layout['mod'], .DATATYPE_INT
	push layout, 0
	push layout, 0
	set layout['unicode'], .DATATYPE_UINT16
	push layout, 0
	push layout, 0

	.sym pmc event
	new event, .ManagedStruct, layout

	.pcc_begin_return
		.return event
	.pcc_end_return
.end

=item _SDL_Wait_Event()

XXX - not ready to expose this one yet

=cut

.pcc_sub _SDL_WaitEvent
	.sym pmc event
	event     = _new_SDL_Event()

	.sym pmc WaitEvent
	WaitEvent = global "SDL::WaitEvent"

	.sym int ret

	.pcc_begin prototyped
		.arg event
		.nci_call WaitEvent
		.result ret
	.pcc_end

	# dunno what this is
	.local string type
	typeof type, event

	.pcc_begin_return
		.return event
		.return ret
	.pcc_end_return
.end

=item _SDL_Poll_Event()

XXX - not ready to expose this one yet

=cut

.pcc_sub _SDL_PollEvent
	.sym pmc event
	event     = _new_SDL_Event()

	.sym pmc PollEvent
	PollEvent = global "SDL::PollEvent"

	.sym int ret
	
	.pcc_begin prototyped
		.arg event
		.nci_call PollEvent
		.result ret
	.pcc_end

	.pcc_begin_return
		.return event
		.return ret
	.pcc_end_return
.end

=item _SDL_loop( event_callbacks )

given an .OrderedHash associating SDL event constants to .Sub objects, loops
around input, calling the callbacks when their associated events come in.

This will call any C<idle> callback provided every 0.05 seconds (or as close as
possible) unless an event has occurred.  This should probably be configurable.

For events that have secondary distinguishing information -- for example, key
events, the value of the .OrderedHash should itself be an .OrderedHash,
associating the distinguishing constants to their callbacks.

Callbacks should return true if the loop should continue.

=cut

.pcc_sub _SDL_loop prototyped
	.param pmc events

	.sym pmc event
	.sym int type
	.sym Sub callback
	.sym num nexttime
	.sym num curtime

	time nexttime
	add nexttime, 0.05

_loop:
	exists type, events["idle"]
	if type == 0 goto _wait

_poll:
	(type, event) = _SDL_PollEvent()

	if type == 1 goto _process

	time curtime
	if curtime >= nexttime goto _idle
	sleep 0.025
	branch _poll

_idle:
	set callback, events["idle"]

	.pcc_begin prototyped
		.pcc_call callback
	.pcc_end

	time nexttime
	add nexttime, 0.05

_wait:
	event = _SDL_WaitEvent()

_process:
	set type, event['type']

	if type == 0 goto _loop

	exists $I0, events[type]
	if $I0 == 0 goto _loop

	if type == 2 goto _key_event
	if type == 3 goto _key_event

	set callback, events[type]
	goto _have_callback

_key_event:
	.sym pmc key_events
	set key_events, events[type]

	.sym int key
	set key, event['sym']

	if $I0 == 0 goto _loop

	set callback, key_events[key]

_have_callback:
	.sym int result

	# no error if the event is not defined
	typeof result, callback
	if result == .PerlUndef goto _loop
	
	.pcc_begin prototyped
		.pcc_call callback
		.result result
	.pcc_end

	if result != 0 goto _loop

	.pcc_begin_return
	.pcc_end_return
.end

=item _new_SDL_Surface()

XXX - exists, but not quite right and not public

=cut

.sub _new_SDL_Surface prototyped
	.sym pmc layout
	.sym pmc surface

	layout = _SDL_Surface_layout()
	new surface, .ManagedStruct, layout

	.pcc_begin_return
		.return surface
	.pcc_end_return
.end

.sub _SDL_Surface_height prototyped
	.param pmc surface

	.pcc_begin_return
		.return 56
	.pcc_end_return
.end

.sub _SDL_Surface_width prototyped
	.param pmc surface

	.pcc_begin_return
		.return 100
	.pcc_end_return
.end

.sub _SDL_Color_layout prototyped
	.sym pmc layout

	new layout, .OrderedHash
	set layout['r'], .DATATYPE_UINT8
	push layout, 0
	push layout, 0
	set layout['g'], .DATATYPE_UINT8
	push layout, 0
	push layout, 0
	set layout['b'], .DATATYPE_UINT8
	push layout, 0
	push layout, 0
	set layout['unused'], .DATATYPE_UINT8
	push layout, 0
	push layout, 0

	.pcc_begin_return
		.return layout
	.pcc_end_return
.end

.sub _SDL_Palette_layout prototyped
	.sym pmc layout

	new layout, .OrderedHash
	set layout['ncolors'], .DATATYPE_INT
	push layout, 0
	push layout, 0
	set layout['colors'], .DATATYPE_STRUCT_PTR

	.sym pmc c_layout
	c_layout = _SDL_Color_layout()
	set $P0, layout[-1]
	setprop $P0, '_struct', c_layout
	push layout, 0
	push layout, 0

	.pcc_begin_return
		.return layout
	.pcc_end_return
.end

.sub _SDL_PixelFormat_layout prototyped
	.sym pmc layout
	new layout, .OrderedHash
	set layout['palette'], .DATATYPE_STRUCT_PTR

	set $P0, layout[-1]
	.sym pmc p_layout
	p_layout = _SDL_Palette_layout()

	.sym pmc palette
	new palette, .UnManagedStruct, p_layout

	setprop $P0, '_struct', palette
	push layout, 0
	push layout, 0

	set layout['BytesPerPixel'], .DATATYPE_UINT8
	push layout, 0
	push layout, 0
	set layout['Rloss'], .DATATYPE_UINT8
	push layout, 0
	push layout, 0
	set layout['Gloss'], .DATATYPE_UINT8
	push layout, 0
	push layout, 0
	set layout['Bloss'], .DATATYPE_UINT8
	push layout, 0
	push layout, 0
	set layout['Aloss'], .DATATYPE_UINT8
	push layout, 0
	push layout, 0
	set layout['Rshift'], .DATATYPE_UINT8
	push layout, 0
	push layout, 0
	set layout['Gshift'], .DATATYPE_UINT8
	push layout, 0
	push layout, 0
	set layout['Bshift'], .DATATYPE_UINT8
	push layout, 0
	push layout, 0
	set layout['Ashift'], .DATATYPE_UINT8
	push layout, 0
	push layout, 0
	set layout['Rmask'], .DATATYPE_UINT32
	push layout, 0
	push layout, 0
	set layout['Gmask'], .DATATYPE_UINT32
	push layout, 0
	push layout, 0
	set layout['Bmask'], .DATATYPE_UINT32
	push layout, 0
	push layout, 0
	set layout['Amask'], .DATATYPE_UINT32
	push layout, 0
	push layout, 0
	set layout['colorkey'], .DATATYPE_UINT32
	push layout, 0
	push layout, 0
	set layout['alpha'], .DATATYPE_UINT8
	push layout, 0
	push layout, 0

	.pcc_begin_return
		.return layout
	.pcc_end_return
.end

.sub _SDL_Surface_layout prototyped
	.sym pmc layout
	new layout, .OrderedHash
	set layout['flags'], .DATATYPE_UINT32
	push layout, 0
	push layout, 0

	# SDL_PixelFormat struct pointer
	set layout['format'], .DATATYPE_STRUCT_PTR
	set $P0, layout[-1]

	.sym pmc pf_layout
	pf_layout = _SDL_PixelFormat_layout()

	.sym pmc pf
	new pf, .UnManagedStruct, pf_layout
	setprop $P0, '_struct', pf

	push layout, 0
	push layout, 0

	set layout['w'], .DATATYPE_INT
	push layout, 0
	push layout, 0
	set layout['h'], .DATATYPE_INT
	push layout, 0
	push layout, 0
	set layout['pitch'], .DATATYPE_UINT16
	push layout, 0
	push layout, 0
	set layout['pixels'], .DATATYPE_PTR
	push layout, 0
	push layout, 0
	set layout['offset'], .DATATYPE_INT
	push layout, 0
	push layout, 0

	# private_hwdata struct pointer
	set layout['hwdata'], .DATATYPE_STRUCT_PTR
	push layout, 0
	push layout, 0

	# SDL_Rect struct (inline, so needs more work here)
	.sym pmc rect
	rect = _new_SDL_Rect()

	push layout, .DATATYPE_STRUCT
	set $P0, layout[-1]
	setprop $P0, '_struct', rect
	push layout, 0
	push layout, 0

	set layout['unused1'], .DATATYPE_UINT32
	push layout, 0
	push layout, 0
	set layout['locked'], .DATATYPE_UINT32
	push layout, 0
	push layout, 0

	# SDL_BlitMap struct pointer
	set layout['map'], .DATATYPE_STRUCT_PTR
	push layout, 0
	push layout, 0

	set layout['format_version'], .DATATYPE_UINT
	push layout, 0
	push layout, 0
	set layout['refcount'], .DATATYPE_INT
	push layout, 0
	push layout, 0

	.pcc_begin_return
		.return layout
	.pcc_end_return
.end

=back

=head1 AUTHOR

Written and maintained by chromatic, E<lt>chromatic at wgz dot orgE<gt>, with
help from Jens Rieks.  Please send patches and suggestions to the Perl 6
Internals mailing list.

=head1 COPYRIGHT

Copyright (c) 2004, the Perl Foundation.

=cut
